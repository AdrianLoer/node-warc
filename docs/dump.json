[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "lib/parsers/gzipDetector.js",
    "content": "/** @ignore */\nconst fs = require('fs-extra')\n/** @ignore */\nconst untildify = require('untildify')\n\n/**\n * @see https://en.wikipedia.org/wiki/Gzip\n * @desc Gizped warc magic num:\n * - Buffer.from('1f8b08', 'hex')\n * - Uint8Array [ 31, 139, 8 ]\n * Not gziped warc magic num:\n * - Uint8Array [ 87, 65, 82 ]\n * Easier to use Uint8Arrays instead of node buffers due to allocation issues ``new Buffer(len)`` is deprecated\n * @type {Uint8Array}\n */\nconst gzipMagicNum = new Uint8Array([0x1F, 0x8B, 0x8])\n\n/**\n * @type {number} length of the gzip magic number header 3 bytes\n */\nconst gzipMagicNumLen = gzipMagicNum.length\n\n/**\n * Utility class that provides the means to detect if a file is gzipped or not\n */\nclass GzipDetector {\n  /**\n   * @desc Determines if a file is gzipped or not by reading its the magic number\n   * @param {string} filePath path to the file to detect\n   * @return {Promise.<boolean>} Promise that resolves to true if the file is gzipped false otherwise\n   * @throws {Error} if the filePath is null or undefined or if another error occurred\n   */\n  static async isGzipped (filePath) {\n    if (filePath === null || filePath === undefined) {\n      throw new Error(`The filePath path is ${filePath}`)\n    }\n    filePath = untildify(filePath)\n    const fd = await fs.open(filePath, 'r')\n    const fillMe = new Uint8Array(3)\n    await fs.read(fd, fillMe, 0, 3, undefined)\n    await fs.close(fd)\n    let i = 0\n    let isGzipped = true\n    // should never happen as we create the Unit8Array to be size 3\n    // but just in case\n    if (gzipMagicNumLen !== fillMe.length) {\n      return false\n    }\n    for (; i < gzipMagicNumLen; ++i) {\n      if (gzipMagicNum[i] !== fillMe[i]) {\n        isGzipped = false\n        break\n      }\n    }\n    return isGzipped\n  }\n\n  /**\n   * @desc Synchronous version of {@link isGzipped}\n   * @param {string} filePath path to the file to detect\n   * @return {boolean} true if the file is gzipped false otherwise\n   * @throws {Error} if the filePath is null or undefined or if another error occurred\n   */\n  static isGzippedSync (filePath) {\n    if (filePath === null || filePath === undefined) {\n      throw new Error(`The filePath path is ${filePath}`)\n    }\n    filePath = untildify(filePath)\n    const fd = fs.openSync(filePath, 'r')\n    const fillMe = new Uint8Array(3)\n    fs.readSync(fd, fillMe, 0, 3, undefined)\n    fs.closeSync(fd)\n    let i = 0\n    let isGzipped = true\n    // should never happen as we create the Unit8Array to be size 3\n    // but just in case\n    if (gzipMagicNumLen !== fillMe.length) {\n      return false\n    }\n    for (; i < gzipMagicNumLen; ++i) {\n      if (gzipMagicNum[i] !== fillMe[i]) {\n        isGzipped = false\n        break\n      }\n    }\n    return isGzipped\n  }\n}\n\nmodule.exports = GzipDetector\n",
    "static": true,
    "longname": "lib/parsers/gzipDetector.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "variable",
    "name": "fs",
    "memberof": "lib/parsers/gzipDetector.js",
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~fs",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/gzipDetector.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2,
    "kind": "variable",
    "name": "untildify",
    "memberof": "lib/parsers/gzipDetector.js",
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~untildify",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/gzipDetector.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 3,
    "kind": "variable",
    "name": "gzipMagicNum",
    "memberof": "lib/parsers/gzipDetector.js",
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~gzipMagicNum",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/gzipDetector.js",
    "importStyle": null,
    "description": "Gizped warc magic num:\n- Buffer.from('1f8b08', 'hex')\n- Uint8Array [ 31, 139, 8 ]\nNot gziped warc magic num:\n- Uint8Array [ 87, 65, 82 ]\nEasier to use Uint8Arrays instead of node buffers due to allocation issues ``new Buffer(len)`` is deprecated",
    "see": [
      "https://en.wikipedia.org/wiki/Gzip"
    ],
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 4,
    "kind": "variable",
    "name": "gzipMagicNumLen",
    "memberof": "lib/parsers/gzipDetector.js",
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~gzipMagicNumLen",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/gzipDetector.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 5,
    "kind": "class",
    "name": "GzipDetector",
    "memberof": "lib/parsers/gzipDetector.js",
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~GzipDetector",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/gzipDetector.js",
    "importStyle": null,
    "description": "Utility class that provides the means to detect if a file is gzipped or not",
    "lineNumber": 26,
    "interface": false
  },
  {
    "__docId__": 6,
    "kind": "method",
    "name": "isGzipped",
    "memberof": "lib/parsers/gzipDetector.js~GzipDetector",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~GzipDetector.isGzipped",
    "access": null,
    "description": "Determines if a file is gzipped or not by reading its the magic number",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "path to the file to detect"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<boolean>"
      ],
      "spread": false,
      "description": "Promise that resolves to true if the file is gzipped false otherwise"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the filePath is null or undefined or if another error occurred"
      }
    ]
  },
  {
    "__docId__": 7,
    "kind": "method",
    "name": "isGzippedSync",
    "memberof": "lib/parsers/gzipDetector.js~GzipDetector",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~GzipDetector.isGzippedSync",
    "access": null,
    "description": "Synchronous version of {@link isGzipped}",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "path to the file to detect"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the file is gzipped false otherwise"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the filePath is null or undefined or if another error occurred"
      }
    ]
  },
  {
    "__docId__": 8,
    "kind": "file",
    "name": "lib/parsers/index.js",
    "content": "/** @ignore */\nconst EventEmitter = require('eventemitter3')\n/** @ignore */\nconst GzipDetector = require('./gzipDetector')\n/** @ignore */\nconst WARCGzParser = require('./warcGzParser')\n/** @ignore */\nconst WARCParser = require('./warcParser')\n\n/**\n * @desc Parse a WARC file automatically detecting if it is gzipped.\n * See {@link GzipDetector}, {@link WARCGzParser}, {@link WARCParser}\n * @extends {EventEmitter}\n * @example\n *  const parser = new AutoWARCParser('<path-to-warcfile>')\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('done', finalRecord => { console.log(finalRecord) })\n *  parser.on('error', error => { console.error(error) })\n *  parser.start()\n * @example\n *  const parser = new AutoWARCParser()\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('done', finalRecord => { console.log(finalRecord) })\n *  parser.on('error', error => { console.error(error) })\n *  parser.parseWARC('<path-to-warcfile>')\n */\nclass AutoWARCParser extends EventEmitter {\n  /**\n   * @desc Create a new AutoWARCParser\n   * @param {?string} wp path to the warc file tobe parsed\n   */\n  constructor (wp = null) {\n    super()\n    /**\n     * @type {?string} the path to the WARC file to be parsed\n     * @private\n     */\n    this._wp = wp\n\n    /**\n     * @type {boolean} is the parser currently parsing the WARC\n     * @private\n     */\n    this._parsing = false\n\n    /**\n     * @type {?WARCGzParser}\n     * @private\n     */\n    this._gzipParser = null\n\n    /**\n     * @type {?WARCParser}\n     * @private\n     */\n    this._notGzipParser = null\n\n    /** @ignore */\n    this._onRecord = this._onRecord.bind(this)\n    /** @ignore */\n    this._onDone = this._onDone.bind(this)\n    /** @ignore */\n    this._onError = this._onError.bind(this)\n  }\n\n  /**\n   * @desc Begin parsing the WARC file. Once the start method has been called the parser will begin emitting\n   * @emits {record} emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record\n   * @emits {done} emitted when the WARC file has been completely parsed, the argument supplied to the listener will be last record\n   * @emits {error} emitted if an exception occurs, the argument supplied to the listener will be the error that occurred.\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC file\n   * - true: indicates the parser has begun parsing the WARC file true\n   * - false: indicated the parser is currently parsing a WARC file\n   * @throws {Error} if the path to the WARC file is null or undefined or another error occurred\n   */\n  start () {\n    if (!this._parsing) {\n      if (this._wp === null || this._wp === undefined) {\n        throw new Error('The path to the WARC file is undefined')\n      }\n      this._parsing = true\n      let isGzipped = GzipDetector.isGzippedSync(this._wp)\n      return this._getParser(isGzipped).parseWARC(this._wp)\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * @desc Alias for {@link start} except that you can supply the path to the WARC file to be parsed\n   * if one was not supplied via the constructor or to parse another WARC file. If the path to WARC file\n   * to be parsed was supplied via the constructor and you supply a different path to this method.\n   * It will override the one supplied via the constructor\n   * @param {?string} wp the path to the WARC file to be parsed\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC file\n   * @throws {Error} if the path to the WARC file is null or undefined or another error occurred\n   */\n  parseWARC (wp) {\n    if (!this._parsing) {\n      this._wp = wp || this._wp\n    }\n    return this.start()\n  }\n\n  /**\n   * @desc Lazily create a parser\n   * @param {boolean} isGzipped\n   * @return {WARCGzParser|WARCParser}\n   * @private\n   */\n  _getParser (isGzipped) {\n    if (isGzipped) {\n      if (this._gzipParser === null || this._gzipParser === undefined) {\n        this._gzipParser = new WARCGzParser()\n        this._gzipParser.on('record', this._onRecord)\n        this._gzipParser.on('done', this._onDone)\n        this._gzipParser.on('error', this._onError)\n      }\n      return this._gzipParser\n    } else {\n      if (this._notGzipParser === null || this._notGzipParser === undefined) {\n        this._notGzipParser = new WARCParser()\n        this._notGzipParser.on('record', this._onRecord)\n        this._notGzipParser.on('done', this._onDone)\n        this._notGzipParser.on('error', this._onError)\n      }\n      return this._notGzipParser\n    }\n  }\n\n  /**\n   * @desc Listener for a parsers record event\n   * @param {WARCInfoRecord|WARCMetaDataRecord|WARCRequestRecord|WARCResponseRecord} record\n   * @private\n   */\n  _onRecord (record) {\n    this.emit('record', record)\n  }\n\n  /**\n   * @desc Listener for a parsers done event\n   * @param {WARCInfoRecord|WARCMetaDataRecord|WARCRequestRecord|WARCResponseRecord} finalRecord\n   * @private\n   */\n  _onDone (finalRecord) {\n    this._parsing = false\n    this.emit('done', finalRecord)\n  }\n\n  /**\n   * @desc Listener for a parsers error event\n   * @param {Error} error\n   * @private\n   */\n  _onError (error) {\n    this.emit('error', error)\n  }\n}\n\nmodule.exports = AutoWARCParser\nmodule.exports.WARCGzParser = WARCGzParser\nmodule.exports.WARCParser = WARCParser\n",
    "static": true,
    "longname": "lib/parsers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 9,
    "kind": "variable",
    "name": "EventEmitter",
    "memberof": "lib/parsers/index.js",
    "static": true,
    "longname": "lib/parsers/index.js~EventEmitter",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 10,
    "kind": "variable",
    "name": "GzipDetector",
    "memberof": "lib/parsers/index.js",
    "static": true,
    "longname": "lib/parsers/index.js~GzipDetector",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 11,
    "kind": "variable",
    "name": "WARCGzParser",
    "memberof": "lib/parsers/index.js",
    "static": true,
    "longname": "lib/parsers/index.js~WARCGzParser",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 12,
    "kind": "variable",
    "name": "WARCParser",
    "memberof": "lib/parsers/index.js",
    "static": true,
    "longname": "lib/parsers/index.js~WARCParser",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 13,
    "kind": "class",
    "name": "AutoWARCParser",
    "memberof": "lib/parsers/index.js",
    "static": true,
    "longname": "lib/parsers/index.js~AutoWARCParser",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/index.js",
    "importStyle": null,
    "description": "Parse a WARC file automatically detecting if it is gzipped.\nSee {@link GzipDetector}, {@link WARCGzParser}, {@link WARCParser}",
    "examples": [
      " const parser = new AutoWARCParser('<path-to-warcfile>')\n parser.on('record', record => { console.log(record) })\n parser.on('done', finalRecord => { console.log(finalRecord) })\n parser.on('error', error => { console.error(error) })\n parser.start()",
      " const parser = new AutoWARCParser()\n parser.on('record', record => { console.log(record) })\n parser.on('done', finalRecord => { console.log(finalRecord) })\n parser.on('error', error => { console.error(error) })\n parser.parseWARC('<path-to-warcfile>')"
    ],
    "lineNumber": 27,
    "interface": false,
    "extends": [
      "EventEmitter"
    ]
  },
  {
    "__docId__": 14,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#constructor",
    "access": null,
    "description": "Create a new AutoWARCParser",
    "lineNumber": 32,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wp",
        "description": "path to the warc file tobe parsed"
      }
    ]
  },
  {
    "__docId__": 15,
    "kind": "member",
    "name": "_wp",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_wp",
    "access": "private",
    "description": "",
    "lineNumber": 38,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 16,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_parsing",
    "access": "private",
    "description": "",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 17,
    "kind": "member",
    "name": "_gzipParser",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_gzipParser",
    "access": "private",
    "description": "",
    "lineNumber": 50,
    "type": {
      "nullable": true,
      "types": [
        "WARCGzParser"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 18,
    "kind": "member",
    "name": "_notGzipParser",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_notGzipParser",
    "access": "private",
    "description": "",
    "lineNumber": 56,
    "type": {
      "nullable": true,
      "types": [
        "WARCParser"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 19,
    "kind": "member",
    "name": "_onRecord",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_onRecord",
    "access": null,
    "description": null,
    "lineNumber": 59,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 20,
    "kind": "member",
    "name": "_onDone",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_onDone",
    "access": null,
    "description": null,
    "lineNumber": 61,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 21,
    "kind": "member",
    "name": "_onError",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_onError",
    "access": null,
    "description": null,
    "lineNumber": 63,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 22,
    "kind": "method",
    "name": "start",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#start",
    "access": null,
    "description": "Begin parsing the WARC file. Once the start method has been called the parser will begin emitting",
    "lineNumber": 76,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC file\n- true: indicates the parser has begun parsing the WARC file true\n- false: indicated the parser is currently parsing a WARC file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC file is null or undefined or another error occurred"
      }
    ],
    "emits": [
      {
        "types": [
          "record"
        ],
        "description": "emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record"
      },
      {
        "types": [
          "done"
        ],
        "description": "emitted when the WARC file has been completely parsed, the argument supplied to the listener will be last record"
      },
      {
        "types": [
          "error"
        ],
        "description": "emitted if an exception occurs, the argument supplied to the listener will be the error that occurred."
      }
    ]
  },
  {
    "__docId__": 23,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_parsing",
    "access": null,
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 24,
    "kind": "method",
    "name": "parseWARC",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#parseWARC",
    "access": null,
    "description": "Alias for {@link start} except that you can supply the path to the WARC file to be parsed\nif one was not supplied via the constructor or to parse another WARC file. If the path to WARC file\nto be parsed was supplied via the constructor and you supply a different path to this method.\nIt will override the one supplied via the constructor",
    "lineNumber": 98,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wp",
        "description": "the path to the WARC file to be parsed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC file is null or undefined or another error occurred"
      }
    ]
  },
  {
    "__docId__": 25,
    "kind": "member",
    "name": "_wp",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_wp",
    "access": null,
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 26,
    "kind": "method",
    "name": "_getParser",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_getParser",
    "access": "private",
    "description": "Lazily create a parser",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isGzipped",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WARCGzParser",
        "WARCParser"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 27,
    "kind": "member",
    "name": "_gzipParser",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_gzipParser",
    "access": null,
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 28,
    "kind": "member",
    "name": "_notGzipParser",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_notGzipParser",
    "access": null,
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 29,
    "kind": "method",
    "name": "_onRecord",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_onRecord",
    "access": "private",
    "description": "Listener for a parsers record event",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCInfoRecord",
          "WARCMetaDataRecord",
          "WARCRequestRecord",
          "WARCResponseRecord"
        ],
        "spread": false,
        "optional": false,
        "name": "record",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 30,
    "kind": "method",
    "name": "_onDone",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_onDone",
    "access": "private",
    "description": "Listener for a parsers done event",
    "lineNumber": 145,
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCInfoRecord",
          "WARCMetaDataRecord",
          "WARCRequestRecord",
          "WARCResponseRecord"
        ],
        "spread": false,
        "optional": false,
        "name": "finalRecord",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 31,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_parsing",
    "access": null,
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 32,
    "kind": "method",
    "name": "_onError",
    "memberof": "lib/parsers/index.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/index.js~AutoWARCParser#_onError",
    "access": "private",
    "description": "Listener for a parsers error event",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 33,
    "kind": "file",
    "name": "lib/parsers/warcGzParser.js",
    "content": "/** @ignore */\nconst bsplit = require('binary-split')\n/** @ignore */\nconst untildify = require('untildify')\n/** @ignore */\nconst fs = require('fs-extra')\n/** @ignore */\nconst zlib = require('zlib')\n/** @ignore */\nconst EventEmitter = require('eventemitter3')\n/** @ignore */\nconst WARCRecorderBuilder = require('../warcRecordBuilder')\n/** @ignore */\nconst warcFieldIdentifiers = require('../warcRecordBuilder/fieldIdentifiers')\n\n/**\n * @desc Parse a WARC.gz file\n * @extends {EventEmitter}\n * @example\n *  const parser = new WARCGzParser('<path-to-warcfile>')\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('done', finalRecord => { console.log(finalRecord) })\n *  parser.on('error', error => { console.error(error) })\n *  parser.start()\n * @example\n *  const parser = new WARCGzParser()\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('done', finalRecord => { console.log(finalRecord) })\n *  parser.on('error', error => { console.error(error) })\n *  parser.parseWARC('<path-to-warcfile>')\n */\nclass WARCGzParser extends EventEmitter {\n  /**\n   * @desc Create a new WARCGzParser\n   * @param {?string} wp path to the warc.gz file tobe parsed\n   */\n  constructor (wp = null) {\n    super()\n    /**\n     * @type {?string} the path to the WARC.gz file to be parsed\n     * @private\n     */\n    this._wp = wp\n\n    /**\n     * @type {ReadStream} the underlying ReadStream\n     * @private\n     */\n    this._readStream = null\n\n    /**\n     * @type {boolean} should the parser check the current lines buffer for the warctype\n     * @private\n     */\n    this._checkRecType = false\n\n    /**\n     * @type {boolean} have we identified the records correct WARC-Type for the record\n     * @private\n     */\n    this._foundType = false\n\n    /**\n     * @type {boolean} is the parser just starting to parse the WARC.gz file\n     * @private\n     */\n    this._starting = true\n\n    /**\n     * @type {boolean} is the parser currently parsing the WARC.gz\n     * @private\n     */\n    this._parsing = false\n\n    /**\n     * @type {{count: number, increment: function, reset: function}}\n     * @private\n     */\n    this._crlfCounter = {\n      count: 0,\n      increment () {\n        this.count += 1\n      },\n      reset () {\n        this.count = 0\n      }\n    }\n    /**\n     * @type {WARCRecorderBuilder}\n     * @private\n     */\n    this._builder = new WARCRecorderBuilder()\n  }\n\n  /**\n   * @desc Begin parsing the WARC.gz file. Once the start method has been called the parser will begin emitting\n   * @emits {record} emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record\n   * @emits {done} emitted when the WARC.gz file has been completely parsed, the argument supplied to the listener will be last record\n   * @emits {error} emitted if an exception occurs, the argument supplied to the listener will be the error that occurred.\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC.gz file\n   * - true: indicates the parser has begun parsing the WARC.gz file true\n   * - false: indicated the parser is currently parsing a WARC.gz file\n   * @throws {Error} if the path to the WARC.gz file is null or undefined or another error occurred\n   */\n  start () {\n    if (!this._parsing) {\n      if (this._wp === null || this._wp === undefined) {\n        throw new Error('The path to the WARC file is undefined')\n      }\n      this._starting = true\n      this._parsing = true\n      let lastBegin\n      let buildKey\n      let isEmptyLine\n      this._readStream = fs.createReadStream(untildify(this._wp))\n      this._readStream\n        .pipe(zlib.createGunzip())\n        .pipe(bsplit())\n        .on('data', (line) => {\n          if (warcFieldIdentifiers.begin.equals(line)) {\n            if (!this._starting) {\n              this.emit('record', this._builder.buildRecord(buildKey))\n            } else {\n              this._starting = false\n            }\n            this._crlfCounter.reset()\n            this._checkRecType = true\n            lastBegin = line\n          } else {\n            isEmptyLine = warcFieldIdentifiers.empty.equals(line)\n            if (this._checkRecType && !isEmptyLine) {\n              this._checkRecType = false\n              buildKey = this._builder.determineWarcType(line, lastBegin)\n            } else if (isEmptyLine) {\n              this._crlfCounter.increment()\n            } else {\n              this._builder.addLineTo(buildKey, this._crlfCounter.count, line)\n            }\n          }\n        })\n        .on('error', error => {\n          this.emit('error', error)\n        })\n        .on('end', () => {\n          this._parsing = false\n          this._readStream.destroy()\n          let record = this._builder.buildRecord(buildKey)\n          this._builder.clear()\n          this.emit('done', record)\n        })\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * @desc Alias for {@link start} except that you can supply the path to the WARC.gz file to be parsed\n   * if one was not supplied via the constructor or to parse another WARC.gz file. If the path to WARC.gz file\n   * to be parsed was supplied via the constructor and you supply a different path to this method.\n   * It will override the one supplied via the constructor\n   * @param {?string} wp the path to the WARC.gz file to be parsed\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC.gz file\n   * @throws {Error} if the path to the WARC.gz file is null or undefined or another error occurred\n   */\n  parseWARC (wp) {\n    if (!this._parsing) {\n      this._wp = wp || this._wp\n    }\n    return this.start()\n  }\n}\n\nmodule.exports = WARCGzParser\n",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 34,
    "kind": "variable",
    "name": "bsplit",
    "memberof": "lib/parsers/warcGzParser.js",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js~bsplit",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcGzParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 35,
    "kind": "variable",
    "name": "untildify",
    "memberof": "lib/parsers/warcGzParser.js",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js~untildify",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcGzParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 36,
    "kind": "variable",
    "name": "fs",
    "memberof": "lib/parsers/warcGzParser.js",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js~fs",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcGzParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 37,
    "kind": "variable",
    "name": "zlib",
    "memberof": "lib/parsers/warcGzParser.js",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js~zlib",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcGzParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 38,
    "kind": "variable",
    "name": "EventEmitter",
    "memberof": "lib/parsers/warcGzParser.js",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js~EventEmitter",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcGzParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 39,
    "kind": "variable",
    "name": "WARCRecorderBuilder",
    "memberof": "lib/parsers/warcGzParser.js",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js~WARCRecorderBuilder",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcGzParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 40,
    "kind": "variable",
    "name": "warcFieldIdentifiers",
    "memberof": "lib/parsers/warcGzParser.js",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js~warcFieldIdentifiers",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcGzParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 41,
    "kind": "class",
    "name": "WARCGzParser",
    "memberof": "lib/parsers/warcGzParser.js",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcGzParser.js",
    "importStyle": null,
    "description": "Parse a WARC.gz file",
    "examples": [
      " const parser = new WARCGzParser('<path-to-warcfile>')\n parser.on('record', record => { console.log(record) })\n parser.on('done', finalRecord => { console.log(finalRecord) })\n parser.on('error', error => { console.error(error) })\n parser.start()",
      " const parser = new WARCGzParser()\n parser.on('record', record => { console.log(record) })\n parser.on('done', finalRecord => { console.log(finalRecord) })\n parser.on('error', error => { console.error(error) })\n parser.parseWARC('<path-to-warcfile>')"
    ],
    "lineNumber": 32,
    "interface": false,
    "extends": [
      "EventEmitter"
    ]
  },
  {
    "__docId__": 42,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#constructor",
    "access": null,
    "description": "Create a new WARCGzParser",
    "lineNumber": 37,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wp",
        "description": "path to the warc.gz file tobe parsed"
      }
    ]
  },
  {
    "__docId__": 43,
    "kind": "member",
    "name": "_wp",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_wp",
    "access": "private",
    "description": "",
    "lineNumber": 43,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 44,
    "kind": "member",
    "name": "_readStream",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_readStream",
    "access": "private",
    "description": "",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "ReadStream"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 45,
    "kind": "member",
    "name": "_checkRecType",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_checkRecType",
    "access": "private",
    "description": "",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 46,
    "kind": "member",
    "name": "_foundType",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_foundType",
    "access": "private",
    "description": "",
    "lineNumber": 61,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 47,
    "kind": "member",
    "name": "_starting",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_starting",
    "access": "private",
    "description": "",
    "lineNumber": 67,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 48,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_parsing",
    "access": "private",
    "description": "",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 49,
    "kind": "member",
    "name": "_crlfCounter",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_crlfCounter",
    "access": "private",
    "description": "",
    "lineNumber": 79,
    "type": {
      "nullable": null,
      "types": [
        "{count: number, increment: function, reset: function}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 50,
    "kind": "member",
    "name": "count",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#count",
    "access": null,
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "count",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#count",
    "access": null,
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "_builder",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_builder",
    "access": "private",
    "description": "",
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "WARCRecorderBuilder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "start",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#start",
    "access": null,
    "description": "Begin parsing the WARC.gz file. Once the start method has been called the parser will begin emitting",
    "lineNumber": 105,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC.gz file\n- true: indicates the parser has begun parsing the WARC.gz file true\n- false: indicated the parser is currently parsing a WARC.gz file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC.gz file is null or undefined or another error occurred"
      }
    ],
    "emits": [
      {
        "types": [
          "record"
        ],
        "description": "emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record"
      },
      {
        "types": [
          "done"
        ],
        "description": "emitted when the WARC.gz file has been completely parsed, the argument supplied to the listener will be last record"
      },
      {
        "types": [
          "error"
        ],
        "description": "emitted if an exception occurs, the argument supplied to the listener will be the error that occurred."
      }
    ]
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "_starting",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_starting",
    "access": null,
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_parsing",
    "access": null,
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "member",
    "name": "_readStream",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_readStream",
    "access": null,
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "_starting",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_starting",
    "access": null,
    "description": null,
    "lineNumber": 124,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "_checkRecType",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_checkRecType",
    "access": null,
    "description": null,
    "lineNumber": 127,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "_checkRecType",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_checkRecType",
    "access": null,
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_parsing",
    "access": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "parseWARC",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#parseWARC",
    "access": null,
    "description": "Alias for {@link start} except that you can supply the path to the WARC.gz file to be parsed\nif one was not supplied via the constructor or to parse another WARC.gz file. If the path to WARC.gz file\nto be parsed was supplied via the constructor and you supply a different path to this method.\nIt will override the one supplied via the constructor",
    "lineNumber": 165,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wp",
        "description": "the path to the WARC.gz file to be parsed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC.gz file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC.gz file is null or undefined or another error occurred"
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_wp",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_wp",
    "access": null,
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "file",
    "name": "lib/parsers/warcParser.js",
    "content": "/** @ignore */\nconst bsplit = require('binary-split')\n/** @ignore */\nconst untildify = require('untildify')\n/** @ignore */\nconst fs = require('fs-extra')\n/** @ignore */\nconst EventEmitter = require('eventemitter3')\n/** @ignore */\nconst WARCRecorderBuilder = require('../warcRecordBuilder')\n/** @ignore */\nconst warcFieldIdentifiers = require('../warcRecordBuilder/fieldIdentifiers')\n\n/**\n * @desc Parse a WARC file\n * @extends {EventEmitter}\n * @example\n *  const parser = new WARCParser('<path-to-warcfile>')\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('done', finalRecord => { console.log(finalRecord) })\n *  parser.on('error', error => { console.error(error) })\n *  parser.start()\n * @example\n *  const parser = new WARCParser()\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('done', finalRecord => { console.log(finalRecord) })\n *  parser.on('error', error => { console.error(error) })\n *  parser.parseWARC('<path-to-warcfile>')\n */\nclass WARCParser extends EventEmitter {\n  /**\n   * @desc Create a new WARCParser\n   * @param {?string} wp path to the warc file tobe parsed\n   */\n  constructor (wp = null) {\n    super()\n    /**\n     * @type {?string} the path to the WARC file to be parsed\n     * @private\n     */\n    this._wp = wp\n\n    /**\n     * @type {ReadStream} the underlying ReadStream\n     * @private\n     */\n    this._readStream = null\n\n    /**\n     * @type {boolean} should the parser check the current lines buffer for the warctype\n     * @private\n     */\n    this._checkRecType = false\n\n    /**\n     * @type {boolean} have we identified the records correct WARC-Type for the record\n     * @private\n     */\n    this._foundType = false\n\n    /**\n     * @type {boolean} is the parser just starting to parse the WARC file\n     * @private\n     */\n    this._starting = true\n\n    /**\n     * @type {boolean} is the parser currently parsing the WARC\n     * @private\n     */\n    this._parsing = false\n\n    /**\n     * @type {{count: number, increment: function, reset: function}}\n     * @private\n     */\n    this._crlfCounter = {\n      count: 0,\n      increment () {\n        this.count += 1\n      },\n      reset () {\n        this.count = 0\n      }\n    }\n    /**\n     * @type {WARCRecorderBuilder}\n     * @private\n     */\n    this._builder = new WARCRecorderBuilder()\n  }\n\n  /**\n   * @desc Begin parsing the WARC file. Once the start method has been called the parser will begin emitting\n   * @emits {record} emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record\n   * @emits {done} emitted when the WARC file has been completely parsed, the argument supplied to the listener will be last record\n   * @emits {error} emitted if an exception occurs, the argument supplied to the listener will be the error that occurred.\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC file\n   * - true: indicates the parser has begun parsing the WARC file true\n   * - false: indicated the parser is currently parsing a WARC file\n   * @throws {Error} if the path to the WARC file is null or undefined or another error occurred\n   */\n  start () {\n    if (!this._parsing) {\n      if (this._wp === null || this._wp === undefined) {\n        throw new Error('The path to the WARC file is undefined')\n      }\n      this._starting = true\n      this._parsing = true\n      let lastBegin\n      let buildKey\n      let isEmptyLine\n      this._readStream = fs.createReadStream(untildify(this._wp))\n      this._readStream.pipe(bsplit())\n        .on('data', (line) => {\n          if (warcFieldIdentifiers.begin.equals(line)) {\n            if (!this._starting) {\n              this.emit('record', this._builder.buildRecord(buildKey))\n            } else {\n              this._starting = false\n            }\n            this._crlfCounter.reset()\n            this._checkRecType = true\n            lastBegin = line\n          } else {\n            isEmptyLine = warcFieldIdentifiers.empty.equals(line)\n            if (this._checkRecType && !isEmptyLine) {\n              this._checkRecType = false\n              buildKey = this._builder.determineWarcType(line, lastBegin)\n            } else if (isEmptyLine) {\n              this._crlfCounter.increment()\n            } else {\n              this._builder.addLineTo(buildKey, this._crlfCounter.count, line)\n            }\n          }\n        })\n        .on('error', error => {\n          this.emit('error', error)\n        })\n        .on('end', () => {\n          this._parsing = false\n          this._readStream.destroy()\n          let record = this._builder.buildRecord(buildKey)\n          this._builder.clear()\n          this.emit('done', record)\n        })\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * @desc Alias for {@link start} except that you can supply the path to the WARC file to be parsed\n   * if one was not supplied via the constructor or to parse another WARC file. If the path to WARC file\n   * to be parsed was supplied via the constructor and you supply a different path to this method.\n   * It will override the one supplied via the constructor\n   * @param {?string} wp the path to the WARC file to be parsed\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC file\n   * @throws {Error} if the path to the WARC file is null or undefined or another error occurred\n   */\n  parseWARC (wp) {\n    if (!this._parsing) {\n      this._wp = wp || this._wp\n    }\n    return this.start()\n  }\n}\n\nmodule.exports = WARCParser\n",
    "static": true,
    "longname": "lib/parsers/warcParser.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 64,
    "kind": "variable",
    "name": "bsplit",
    "memberof": "lib/parsers/warcParser.js",
    "static": true,
    "longname": "lib/parsers/warcParser.js~bsplit",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "variable",
    "name": "untildify",
    "memberof": "lib/parsers/warcParser.js",
    "static": true,
    "longname": "lib/parsers/warcParser.js~untildify",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "variable",
    "name": "fs",
    "memberof": "lib/parsers/warcParser.js",
    "static": true,
    "longname": "lib/parsers/warcParser.js~fs",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "variable",
    "name": "EventEmitter",
    "memberof": "lib/parsers/warcParser.js",
    "static": true,
    "longname": "lib/parsers/warcParser.js~EventEmitter",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "variable",
    "name": "WARCRecorderBuilder",
    "memberof": "lib/parsers/warcParser.js",
    "static": true,
    "longname": "lib/parsers/warcParser.js~WARCRecorderBuilder",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "variable",
    "name": "warcFieldIdentifiers",
    "memberof": "lib/parsers/warcParser.js",
    "static": true,
    "longname": "lib/parsers/warcParser.js~warcFieldIdentifiers",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "class",
    "name": "WARCParser",
    "memberof": "lib/parsers/warcParser.js",
    "static": true,
    "longname": "lib/parsers/warcParser.js~WARCParser",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/parsers/warcParser.js",
    "importStyle": null,
    "description": "Parse a WARC file",
    "examples": [
      " const parser = new WARCParser('<path-to-warcfile>')\n parser.on('record', record => { console.log(record) })\n parser.on('done', finalRecord => { console.log(finalRecord) })\n parser.on('error', error => { console.error(error) })\n parser.start()",
      " const parser = new WARCParser()\n parser.on('record', record => { console.log(record) })\n parser.on('done', finalRecord => { console.log(finalRecord) })\n parser.on('error', error => { console.error(error) })\n parser.parseWARC('<path-to-warcfile>')"
    ],
    "lineNumber": 30,
    "interface": false,
    "extends": [
      "EventEmitter"
    ]
  },
  {
    "__docId__": 71,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#constructor",
    "access": null,
    "description": "Create a new WARCParser",
    "lineNumber": 35,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wp",
        "description": "path to the warc file tobe parsed"
      }
    ]
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "_wp",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_wp",
    "access": "private",
    "description": "",
    "lineNumber": 41,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "_readStream",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_readStream",
    "access": "private",
    "description": "",
    "lineNumber": 47,
    "type": {
      "nullable": null,
      "types": [
        "ReadStream"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "_checkRecType",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_checkRecType",
    "access": "private",
    "description": "",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "_foundType",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_foundType",
    "access": "private",
    "description": "",
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "_starting",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_starting",
    "access": "private",
    "description": "",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 77,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_parsing",
    "access": "private",
    "description": "",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "_crlfCounter",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_crlfCounter",
    "access": "private",
    "description": "",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "{count: number, increment: function, reset: function}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "count",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#count",
    "access": null,
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "count",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#count",
    "access": null,
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "_builder",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_builder",
    "access": "private",
    "description": "",
    "lineNumber": 90,
    "type": {
      "nullable": null,
      "types": [
        "WARCRecorderBuilder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "start",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#start",
    "access": null,
    "description": "Begin parsing the WARC file. Once the start method has been called the parser will begin emitting",
    "lineNumber": 103,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC file\n- true: indicates the parser has begun parsing the WARC file true\n- false: indicated the parser is currently parsing a WARC file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC file is null or undefined or another error occurred"
      }
    ],
    "emits": [
      {
        "types": [
          "record"
        ],
        "description": "emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record"
      },
      {
        "types": [
          "done"
        ],
        "description": "emitted when the WARC file has been completely parsed, the argument supplied to the listener will be last record"
      },
      {
        "types": [
          "error"
        ],
        "description": "emitted if an exception occurs, the argument supplied to the listener will be the error that occurred."
      }
    ]
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "_starting",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_starting",
    "access": null,
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_parsing",
    "access": null,
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "_readStream",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_readStream",
    "access": null,
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "_starting",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_starting",
    "access": null,
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "_checkRecType",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_checkRecType",
    "access": null,
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "_checkRecType",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_checkRecType",
    "access": null,
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_parsing",
    "access": null,
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "parseWARC",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#parseWARC",
    "access": null,
    "description": "Alias for {@link start} except that you can supply the path to the WARC file to be parsed\nif one was not supplied via the constructor or to parse another WARC file. If the path to WARC file\nto be parsed was supplied via the constructor and you supply a different path to this method.\nIt will override the one supplied via the constructor",
    "lineNumber": 161,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wp",
        "description": "the path to the WARC file to be parsed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC file is null or undefined or another error occurred"
      }
    ]
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "_wp",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_wp",
    "access": null,
    "description": null,
    "lineNumber": 163,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "file",
    "name": "lib/requestCapturers/electron.js",
    "content": "/** @ignore */\nconst uuid = require('uuid/v1')\n\n/**\n * @extends Map\n * @desc The remote electron request chapturer to use along side {@link ElectronWARCGenerator}\n *\n * See the documentation for {@link attach} and {@link maybeNetworkMessage} for setup information\n *\n * Controlled via {@link startCapturing} and {@link stopCapturing}\n * @see https://electron.atom.io/docs/api/debugger/\n * @see https://chromedevtools.github.io/devtools-protocol/tot/Network\n */\nclass ElectronRequestCapturer extends Map {\n  constructor () {\n    super()\n    this._capture = true\n    this.maybeNetworkMessage = this.maybeNetworkMessage.bind(this)\n    this.attach = this.attach.bind(this)\n    this._requestWillBeSent = this._requestWillBeSent.bind(this)\n    this._responseReceived = this._responseReceived.bind(this)\n    this._set = this.set.bind(this)\n\n    this.set = () => {\n      console.log('you fell for the trap!!! You cant add values to me, only I can :)')\n    }\n  }\n\n  /**\n   * @desc Attach to the debugger {@link _requestWillBeSent} and {@link _responseReceived}\n   * @param wcDebugger the debugger\n   * @see https://electron.atom.io/docs/api/debugger/\n   */\n  attach (wcDebugger) {\n    wcDebugger.on('message', (event, method, params) => {\n      if (method === 'Network.requestWillBeSent') {\n        this._requestWillBeSent(params)\n      } else if (method === 'Network.responseReceived') {\n        this._responseReceived(params)\n      }\n    })\n  }\n\n  /**\n   * @desc Rather than adding an additional listener to the debugger pass the two relevant parameters\n   * of the listener to this method. Useful if you are already listening to some other event.\n   * {@link attach}, {@link _requestWillBeSent} and {@link _responseReceived}\n   * @param {string} method the event method\n   * @param {Object} params the parameters of the event\n   * @see https://electron.atom.io/docs/api/debugger/\n   */\n  maybeNetworkMessage (method, params) {\n    if (method === 'Network.requestWillBeSent') {\n      this._requestWillBeSent(params)\n    } else if (method === 'Network.responseReceived') {\n      this._responseReceived(params)\n    }\n  }\n\n  /**\n   * @desc Sets an internal flag to begin capturing network requests\n   */\n  startCapturing () {\n    this.clear()\n    this._capture = true\n  }\n\n  /**\n   * @desc Sets an internal flag to stop the capturing network requests\n   */\n  stopCapturing () {\n    this._capture = false\n  }\n\n  /**\n   * @desc Handles the Network.requestWillBeSent event\n   * @see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent\n   * @param {Object} info\n   * @private\n   */\n  _requestWillBeSent (info) {\n    if (this._capture) {\n      if (this.has(info.requestId)) {\n        if (info.redirectResponse) {\n          if (this.get(info.requestId).redirectResponse) {\n            let cr = this.get(info.requestId)\n            if (Array.isArray(cr.redirectResponse)) {\n              cr.redirectResponse.push({\n                url: info.redirectResponse.url,\n                status: info.redirectResponse.status,\n                statusText: info.redirectResponse.statusText,\n                headers: info.redirectResponse.headers,\n                headersText: info.redirectResponse.headersText,\n                requestHeaders: info.redirectResponse.requestHeaders || info.headers,\n                requestHeadersText: info.redirectResponse.requestHeadersText,\n                method: info.redirectResponse.method,\n                protocol: info.redirectResponse.protocol\n              })\n              this._set(info.requestId, cr)\n            } else {\n              let oldRR = cr.redirectResponse\n              cr.redirectResponse = [oldRR, {\n                url: info.redirectResponse.url,\n                status: info.redirectResponse.status,\n                statusText: info.redirectResponse.statusText,\n                headers: info.redirectResponse.headers,\n                headersText: info.redirectResponse.headersText,\n                requestHeaders: info.redirectResponse.requestHeaders || info.headers,\n                requestHeadersText: info.redirectResponse.requestHeadersText,\n                method: info.redirectResponse.method,\n                protocol: info.redirectResponse.protocol\n              }]\n              this._set(info.requestId, cr)\n            }\n          } else {\n            this.get(info.requestId).redirectResponse = {\n              url: info.redirectResponse.url,\n              status: info.redirectResponse.status,\n              statusText: info.redirectResponse.statusText,\n              headers: info.redirectResponse.headers,\n              headersText: info.redirectResponse.headersText,\n              requestHeaders: info.redirectResponse.requestHeaders || info.headers,\n              requestHeadersText: info.redirectResponse.requestHeadersText,\n              method: info.redirectResponse.method,\n              protocol: info.redirectResponse.protocol\n            }\n          }\n        } else {\n          // was double request currently seems like a bug\n          // only happens when chrome is angry with us\n          // docs state that RequestId is unique and if\n          // redirect response is not on the object\n          // this should never happen or does it ????\n          let maybeRes = this.get(info.requestId)\n          if (\n            (maybeRes.headers === null || maybeRes.headers === undefined) &&\n            (maybeRes.method === null || maybeRes.method === undefined) &&\n            (maybeRes.url === null || maybeRes.url === undefined) &&\n            (maybeRes.res !== null && maybeRes.res !== undefined)\n          ) {\n            // we found you!\n            maybeRes.url = info.request.url\n            maybeRes.headers = info.request.headers\n            maybeRes.method = info.request.method\n            if (info.request.postData !== undefined && info.request.postData !== null) {\n              maybeRes.postData = info.request.postData\n            }\n            this._set(info.requestId, maybeRes)\n          } else {\n            let captured = {\n              requestId: info.requestId,\n              url: info.request.url,\n              headers: info.request.headers,\n              method: info.request.method\n            }\n            if (info.redirectResponse !== undefined && info.redirectResponse !== null) {\n              captured.redirectResponse = info.redirectResponse\n            }\n            if (info.request.postData !== undefined && info.request.postData !== null) {\n              captured.postData = info.request.postData\n            }\n            this._set(`${info.requestId}${uuid()}`, captured)\n          }\n        }\n      } else {\n        let captured = {\n          requestId: info.requestId,\n          url: info.request.url,\n          headers: info.request.headers,\n          method: info.request.method\n        }\n        if (info.redirectResponse !== undefined && info.redirectResponse !== null) {\n          captured.redirectResponse = info.redirectResponse\n        }\n        if (info.request.postData !== undefined && info.request.postData !== null) {\n          captured.postData = info.request.postData\n        }\n        this._set(info.requestId, captured)\n      }\n    }\n  }\n\n  /**\n   * @desc Handles the Network.responseReceived event\n   * @see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived\n   * @param {Object} info\n   * @private\n   */\n  _responseReceived (info) {\n    if (this._capture) {\n      if (!this.has(info.requestId)) {\n        let captured = {\n          res: {\n            url: info.response.url,\n            status: info.response.status,\n            statusText: info.response.statusText,\n            headers: info.response.headers,\n            headersText: info.response.headersText,\n            requestHeaders: info.response.requestHeaders,\n            requestHeadersText: info.response.requestHeadersText,\n            protocol: info.response.protocol\n          },\n          requestId: info.requestId\n        }\n        if (captured.res.requestHeaders !== null && captured.res.requestHeaders !== undefined) {\n          let method = captured.res.requestHeaders[':method']\n          if (method && method !== '') {\n            // http2 why you do this to me\n            captured.headers = captured.res.requestHeaders\n            captured.url = captured.res.url\n            captured.method = method\n          }\n        }\n        this._set(info.requestId, captured)\n      } else {\n        let res = this.get(info.requestId).res\n        if (res) {\n          if (Array.isArray(res)) {\n            this.get(info.requestId).res.push({\n              url: info.response.url,\n              status: info.response.status,\n              statusText: info.response.statusText,\n              headers: info.response.headers,\n              headersText: info.response.headersText,\n              requestHeaders: info.response.requestHeaders,\n              requestHeadersText: info.response.requestHeadersText,\n              protocol: info.response.protocol\n            })\n          } else {\n            this.get(info.requestId).res = [res, {\n              url: info.response.url,\n              status: info.response.status,\n              statusText: info.response.statusText,\n              headers: info.response.headers,\n              headersText: info.response.headersText,\n              requestHeaders: info.response.requestHeaders,\n              requestHeadersText: info.response.requestHeadersText,\n              protocol: info.response.protocol\n            }]\n          }\n        } else {\n          this.get(info.requestId).res = {\n            url: info.response.url,\n            status: info.response.status,\n            statusText: info.response.statusText,\n            headers: info.response.headers,\n            headersText: info.response.headersText,\n            requestHeaders: info.response.requestHeaders,\n            requestHeadersText: info.response.requestHeadersText,\n            protocol: info.response.protocol\n          }\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = ElectronRequestCapturer\n",
    "static": true,
    "longname": "lib/requestCapturers/electron.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 93,
    "kind": "variable",
    "name": "uuid",
    "memberof": "lib/requestCapturers/electron.js",
    "static": true,
    "longname": "lib/requestCapturers/electron.js~uuid",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/requestCapturers/electron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "class",
    "name": "ElectronRequestCapturer",
    "memberof": "lib/requestCapturers/electron.js",
    "static": true,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/requestCapturers/electron.js",
    "importStyle": null,
    "description": "The remote electron request chapturer to use along side {@link ElectronWARCGenerator}\n\nSee the documentation for {@link attach} and {@link maybeNetworkMessage} for setup information\n\nControlled via {@link startCapturing} and {@link stopCapturing}",
    "see": [
      "https://electron.atom.io/docs/api/debugger/",
      "https://chromedevtools.github.io/devtools-protocol/tot/Network"
    ],
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 95,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#constructor",
    "access": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "_capture",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#_capture",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "maybeNetworkMessage",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#maybeNetworkMessage",
    "access": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "attach",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#attach",
    "access": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "_requestWillBeSent",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#_requestWillBeSent",
    "access": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "_responseReceived",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#_responseReceived",
    "access": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "_set",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#_set",
    "access": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "set",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#set",
    "access": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "attach",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#attach",
    "access": null,
    "description": "Attach to the debugger {@link _requestWillBeSent} and {@link _responseReceived}",
    "see": [
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the debugger"
      }
    ]
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "maybeNetworkMessage",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#maybeNetworkMessage",
    "access": null,
    "description": "Rather than adding an additional listener to the debugger pass the two relevant parameters\nof the listener to this method. Useful if you are already listening to some other event.\n{@link attach}, {@link _requestWillBeSent} and {@link _responseReceived}",
    "see": [
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "the event method"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the parameters of the event"
      }
    ]
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "startCapturing",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#startCapturing",
    "access": null,
    "description": "Sets an internal flag to begin capturing network requests",
    "lineNumber": 63,
    "params": []
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "_capture",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#_capture",
    "access": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "stopCapturing",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#stopCapturing",
    "access": null,
    "description": "Sets an internal flag to stop the capturing network requests",
    "lineNumber": 71,
    "params": []
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_capture",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#_capture",
    "access": null,
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "_requestWillBeSent",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#_requestWillBeSent",
    "access": "private",
    "description": "Handles the Network.requestWillBeSent event",
    "see": [
      "https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent"
    ],
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "_responseReceived",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#_responseReceived",
    "access": "private",
    "description": "Handles the Network.responseReceived event",
    "see": [
      "https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived"
    ],
    "lineNumber": 189,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 111,
    "kind": "file",
    "name": "lib/requestCapturers/index.js",
    "content": "module.exports = {\n  ElectronCapturer: require('./electron'),\n  RemoteChromeCapturer: require('./remoteChrome')\n}\n",
    "static": true,
    "longname": "lib/requestCapturers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 112,
    "kind": "file",
    "name": "lib/requestCapturers/remoteChrome.js",
    "content": "/** @ignore */\nconst uuid = require('uuid/v1')\n\n/**\n * @extends Map\n * @desc The remote chrome request chapturer to use along side {@link RemoteChromeWARCGenerator}\n *\n * The only setup required is to pass the chrome-remote-interface Network object\n *\n * Controlled via {@link startCapturing} and {@link stopCapturing}\n * @see https://github.com/cyrus-and/chrome-remote-interface\n * @see https://chromedevtools.github.io/devtools-protocol/tot/Network\n */\nclass RemoteChromeRequestCapturer extends Map {\n  /**\n   * @param {Object} network the chrome-remote-interface Network object\n   */\n  constructor (network) {\n    super()\n    this._capture = true\n    this._requestWillBeSent = this._requestWillBeSent.bind(this)\n    this._responseReceived = this._responseReceived.bind(this)\n    this._set = this.set.bind(this)\n\n    this.set = () => {\n      console.log('you fell for the trap!!! You cant add values to me, only I can :)')\n    }\n    network.requestWillBeSent(this._requestWillBeSent)\n    network.responseReceived(this._responseReceived)\n  }\n\n  /**\n   * @desc Sets an internal flag to begin capturing network requests\n   */\n  startCapturing () {\n    this.clear()\n    this._capture = true\n  }\n\n  /**\n   * @desc Sets an internal flag to stop the capturing network requests\n   */\n  stopCapturing () {\n    this._capture = false\n  }\n\n  /**\n   * @desc Handles the Network.requestWillBeSent event\n   * @see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent\n   * @param {Object} info\n   * @private\n   */\n  _requestWillBeSent (info) {\n    if (this._capture) {\n      if (this.has(info.requestId)) {\n        if (info.redirectResponse) {\n          if (this.get(info.requestId).redirectResponse) {\n            let cr = this.get(info.requestId)\n            if (Array.isArray(cr.redirectResponse)) {\n              cr.redirectResponse.push({\n                url: info.redirectResponse.url,\n                status: info.redirectResponse.status,\n                statusText: info.redirectResponse.statusText,\n                headers: info.redirectResponse.headers,\n                headersText: info.redirectResponse.headersText,\n                requestHeaders: info.redirectResponse.requestHeaders || info.headers,\n                requestHeadersText: info.redirectResponse.requestHeadersText,\n                method: info.redirectResponse.method,\n                protocol: info.redirectResponse.protocol\n              })\n              this._set(info.requestId, cr)\n            } else {\n              let oldRR = cr.redirectResponse\n              cr.redirectResponse = [oldRR, {\n                url: info.redirectResponse.url,\n                status: info.redirectResponse.status,\n                statusText: info.redirectResponse.statusText,\n                headers: info.redirectResponse.headers,\n                headersText: info.redirectResponse.headersText,\n                requestHeaders: info.redirectResponse.requestHeaders || info.headers,\n                requestHeadersText: info.redirectResponse.requestHeadersText,\n                method: info.redirectResponse.method,\n                protocol: info.redirectResponse.protocol\n              }]\n              this._set(info.requestId, cr)\n            }\n          } else {\n            this.get(info.requestId).redirectResponse = {\n              url: info.redirectResponse.url,\n              status: info.redirectResponse.status,\n              statusText: info.redirectResponse.statusText,\n              headers: info.redirectResponse.headers,\n              headersText: info.redirectResponse.headersText,\n              requestHeaders: info.redirectResponse.requestHeaders || info.headers,\n              requestHeadersText: info.redirectResponse.requestHeadersText,\n              method: info.redirectResponse.method,\n              protocol: info.redirectResponse.protocol\n            }\n          }\n        } else {\n          // was double request currently seems like a bug\n          // only happens when chrome is angry with us\n          // docs state that RequestId is unique and if\n          // redirect response is not on the object\n          // this should never happen or does it ????\n          let maybeRes = this.get(info.requestId)\n          if (\n            (maybeRes.headers === null || maybeRes.headers === undefined) &&\n            (maybeRes.method === null || maybeRes.method === undefined) &&\n            (maybeRes.url === null || maybeRes.url === undefined) &&\n            (maybeRes.res !== null && maybeRes.res !== undefined)\n          ) {\n            // we found you!\n            maybeRes.url = info.request.url\n            maybeRes.headers = info.request.headers\n            maybeRes.method = info.request.method\n            if (info.request.postData !== undefined && info.request.postData !== null) {\n              maybeRes.postData = info.request.postData\n            }\n            this._set(info.requestId, maybeRes)\n          } else {\n            let captured = {\n              requestId: info.requestId,\n              url: info.request.url,\n              headers: info.request.headers,\n              method: info.request.method\n            }\n            if (info.redirectResponse !== undefined && info.redirectResponse !== null) {\n              captured.redirectResponse = info.redirectResponse\n            }\n            if (info.request.postData !== undefined && info.request.postData !== null) {\n              captured.postData = info.request.postData\n            }\n            this._set(`${info.requestId}${uuid()}`, captured)\n          }\n        }\n      } else {\n        let captured = {\n          requestId: info.requestId,\n          url: info.request.url,\n          headers: info.request.headers,\n          method: info.request.method\n        }\n        if (info.redirectResponse !== undefined && info.redirectResponse !== null) {\n          captured.redirectResponse = info.redirectResponse\n        }\n        if (info.request.postData !== undefined && info.request.postData !== null) {\n          captured.postData = info.request.postData\n        }\n        this._set(info.requestId, captured)\n      }\n    }\n  }\n\n  /**\n   * @desc Handles the Network.responseReceived event\n   * @see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived\n   * @param {Object} info\n   * @private\n   */\n  _responseReceived (info) {\n    if (this._capture) {\n      if (!this.has(info.requestId)) {\n        let captured = {\n          res: {\n            url: info.response.url,\n            status: info.response.status,\n            statusText: info.response.statusText,\n            headers: info.response.headers,\n            headersText: info.response.headersText,\n            requestHeaders: info.response.requestHeaders,\n            requestHeadersText: info.response.requestHeadersText,\n            protocol: info.response.protocol\n          },\n          requestId: info.requestId\n        }\n        if (captured.res.requestHeaders !== null && captured.res.requestHeaders !== undefined) {\n          let method = captured.res.requestHeaders[':method']\n          if (method && method !== '') {\n            // http2 why you do this to me\n            captured.headers = captured.res.requestHeaders\n            captured.url = captured.res.url\n            captured.method = method\n          }\n        }\n        this._set(info.requestId, captured)\n      } else {\n        let res = this.get(info.requestId).res\n        if (res) {\n          if (Array.isArray(res)) {\n            this.get(info.requestId).res.push({\n              url: info.response.url,\n              status: info.response.status,\n              statusText: info.response.statusText,\n              headers: info.response.headers,\n              headersText: info.response.headersText,\n              requestHeaders: info.response.requestHeaders,\n              requestHeadersText: info.response.requestHeadersText,\n              protocol: info.response.protocol\n            })\n          } else {\n            this.get(info.requestId).res = [res, {\n              url: info.response.url,\n              status: info.response.status,\n              statusText: info.response.statusText,\n              headers: info.response.headers,\n              headersText: info.response.headersText,\n              requestHeaders: info.response.requestHeaders,\n              requestHeadersText: info.response.requestHeadersText,\n              protocol: info.response.protocol\n            }]\n          }\n        } else {\n          this.get(info.requestId).res = {\n            url: info.response.url,\n            status: info.response.status,\n            statusText: info.response.statusText,\n            headers: info.response.headers,\n            headersText: info.response.headersText,\n            requestHeaders: info.response.requestHeaders,\n            requestHeadersText: info.response.requestHeadersText,\n            protocol: info.response.protocol\n          }\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = RemoteChromeRequestCapturer\n",
    "static": true,
    "longname": "lib/requestCapturers/remoteChrome.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 113,
    "kind": "variable",
    "name": "uuid",
    "memberof": "lib/requestCapturers/remoteChrome.js",
    "static": true,
    "longname": "lib/requestCapturers/remoteChrome.js~uuid",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/requestCapturers/remoteChrome.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "class",
    "name": "RemoteChromeRequestCapturer",
    "memberof": "lib/requestCapturers/remoteChrome.js",
    "static": true,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/requestCapturers/remoteChrome.js",
    "importStyle": null,
    "description": "The remote chrome request chapturer to use along side {@link RemoteChromeWARCGenerator}\n\nThe only setup required is to pass the chrome-remote-interface Network object\n\nControlled via {@link startCapturing} and {@link stopCapturing}",
    "see": [
      "https://github.com/cyrus-and/chrome-remote-interface",
      "https://chromedevtools.github.io/devtools-protocol/tot/Network"
    ],
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 115,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#constructor",
    "access": null,
    "description": "",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "the chrome-remote-interface Network object"
      }
    ]
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "_capture",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#_capture",
    "access": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "_requestWillBeSent",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#_requestWillBeSent",
    "access": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "_responseReceived",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#_responseReceived",
    "access": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "_set",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#_set",
    "access": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "set",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#set",
    "access": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "startCapturing",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#startCapturing",
    "access": null,
    "description": "Sets an internal flag to begin capturing network requests",
    "lineNumber": 35,
    "params": []
  },
  {
    "__docId__": 122,
    "kind": "member",
    "name": "_capture",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#_capture",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "stopCapturing",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#stopCapturing",
    "access": null,
    "description": "Sets an internal flag to stop the capturing network requests",
    "lineNumber": 43,
    "params": []
  },
  {
    "__docId__": 124,
    "kind": "member",
    "name": "_capture",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#_capture",
    "access": null,
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "_requestWillBeSent",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#_requestWillBeSent",
    "access": "private",
    "description": "Handles the Network.requestWillBeSent event",
    "see": [
      "https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent"
    ],
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "_responseReceived",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#_responseReceived",
    "access": "private",
    "description": "Handles the Network.responseReceived event",
    "see": [
      "https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived"
    ],
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 127,
    "kind": "file",
    "name": "lib/utils/electronGetResError.js",
    "content": "/**\n * @desc Electron debugger errors passed to the callback are plain objects not Errors\n * but contain information concerning the error.\n */\nclass ElectronGetResError extends Error {\n  /**\n   * @param {Object} oError - the error supplied to the callback\n   * @param {string} rid - the request id of the request retrieval of the response body failed for\n   */\n  constructor (oError, rid) {\n    super(oError.message || `An Error Occurred retrieving the response body for ${rid}`)\n\n    /**\n     * @desc the original error object supplied to the callback\n     * @type {Object}\n     */\n    this.oError = oError\n    /**\n     * @desc the request id of the request retrieval of the response body failed for\n     * @type {string}\n     */\n    this.rid = rid\n  }\n}\n\nmodule.exports = ElectronGetResError\n",
    "static": true,
    "longname": "lib/utils/electronGetResError.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 128,
    "kind": "class",
    "name": "ElectronGetResError",
    "memberof": "lib/utils/electronGetResError.js",
    "static": true,
    "longname": "lib/utils/electronGetResError.js~ElectronGetResError",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/utils/electronGetResError.js",
    "importStyle": null,
    "description": "Electron debugger errors passed to the callback are plain objects not Errors\nbut contain information concerning the error.",
    "lineNumber": 5,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 129,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils/electronGetResError.js~ElectronGetResError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils/electronGetResError.js~ElectronGetResError#constructor",
    "access": null,
    "description": "",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "oError",
        "description": "the error supplied to the callback"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rid",
        "description": "the request id of the request retrieval of the response body failed for"
      }
    ]
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "oError",
    "memberof": "lib/utils/electronGetResError.js~ElectronGetResError",
    "static": false,
    "longname": "lib/utils/electronGetResError.js~ElectronGetResError#oError",
    "access": null,
    "description": "the original error object supplied to the callback",
    "lineNumber": 17,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 131,
    "kind": "member",
    "name": "rid",
    "memberof": "lib/utils/electronGetResError.js~ElectronGetResError",
    "static": false,
    "longname": "lib/utils/electronGetResError.js~ElectronGetResError#rid",
    "access": null,
    "description": "the request id of the request retrieval of the response body failed for",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 132,
    "kind": "file",
    "name": "lib/utils/getResBodyElectron.js",
    "content": "/** @ignore */\nconst Promise = require('bluebird')\n/** @ignore */\nconst isEmpty = require('lodash.isempty')\nconst ElectronGetResError = require('./electronGetResError')\n\n/**\n * @desc Electron requires the use of the debugger to retrieve the requests response body\n * @param {string} requestId the request to fetch the response body for\n * @param wcDebugger the Electron debugger to use to get the response body\n * @see https://electron.atom.io/docs/api/debugger/\n * @return {Promise<Buffer>} body - the response body as a node buffer\n * @throws {ElectronGetResError} - rejects if the error parameter to the callback was set\n */\nfunction getResBodyElectron (requestId, wcDebugger) {\n  return new Promise((resolve, reject) => {\n    wcDebugger.sendCommand('Network.getResponseBody', {requestId}, (error, body) => {\n      if (!isEmpty(error)) {\n        reject(new ElectronGetResError(error, requestId))\n      } else {\n        resolve(body)\n      }\n    })\n  })\n}\n\nmodule.exports = getResBodyElectron\n",
    "static": true,
    "longname": "lib/utils/getResBodyElectron.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 133,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/utils/getResBodyElectron.js",
    "static": true,
    "longname": "lib/utils/getResBodyElectron.js~Promise",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/utils/getResBodyElectron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "variable",
    "name": "isEmpty",
    "memberof": "lib/utils/getResBodyElectron.js",
    "static": true,
    "longname": "lib/utils/getResBodyElectron.js~isEmpty",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/utils/getResBodyElectron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "variable",
    "name": "ElectronGetResError",
    "memberof": "lib/utils/getResBodyElectron.js",
    "static": true,
    "longname": "lib/utils/getResBodyElectron.js~ElectronGetResError",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/utils/getResBodyElectron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "function",
    "name": "getResBodyElectron",
    "memberof": "lib/utils/getResBodyElectron.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/getResBodyElectron.js~getResBodyElectron",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/utils/getResBodyElectron.js",
    "importStyle": null,
    "description": "Electron requires the use of the debugger to retrieve the requests response body",
    "see": [
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestId",
        "description": "the request to fetch the response body for"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the Electron debugger to use to get the response body"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Buffer>"
      ],
      "spread": false,
      "description": "body - the response body as a node buffer"
    },
    "throws": [
      {
        "types": [
          "ElectronGetResError"
        ],
        "description": "rejects if the error parameter to the callback was set"
      }
    ]
  },
  {
    "__docId__": 137,
    "kind": "file",
    "name": "lib/utils/index.js",
    "content": "module.exports = {\n  isEmptyPlainObject: require('./isEmptyPlainObject'),\n  getResBodyElectron: require('./getResBodyElectron')\n}\n",
    "static": true,
    "longname": "lib/utils/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 138,
    "kind": "file",
    "name": "lib/utils/isEmptyPlainObject.js",
    "content": "const isEmpty = require('lodash.isempty')\n\n/**\n * @desc Test to see if a ``plain object`` is empty\n * @param {Object?} object\n * @return {boolean}\n */\nfunction isEmptyPlainObject (object) {\n  if (object === null || object === undefined) {\n    return true\n  }\n  return isEmpty(object)\n}\n\nmodule.exports = isEmptyPlainObject\n",
    "static": true,
    "longname": "lib/utils/isEmptyPlainObject.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 139,
    "kind": "variable",
    "name": "isEmpty",
    "memberof": "lib/utils/isEmptyPlainObject.js",
    "static": true,
    "longname": "lib/utils/isEmptyPlainObject.js~isEmpty",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/utils/isEmptyPlainObject.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "function",
    "name": "isEmptyPlainObject",
    "memberof": "lib/utils/isEmptyPlainObject.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/isEmptyPlainObject.js~isEmptyPlainObject",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/utils/isEmptyPlainObject.js",
    "importStyle": null,
    "description": "Test to see if a ``plain object`` is empty",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object?"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 141,
    "kind": "file",
    "name": "lib/warcRecordBuilder/buildKeys.js",
    "content": "/**\n * @desc Keys used by {@link WARCRecorderBuilder} to identify which WARC Record is currently being built\n * @type {{builderKeyInfo: Symbol, builderKeyMdata: Symbol, builderKeyReq: Symbol, builderKeyRes: Symbol, builderKeyRev: Symbol,builderKeyResource: Symbol,builderKeyUnknown: Symbol}}\n */\nconst buildKeys = {\n  builderKeyInfo: Symbol('info'),\n  builderKeyMdata: Symbol('mdata'),\n  builderKeyReq: Symbol('req'),\n  builderKeyRes: Symbol('res'),\n  builderKeyRev: Symbol('revisit'),\n  builderKeyResource: Symbol('resource'),\n  builderKeyUnknown: Symbol('unkown')\n}\n\nmodule.exports = buildKeys\n",
    "static": true,
    "longname": "lib/warcRecordBuilder/buildKeys.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 142,
    "kind": "variable",
    "name": "buildKeys",
    "memberof": "lib/warcRecordBuilder/buildKeys.js",
    "static": true,
    "longname": "lib/warcRecordBuilder/buildKeys.js~buildKeys",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecordBuilder/buildKeys.js",
    "importStyle": null,
    "description": "Keys used by {@link WARCRecorderBuilder} to identify which WARC Record is currently being built",
    "lineNumber": 5,
    "type": {
      "nullable": null,
      "types": [
        "{builderKeyInfo: Symbol, builderKeyMdata: Symbol, builderKeyReq: Symbol, builderKeyRes: Symbol, builderKeyRev: Symbol,builderKeyResource: Symbol,builderKeyUnknown: Symbol}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 143,
    "kind": "file",
    "name": "lib/warcRecordBuilder/fieldIdentifiers.js",
    "content": "/**\n * @desc Buffers from hex strings representing the a WARC records WARC-TYPE or record/record-section separator\n * as seen by the parser. Due to the large size of WARC files and the binary data contained within it is more efficient\n * to parse the files contents looking for these sentinels than converting the buffer to an UTF-8 string first\n * @type {{begin: Buffer, info: Buffer, mdata: Buffer, req: Buffer, res: Buffer, revisit: Buffer, crlf: Buffer, empty: Buffer}}\n */\nconst fieldIdentifiers = {\n  begin: Buffer.from('574152432f312e300d', 'hex'),\n  info: Buffer.from('574152432d547970653a2077617263696e666f0d', 'hex'),\n  mdata: Buffer.from('574152432d547970653a206d657461646174610d', 'hex'),\n  req: Buffer.from('574152432d547970653a20726571756573740d', 'hex'),\n  res: Buffer.from('574152432d547970653a20726573706f6e73650d', 'hex'),\n  revisit: Buffer.from('574152432d547970653a20726576697369740d', 'hex'),\n  resource: Buffer.from('574152432d547970653a207265736f757263650d', 'hex'),\n  crlf: Buffer.from('0d0a', 'hex'),\n  empty: Buffer.from('0d', 'hex')\n}\n\nmodule.exports = fieldIdentifiers\n",
    "static": true,
    "longname": "lib/warcRecordBuilder/fieldIdentifiers.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 144,
    "kind": "variable",
    "name": "fieldIdentifiers",
    "memberof": "lib/warcRecordBuilder/fieldIdentifiers.js",
    "static": true,
    "longname": "lib/warcRecordBuilder/fieldIdentifiers.js~fieldIdentifiers",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecordBuilder/fieldIdentifiers.js",
    "importStyle": null,
    "description": "Buffers from hex strings representing the a WARC records WARC-TYPE or record/record-section separator\nas seen by the parser. Due to the large size of WARC files and the binary data contained within it is more efficient\nto parse the files contents looking for these sentinels than converting the buffer to an UTF-8 string first",
    "lineNumber": 7,
    "type": {
      "nullable": null,
      "types": [
        "{begin: Buffer, info: Buffer, mdata: Buffer, req: Buffer, res: Buffer, revisit: Buffer, crlf: Buffer, empty: Buffer}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 145,
    "kind": "file",
    "name": "lib/warcRecordBuilder/index.js",
    "content": "/** @ignore */\nconst {\n  builderKeyInfo,\n  builderKeyMdata,\n  builderKeyReq,\n  builderKeyRes,\n  builderKeyRev,\n  builderKeyResource,\n  builderKeyUnknown\n} = require('./buildKeys')\n/** @ignore */\nconst {\n  WARCInfoRecord,\n  WARCMetaDataRecord,\n  WARCRequestRecord,\n  WARCResponseRecord,\n  WARCRevisitRecord,\n  WARCUnknownRecord,\n  WARCResourceRecord\n} = require('../warcRecords')\n/** @ignore */\nconst warcFieldIdentifiers = require('./fieldIdentifiers')\n\n/**\n * @desc Builds WARC Records by keeping track internally of the current WARC Record WARC-TYPE being parsed\n * by a parser e.g. {@link WARCGzParser}\n */\nclass WARCRecorderBuilder {\n  /**\n   * @desc Construct a new WARCRecorderBuilder\n   */\n  constructor () {\n    /**\n     * @type {?Map}\n     * @private\n     */\n    this._info = null\n\n    /**\n     * @type {?Map}\n     * @private\n     */\n    this._mdata = null\n\n    /**\n     * @type {?Map}\n     * @private\n     */\n    this._req = null\n\n    /**\n     * @type {?Map}\n     * @private\n     */\n    this._res = null\n\n    /**\n     * @type {?Map}\n     * @private\n     */\n    this._rev = null\n\n    /**\n     * @type {?Map}\n     * @private\n     */\n    this._resource = null\n\n    /**\n     * @type {?Map}\n     * @private\n     */\n    this._unkown = null\n  }\n\n  /**\n   * @desc determine the WARC-Type for the record\n   * @param {Buffer} line the WARC-Type line\n   * @param {Buffer} lastBegin the WARC/1.0 line (WARC record begin)\n   * @return {Symbol} the record key that identifies the WARC-Type being parsed\n   * @public\n   */\n  determineWarcType (line, lastBegin) {\n    let foundType = warcFieldIdentifiers.req.equals(line)\n    if (foundType) {\n      return this.initReq(lastBegin, line)\n    } else {\n      foundType = warcFieldIdentifiers.res.equals(line)\n      if (foundType) {\n        return this.initRes(lastBegin, line)\n      } else {\n        foundType = warcFieldIdentifiers.revisit.equals(line)\n        if (foundType) {\n          return this.initRevist(lastBegin, line)\n        } else {\n          foundType = warcFieldIdentifiers.info.equals(line)\n          if (foundType) {\n            return this.initInfo(lastBegin, line)\n          } else {\n            foundType = warcFieldIdentifiers.mdata.equals(line)\n            if (foundType) {\n              return this.initMdata(lastBegin, line)\n            } else {\n              foundType = warcFieldIdentifiers.resource.equals(line)\n              if (foundType) {\n                return this.initResource(lastBegin, line)\n              }\n              // console.log('unknown warc type', line, line.toString())\n              return this.initUnknown(lastBegin, line)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @desc Begin building WARC-TYPE: warcinfo\n   * @param {Buffer} bgn the WARC/1.0 line\n   * @param {Buffer} line the WARC-TYPE line\n   * @return {Symbol} the internal record key for the warcinfo record currently being built\n   */\n  initInfo (bgn, line) {\n    if (this._info === null) {\n      this._info = new Map()\n    }\n    this._info.clear()\n    this._info.set('header', [bgn, line])\n    this._info.set('content', [])\n    return builderKeyInfo\n  }\n\n  /**\n   * @desc Begin building WARC-TYPE: metadata\n   * @param {Buffer} bgn the WARC/1.0 line\n   * @param {Buffer} line the WARC-TYPE line\n   * @return {Symbol} the internal record key for the metadata record currently being built\n   */\n  initMdata (bgn, line) {\n    if (this._mdata === null) {\n      this._mdata = new Map()\n    }\n    this._mdata.clear()\n    this._mdata.set('header', [bgn, line])\n    this._mdata.set('content', [])\n    return builderKeyMdata\n  }\n\n  /**\n   * @desc Begin building WARC-TYPE: request\n   * @param {Buffer} bgn the WARC/1.0 line\n   * @param {Buffer} line the WARC-TYPE line\n   * @return {Symbol} the internal record key for the request record currently being built\n   */\n  initReq (bgn, line) {\n    if (this._req === null) {\n      this._req = new Map()\n    }\n    this._req.clear()\n    this._req.set('header', [bgn, line])\n    this._req.set('http', [])\n    this._req.set('post', [])\n    return builderKeyReq\n  }\n\n  /**\n   * @desc Begin building WARC-TYPE: response\n   * @param {Buffer} bgn the WARC/1.0 line\n   * @param {Buffer} line the WARC-TYPE line\n   * @return {Symbol} the internal record key for the response record currently being built\n   */\n  initRes (bgn, line) {\n    if (this._res === null) {\n      this._res = new Map()\n    }\n    this._res.clear()\n    this._res.set('header', [bgn, line])\n    this._res.set('http', [])\n    this._res.set('body', [])\n    return builderKeyRes\n  }\n\n  /**\n   * @desc Begin building WARC-TYPE: revisit\n   * @param {Buffer} bgn the WARC/1.0 line\n   * @param {Buffer} line the WARC-TYPE line\n   * @return {Symbol} the internal record key for the revisit record currently being built\n   */\n  initRevist (bgn, line) {\n    if (this._rev === null) {\n      this._rev = new Map()\n    }\n    this._rev.clear()\n    this._rev.set('header', [bgn, line])\n    this._rev.set('http', [])\n    return builderKeyRev\n  }\n\n  /**\n   * @desc Begin building WARC-TYPE: revisit\n   * @param {Buffer} bgn the WARC/1.0 line\n   * @param {Buffer} line the WARC-TYPE line\n   * @return {Symbol} the internal record key for the revisit record currently being built\n   */\n  initUnknown (bgn, line) {\n    if (this._unkown === null) {\n      this._unkown = new Map()\n    }\n    this._unkown.clear()\n    this._unkown.set('header', [bgn, line])\n    return builderKeyUnknown\n  }\n\n  /**\n   * @desc Begin building WARC-TYPE: resource\n   * @param {Buffer} bgn the WARC/1.0 line\n   * @param {Buffer} line the WARC-TYPE line\n   * @return {Symbol} the internal record key for the resource record currently being built\n   */\n  initResource (bgn, line) {\n    if (this._resource === null) {\n      this._resource = new Map()\n    }\n    this._resource.clear()\n    this._resource.set('header', [bgn, line])\n    this._resource.set('content', [])\n    return builderKeyResource\n  }\n\n  /**\n   * @desc Add the current line being parsed to a record currently being built\n   * @param {Symbol} key the internal record key for the response record currently being built exposed by\n   * {@link initInfo}, {@link initMdata}, {@link initRes} and {@link initReq}\n   * @param {number} ctrlfCount the current count of Control LineFeeds between WARC Record parts\n   * @param {Buffer} line the current line being parsed\n   */\n  addLineTo (key, ctrlfCount, line) {\n    switch (key) {\n      case builderKeyInfo:\n        this._addInfoLine(ctrlfCount, line)\n        break\n      case builderKeyMdata:\n        this._addMdataLine(ctrlfCount, line)\n        break\n      case builderKeyReq:\n        this._addReqLine(ctrlfCount, line)\n        break\n      case builderKeyRes:\n        this._addResLine(ctrlfCount, line)\n        break\n      case builderKeyRev:\n        this._addRevLine(ctrlfCount, line)\n        break\n      case builderKeyResource:\n        this._addResourceLine(ctrlfCount, line)\n        break\n      case builderKeyUnknown:\n        this._addUnkownLine(ctrlfCount, line)\n        break\n    }\n  }\n\n  /**\n   * @desc Build the record currently being parsed\n   * @param {Symbol} key the internal record key for the response record currently being built exposed by\n   * {@link initInfo}, {@link initMdata}, {@link initRes} and {@link initReq}\n   * @return {WARCInfoRecord|WARCMetaDataRecord|WARCRequestRecord|WARCResponseRecord|WARCRevisitRecord|WARCUnknownRecord} based off the ``key`` supplied to\n   * this method\n   */\n  buildRecord (key) {\n    let record\n    switch (key) {\n      case builderKeyInfo:\n        record = new WARCInfoRecord(...this._info.values())\n        this._info.clear()\n        break\n      case builderKeyMdata:\n        record = new WARCMetaDataRecord(...this._mdata.values())\n        this._mdata.clear()\n        break\n      case builderKeyReq:\n        record = new WARCRequestRecord(...this._req.values())\n        this._req.clear()\n        break\n      case builderKeyRes:\n        record = new WARCResponseRecord(...this._res.values())\n        this._res.clear()\n        break\n      case builderKeyRev:\n        record = new WARCRevisitRecord(...this._rev.values())\n        this._rev.clear()\n        break\n      case builderKeyResource:\n        record = new WARCResourceRecord(...this._resource.values())\n        this._resource.clear()\n        break\n      case builderKeyUnknown:\n        record = this._attemptCorrection()\n        this._unkown.clear()\n        break\n    }\n    return record\n  }\n\n  _attemptCorrection () {\n    let headers = this._unkown.get('header')\n    let len = headers.length\n    let i = 0\n    for (; i < len; ++i) {\n      if (warcFieldIdentifiers.req.equals(headers[i])) {\n        return new WARCRequestRecord(...this._unkown.values())\n      }\n\n      if (warcFieldIdentifiers.res.equals(headers[i])) {\n        return new WARCResponseRecord(...this._unkown.values())\n      }\n\n      if (warcFieldIdentifiers.info.equals(headers[i])) {\n        return new WARCInfoRecord(...this._unkown.values())\n      }\n\n      if (warcFieldIdentifiers.revisit.equals(headers[i])) {\n        return new WARCRevisitRecord(...this._unkown.values())\n      }\n\n      if (warcFieldIdentifiers.mdata.equals(headers[i])) {\n        return new WARCMetaDataRecord(...this._unkown.values())\n      }\n\n      if (warcFieldIdentifiers.resource.equals(headers[i])) {\n        return new WARCResourceRecord(...this._unkown.values())\n      }\n    }\n\n    // console.log('found nothing', this._unkown)\n    // ;[...this._unkown.values()].forEach(it => {\n    //   it.forEach(it2 => {\n    //     console.log(it2.toString())\n    //   })\n    //   console.log('--------------')\n    // })\n    return new WARCUnknownRecord(...this._unkown.values())\n  }\n\n  /**\n   * @desc Clears the builders internals. Do not call this functions unless parsing has completely finished\n   * this will completely remove all information pertaining to building of the current WARC Record.\n   * This method is intended to be used by the WARC parsers.\n   */\n  clear () {\n    if (this._info) {\n      this._info.clear()\n    }\n    if (this._mdata) {\n      this._mdata.clear()\n    }\n    if (this._req) {\n      this._req.clear()\n    }\n    if (this._res) {\n      this._res.clear()\n    }\n    if (this._rev) {\n      this._rev.clear()\n    }\n    if (this._resource) {\n      this._resource.clear()\n    }\n    if (this._unkown) {\n      this._unkown.clear()\n    }\n  }\n\n  /**\n   * @desc Adds the line to the correct WARC record section for warcinfo\n   * @param {number} ctrlfCount the current count of Control LineFeeds between WARC Record parts\n   * @param {Buffer} line the current line being parsed\n   * @private\n   */\n  _addInfoLine (ctrlfCount, line) {\n    if (ctrlfCount === 0) {\n      this._info.get('header').push(line)\n    } else if (ctrlfCount === 1) {\n      this._info.get('content').push(line)\n    }\n  }\n\n  /**\n   * @desc Adds the line to the correct WARC record section for metadata\n   * @param {number} ctrlfCount the current count of Control LineFeeds between WARC Record parts\n   * @param {Buffer} line the current line being parsed\n   * @private\n   */\n  _addMdataLine (ctrlfCount, line) {\n    if (ctrlfCount === 0) {\n      this._mdata.get('header').push(line)\n    } else if (ctrlfCount === 1) {\n      this._mdata.get('content').push(line)\n    }\n  }\n\n  /**\n   * @desc Adds the line to the correct WARC record section for request\n   * @param {number} ctrlfCount the current count of Control LineFeeds between WARC Record parts\n   * @param {Buffer} line the current line being parsed\n   * @private\n   */\n  _addReqLine (ctrlfCount, line) {\n    if (ctrlfCount === 0) {\n      this._req.get('header').push(line)\n    } else if (ctrlfCount === 1) {\n      this._req.get('http').push(line)\n    } else if (ctrlfCount === 2) {\n      this._req.get('post').push(line)\n    }\n  }\n\n  /**\n   * @desc Adds the line to the correct WARC record section for response\n   * @param {number} ctrlfCount the current count of Control LineFeeds between WARC Record parts\n   * @param {Buffer} line the current line being parsed\n   * @private\n   */\n  _addResLine (ctrlfCount, line) {\n    if (ctrlfCount === 0) {\n      this._res.get('header').push(line)\n    } else if (ctrlfCount === 1) {\n      this._res.get('http').push(line)\n    } else if (ctrlfCount === 2) {\n      this._res.get('body').push(line)\n    }\n  }\n\n  /**\n   * @desc Adds the line to the correct WARC record section for revisit\n   * @param {number} ctrlfCount the current count of Control LineFeeds between WARC Record parts\n   * @param {Buffer} line the current line being parsed\n   * @private\n   */\n  _addRevLine (ctrlfCount, line) {\n    if (ctrlfCount === 0) {\n      this._rev.get('header').push(line)\n    } else if (ctrlfCount === 1) {\n      this._rev.get('http').push(line)\n    }\n  }\n\n  /**\n   * @desc Adds the line to the correct section for an ``unknown`` record\n   * @param {number} ctrlfCount the current count of Control LineFeeds between WARC Record parts\n   * @param {Buffer} line the current line being parsed\n   * @private\n   */\n  _addUnkownLine (ctrlfCount, line) {\n    if (ctrlfCount === 0) {\n      this._unkown.get('header').push(line)\n    } else {\n      if (!this._unkown.has(ctrlfCount)) {\n        this._unkown.set(ctrlfCount, [])\n      }\n      this._unkown.get(ctrlfCount).push(line)\n    }\n  }\n\n  /**\n   * @desc Adds the line to the correct WARC record section for resource\n   * @param {number} ctrlfCount the current count of Control LineFeeds between WARC Record parts\n   * @param {Buffer} line the current line being parsed\n   * @private\n   */\n  _addResourceLine (ctrlfCount, line) {\n    if (ctrlfCount === 0) {\n      this._resource.get('header').push(line)\n    } else if (ctrlfCount === 1) {\n      this._resource.get('content').push(line)\n    }\n  }\n}\n\nmodule.exports = WARCRecorderBuilder\n",
    "static": true,
    "longname": "lib/warcRecordBuilder/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 146,
    "kind": "variable",
    "name": "builderKeyInfo",
    "memberof": "lib/warcRecordBuilder/index.js",
    "static": true,
    "longname": "lib/warcRecordBuilder/index.js~builderKeyInfo",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecordBuilder/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "variable",
    "name": "WARCInfoRecord",
    "memberof": "lib/warcRecordBuilder/index.js",
    "static": true,
    "longname": "lib/warcRecordBuilder/index.js~WARCInfoRecord",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecordBuilder/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "variable",
    "name": "warcFieldIdentifiers",
    "memberof": "lib/warcRecordBuilder/index.js",
    "static": true,
    "longname": "lib/warcRecordBuilder/index.js~warcFieldIdentifiers",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecordBuilder/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "class",
    "name": "WARCRecorderBuilder",
    "memberof": "lib/warcRecordBuilder/index.js",
    "static": true,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecordBuilder/index.js",
    "importStyle": null,
    "description": "Builds WARC Records by keeping track internally of the current WARC Record WARC-TYPE being parsed\nby a parser e.g. {@link WARCGzParser}",
    "lineNumber": 28,
    "interface": false
  },
  {
    "__docId__": 150,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#constructor",
    "access": null,
    "description": "Construct a new WARCRecorderBuilder",
    "lineNumber": 32,
    "params": []
  },
  {
    "__docId__": 151,
    "kind": "member",
    "name": "_info",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_info",
    "access": "private",
    "description": "",
    "lineNumber": 37,
    "type": {
      "nullable": true,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "_mdata",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_mdata",
    "access": "private",
    "description": "",
    "lineNumber": 43,
    "type": {
      "nullable": true,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "_req",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_req",
    "access": "private",
    "description": "",
    "lineNumber": 49,
    "type": {
      "nullable": true,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "_res",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_res",
    "access": "private",
    "description": "",
    "lineNumber": 55,
    "type": {
      "nullable": true,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "_rev",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_rev",
    "access": "private",
    "description": "",
    "lineNumber": 61,
    "type": {
      "nullable": true,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 156,
    "kind": "member",
    "name": "_resource",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_resource",
    "access": "private",
    "description": "",
    "lineNumber": 67,
    "type": {
      "nullable": true,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 157,
    "kind": "member",
    "name": "_unkown",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_unkown",
    "access": "private",
    "description": "",
    "lineNumber": 73,
    "type": {
      "nullable": true,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "determineWarcType",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#determineWarcType",
    "access": "public",
    "description": "determine the WARC-Type for the record",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the WARC-Type line"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "lastBegin",
        "description": "the WARC/1.0 line (WARC record begin)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Symbol"
      ],
      "spread": false,
      "description": "the record key that identifies the WARC-Type being parsed"
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "initInfo",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#initInfo",
    "access": null,
    "description": "Begin building WARC-TYPE: warcinfo",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "bgn",
        "description": "the WARC/1.0 line"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the WARC-TYPE line"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Symbol"
      ],
      "spread": false,
      "description": "the internal record key for the warcinfo record currently being built"
    }
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "_info",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_info",
    "access": null,
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "initMdata",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#initMdata",
    "access": null,
    "description": "Begin building WARC-TYPE: metadata",
    "lineNumber": 139,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "bgn",
        "description": "the WARC/1.0 line"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the WARC-TYPE line"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Symbol"
      ],
      "spread": false,
      "description": "the internal record key for the metadata record currently being built"
    }
  },
  {
    "__docId__": 162,
    "kind": "member",
    "name": "_mdata",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_mdata",
    "access": null,
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "initReq",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#initReq",
    "access": null,
    "description": "Begin building WARC-TYPE: request",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "bgn",
        "description": "the WARC/1.0 line"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the WARC-TYPE line"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Symbol"
      ],
      "spread": false,
      "description": "the internal record key for the request record currently being built"
    }
  },
  {
    "__docId__": 164,
    "kind": "member",
    "name": "_req",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_req",
    "access": null,
    "description": null,
    "lineNumber": 157,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "initRes",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#initRes",
    "access": null,
    "description": "Begin building WARC-TYPE: response",
    "lineNumber": 172,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "bgn",
        "description": "the WARC/1.0 line"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the WARC-TYPE line"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Symbol"
      ],
      "spread": false,
      "description": "the internal record key for the response record currently being built"
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "_res",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_res",
    "access": null,
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "initRevist",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#initRevist",
    "access": null,
    "description": "Begin building WARC-TYPE: revisit",
    "lineNumber": 189,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "bgn",
        "description": "the WARC/1.0 line"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the WARC-TYPE line"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Symbol"
      ],
      "spread": false,
      "description": "the internal record key for the revisit record currently being built"
    }
  },
  {
    "__docId__": 168,
    "kind": "member",
    "name": "_rev",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_rev",
    "access": null,
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "initUnknown",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#initUnknown",
    "access": null,
    "description": "Begin building WARC-TYPE: revisit",
    "lineNumber": 205,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "bgn",
        "description": "the WARC/1.0 line"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the WARC-TYPE line"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Symbol"
      ],
      "spread": false,
      "description": "the internal record key for the revisit record currently being built"
    }
  },
  {
    "__docId__": 170,
    "kind": "member",
    "name": "_unkown",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_unkown",
    "access": null,
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "initResource",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#initResource",
    "access": null,
    "description": "Begin building WARC-TYPE: resource",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "bgn",
        "description": "the WARC/1.0 line"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the WARC-TYPE line"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Symbol"
      ],
      "spread": false,
      "description": "the internal record key for the resource record currently being built"
    }
  },
  {
    "__docId__": 172,
    "kind": "member",
    "name": "_resource",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_resource",
    "access": null,
    "description": null,
    "lineNumber": 222,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "addLineTo",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#addLineTo",
    "access": null,
    "description": "Add the current line being parsed to a record currently being built",
    "lineNumber": 237,
    "params": [
      {
        "nullable": null,
        "types": [
          "Symbol"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the internal record key for the response record currently being built exposed by\n{@link initInfo}, {@link initMdata}, {@link initRes} and {@link initReq}"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlfCount",
        "description": "the current count of Control LineFeeds between WARC Record parts"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the current line being parsed"
      }
    ]
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "buildRecord",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#buildRecord",
    "access": null,
    "description": "Build the record currently being parsed",
    "lineNumber": 270,
    "params": [
      {
        "nullable": null,
        "types": [
          "Symbol"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "the internal record key for the response record currently being built exposed by\n{@link initInfo}, {@link initMdata}, {@link initRes} and {@link initReq}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WARCInfoRecord",
        "WARCMetaDataRecord",
        "WARCRequestRecord",
        "WARCResponseRecord",
        "WARCRevisitRecord",
        "WARCUnknownRecord"
      ],
      "spread": false,
      "description": "based off the ``key`` supplied to\nthis method"
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "_attemptCorrection",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_attemptCorrection",
    "access": null,
    "description": null,
    "lineNumber": 305,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "clear",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#clear",
    "access": null,
    "description": "Clears the builders internals. Do not call this functions unless parsing has completely finished\nthis will completely remove all information pertaining to building of the current WARC Record.\nThis method is intended to be used by the WARC parsers.",
    "lineNumber": 350,
    "params": []
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "_addInfoLine",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_addInfoLine",
    "access": "private",
    "description": "Adds the line to the correct WARC record section for warcinfo",
    "lineNumber": 380,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlfCount",
        "description": "the current count of Control LineFeeds between WARC Record parts"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the current line being parsed"
      }
    ]
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "_addMdataLine",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_addMdataLine",
    "access": "private",
    "description": "Adds the line to the correct WARC record section for metadata",
    "lineNumber": 394,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlfCount",
        "description": "the current count of Control LineFeeds between WARC Record parts"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the current line being parsed"
      }
    ]
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "_addReqLine",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_addReqLine",
    "access": "private",
    "description": "Adds the line to the correct WARC record section for request",
    "lineNumber": 408,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlfCount",
        "description": "the current count of Control LineFeeds between WARC Record parts"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the current line being parsed"
      }
    ]
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "_addResLine",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_addResLine",
    "access": "private",
    "description": "Adds the line to the correct WARC record section for response",
    "lineNumber": 424,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlfCount",
        "description": "the current count of Control LineFeeds between WARC Record parts"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the current line being parsed"
      }
    ]
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "_addRevLine",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_addRevLine",
    "access": "private",
    "description": "Adds the line to the correct WARC record section for revisit",
    "lineNumber": 440,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlfCount",
        "description": "the current count of Control LineFeeds between WARC Record parts"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the current line being parsed"
      }
    ]
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "_addUnkownLine",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_addUnkownLine",
    "access": "private",
    "description": "Adds the line to the correct section for an ``unknown`` record",
    "lineNumber": 454,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlfCount",
        "description": "the current count of Control LineFeeds between WARC Record parts"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the current line being parsed"
      }
    ]
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "_addResourceLine",
    "memberof": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecordBuilder/index.js~WARCRecorderBuilder#_addResourceLine",
    "access": "private",
    "description": "Adds the line to the correct WARC record section for resource",
    "lineNumber": 471,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlfCount",
        "description": "the current count of Control LineFeeds between WARC Record parts"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "the current line being parsed"
      }
    ]
  },
  {
    "__docId__": 184,
    "kind": "file",
    "name": "lib/warcRecords/index.js",
    "content": "/** @ignore */\nconst {parseWarcInfoMetaDataContent, parseWarcRecordHeader, headerRe} = require('./warcContentParsers')\n\n/**\n * @desc WARC-TYPE: warcinfo\n */\nclass WARCInfoRecord {\n  /**\n   * @desc Create a new WARCInfoRecord\n   * @param {Buffer[]} headerBuffers the warc header fields\n   * @param {Buffer[]} contentBuffers the warc records contents\n   */\n  constructor (headerBuffers, contentBuffers) {\n    /**\n     * @type {Object}\n     */\n    this.warcHeader = parseWarcRecordHeader(headerBuffers)\n\n    /**\n     * @type {Object}\n     */\n    this.content = parseWarcInfoMetaDataContent(contentBuffers)\n\n    /**\n     * @type {string}\n     */\n    this.type = 'warcinfo'\n  }\n\n  /**\n   * @return {string} WARC-TYPE\n   */\n  get warcType () {\n    return this.warcHeader['WARC-Type']\n  }\n\n  /**\n   * @return {string} WARC-Filename\n   */\n  get warcFilename () {\n    return this.warcHeader['WARC-Filename']\n  }\n\n  /**\n   * @return {string} WARC-Record-ID\n   */\n  get recordId () {\n    return this.warcHeader['WARC-Record-ID']\n  }\n\n  /**\n   * @return {string} WARC-HEADER:Content-Type\n   */\n  get warcContentType () {\n    return this.warcHeader['Content-Type']\n  }\n\n  /**\n   * @return {number} WARC-HEADER:Content-Length\n   */\n  get warcContentLength () {\n    return this.warcHeader['Content-Length']\n  }\n}\n\n/**\n * @desc WARC-TYPE: metadata\n */\nclass WARCMetaDataRecord {\n  /**\n   * @desc Create a new WARCMetaDataRecord\n   * @param {Buffer[]} headerBuffers the warc header fields\n   * @param {Buffer[]} contentBuffers the warc records contents\n   */\n  constructor (headerBuffers, contentBuffers) {\n    /**\n     * @type {Object}\n     */\n    this.warcHeader = parseWarcRecordHeader(headerBuffers)\n\n    /**\n     * @type {Object}\n     */\n    this.content = parseWarcInfoMetaDataContent(contentBuffers)\n\n    /**\n     * @type {string}\n     */\n    this.type = 'metadata'\n  }\n\n  /**\n   * @return {string} WARC-TYPE\n   */\n  get warcType () {\n    return this.warcHeader['WARC-Type']\n  }\n\n  /**\n   * @return {string} WARC-Record-ID\n   */\n  get recordId () {\n    return this.warcHeader['WARC-Record-ID']\n  }\n\n  /**\n   * @return {string} WARC-Concurrent-To\n   */\n  get concurrentTo () {\n    return this.warcHeader['WARC-Concurrent-To']\n  }\n\n  /**\n   * @return {string} WARC-HEADER:Content-Type\n   */\n  get warcContentType () {\n    return this.warcHeader['Content-Type']\n  }\n\n  /**\n   * @return {number} WARC-HEADER:Content-Length\n   */\n  get warcContentLength () {\n    return this.warcHeader['Content-Length']\n  }\n}\n\n/**\n * @desc WARC-TYPE: request\n */\nclass WARCRequestRecord {\n  /**\n   * @desc Create a new WARCRequestRecord\n   * @param {Buffer[]} headerBuffers\n   * @param {Buffer[]} httpBuffers\n   * @param {Buffer[]} postBuffers\n   */\n  constructor (headerBuffers, httpBuffers, postBuffers) {\n    /**\n     * @type {string}\n     */\n    this.type = 'request'\n\n    /**\n     * @type {?string}\n     */\n    this.method = null\n\n    /**\n     * @type {?string}\n     */\n    this.requestLine = null\n\n    /**\n     * @type {?string}\n     */\n    this.httpVersion = null\n\n    /**\n     * @type {Object}\n     */\n    this.warcHeader = parseWarcRecordHeader(headerBuffers)\n\n    /**\n     * @type {Object}\n     */\n    this.httpHeaders = this._parseHttpHeaders(httpBuffers)\n\n    if (this.method && this.method.toLowerCase() === 'post') {\n      /**\n       * @desc The post data of the request. This property is only on a {@link WARCRequestRecord} if it corresponds to\n       * a post request\n       * @type {Buffer}\n       */\n      this.postBuffer = Buffer.concat(postBuffers)\n    }\n  }\n\n  /**\n   * @desc Parses the request HTTP headers\n   * @param {Buffer[]} bufs the request HTTP headers\n   * @return {Object}\n   * @private\n   */\n  _parseHttpHeaders (bufs) {\n    if (bufs.length === 0) {\n      return {}\n    }\n    let content = {}\n    let len = bufs.length\n    let i = 1\n    let line\n    let match\n    // console.log(bufs[0].toString('utf8').trim())\n    this.requestLine = bufs[0].toString('utf8').trim()\n    // disabling eslint to account for ES6 array destructuring\n    let [meth, path, httpV] = this.requestLine.split(' ') // eslint-disable-line\n    this.method = meth\n    this.httpVersion = httpV\n    let lastMatch\n    for (; i < len; ++i) {\n      line = bufs[i].toString('utf8').trim()\n      match = headerRe.exec(line)\n      if (match) {\n        let [_, m1, m2] = match // eslint-disable-line\n        content[m1] = m2\n        lastMatch = m1\n      } else {\n        // because really long set cookie and friends\n        if (lastMatch) {\n          content[lastMatch] += line\n        } else {\n          console.log('boooo WarcRequestRecord._parseHeaders', line)\n        }\n      }\n    }\n    return content\n  }\n\n  /**\n   * @return {string} WARC-Record-ID\n   */\n  get recordId () {\n    return this.warcHeader['WARC-Record-ID']\n  }\n\n  /**\n   * @return {string} WARC-Target-URI\n   */\n  get targetURI () {\n    return this.warcHeader['WARC-Target-URI']\n  }\n\n  /**\n   * @return {string} WARC-HEADER:Content-Type\n   */\n  get warcContentType () {\n    return this.warcHeader['Content-Type']\n  }\n\n  /**\n   * @return {number} WARC-HEADER:Content-Length\n   */\n  get warcContentLength () {\n    return this.warcHeader['Content-Length']\n  }\n}\n\n/**\n * @desc WARC-TYPE: response\n */\nclass WARCResponseRecord {\n  /**\n   * @desc Create a new WARCResponseRecord\n   * @param {Buffer[]} headerBuffers\n   * @param {Buffer[]} httpBuffers\n   * @param {Buffer[]} bodyBuffers\n   */\n  constructor (headerBuffers, httpBuffers, bodyBuffers) {\n    /**\n     * @type {?number}\n     */\n    this.statusCode = null\n\n    /**\n     * @type {?string}\n     */\n    this.statusReason = null\n\n    /**\n     * @type {?string}\n     */\n    this.statusLine = null\n\n    /**\n     * @type {?string}\n     */\n    this.httpVersion = null\n\n    /**\n     * @type {Object}\n     */\n    this.warcHeader = parseWarcRecordHeader(headerBuffers)\n\n    if (this.warcContentType === 'text/dns') {\n      /**\n       * @type {Object}\n       */\n      this.httpHeaders = {}\n\n      /**\n       * @type {?Buffer|?string[]}\n       */\n      this.bodyBuffer = httpBuffers.map(it => it.toString())\n    } else {\n      /**\n       * @type {Object}\n       */\n      this.httpHeaders = this._parseHttpHeaders(httpBuffers)\n\n      /**\n       * @type {?Buffer|?string[]}\n       */\n      this.bodyBuffer = Buffer.concat(bodyBuffers || [])\n    }\n\n    /**\n     * @type {string}\n     */\n    this.type = 'response'\n  }\n\n  /**\n   * @desc Parses the response HTTP headers\n   * @param {Buffer[]} bufs the response HTTP headers\n   * @return {Object}\n   * @private\n   */\n  _parseHttpHeaders (bufs) {\n    if (bufs.length === 0) {\n      return {}\n    }\n    let content = {}\n    let len = bufs.length\n    let i = 1\n    let line\n    let match\n    this.statusLine = bufs[0].toString('utf8').trim()\n    let [httpV, statusCode, statusReason] = this.statusLine.split(' ')\n    this.statusCode = parseInt(statusCode)\n    this.statusReason = statusReason\n    this.httpVersion = httpV\n    let lastMatch\n    for (; i < len; ++i) {\n      line = bufs[i].toString('utf8').trim()\n      match = headerRe.exec(line)\n      if (match) {\n        // disabling eslint to account for ES6 array destructuring\n        let [_, m1, m2] = match // eslint-disable-line\n        if (m1.toLowerCase() === 'content-length') {\n          content[m1] = parseInt(m2)\n        } else {\n          content[m1] = m2\n        }\n        lastMatch = m1\n      } else {\n        // because really long set cookie and friends\n        if (lastMatch) {\n          content[lastMatch] += line\n        } else {\n          console.log('boooo WarcResponseRecord._parseHeaders', this.warcContentType, line)\n        }\n      }\n    }\n    return content\n  }\n\n  /**\n   * @return {string} WARC-Record-ID\n   */\n  get recordId () {\n    return this.warcHeader['WARC-Record-ID']\n  }\n\n  /**\n   * @return {string} WARC-Target-URI\n   */\n  get targetURI () {\n    return this.warcHeader['WARC-Target-URI']\n  }\n\n  /**\n   * @return {string} WARC-HEADER:Content-Type\n   */\n  get warcContentType () {\n    return this.warcHeader['Content-Type']\n  }\n\n  /**\n   * @return {number} WARC-HEADER:Content-Length\n   */\n  get warcContentLength () {\n    return this.warcHeader['Content-Length']\n  }\n}\n\n/**\n * @desc WARC-TYPE: revisit\n */\nclass WARCRevisitRecord {\n  /**\n   * @desc Create a new WARCResponseRecord\n   * @param {Buffer[]} headerBuffers\n   * @param {Buffer[]} httpBuffers\n   */\n  constructor (headerBuffers, httpBuffers) {\n    /**\n     * @type {string}\n     */\n    this.type = 'revisit'\n\n    /**\n     * @type {?number}\n     */\n    this.statusCode = null\n\n    /**\n     * @type {?string}\n     */\n    this.statusReason = null\n\n    /**\n     * @type {?string}\n     */\n    this.statusLine = null\n\n    /**\n     * @type {?string}\n     */\n    this.httpVersion = null\n\n    /**\n     * @type {Object}\n     */\n    this.warcHeader = parseWarcRecordHeader(headerBuffers)\n\n    /**\n     * @type {Object}\n     */\n    this.httpHeaders = this._parseHttpHeaders(httpBuffers)\n  }\n\n  /**\n   * @desc Parses the response HTTP headers\n   * @param {Buffer[]} bufs the response HTTP headers\n   * @return {Object}\n   * @private\n   */\n  _parseHttpHeaders (bufs) {\n    if (bufs.length === 0) {\n      return {}\n    }\n    let content = {}\n    let len = bufs.length\n    let i = 1\n    let line\n    let match\n    // console.log(fl)\n    this.statusLine = bufs[0].toString('utf8').trim()\n    let [httpV, statusCode, statusReason] = this.statusLine.split(' ')\n    this.statusCode = parseInt(statusCode)\n    this.statusReason = statusReason\n    this.httpVersion = httpV\n    let lastMatch\n    for (; i < len; ++i) {\n      line = bufs[i].toString('utf8').trim()\n      match = headerRe.exec(line)\n      if (match) {\n        // disabling eslint to account for ES6 array destructuring\n        let [_, m1, m2] = match // eslint-disable-line\n        if (m1.toLowerCase() === 'content-length') {\n          content[m1] = parseInt(m2)\n        } else {\n          content[m1] = m2\n        }\n        lastMatch = m1\n      } else {\n        // because really long set cookie and friends\n        if (lastMatch) {\n          content[lastMatch] += line\n        } else {\n          console.log('boooo WARCRevisitRecord._parseHeaders', this.warcContentType, line)\n        }\n      }\n    }\n    return content\n  }\n\n  /**\n   * @return {string} WARC-Record-ID\n   */\n  get recordId () {\n    return this.warcHeader['WARC-Record-ID']\n  }\n\n  /**\n   * @return {string} WARC-Target-URI\n   */\n  get targetURI () {\n    return this.warcHeader['WARC-Target-URI']\n  }\n\n  /**\n   * @return {string} WARC-HEADER:Content-Type\n   */\n  get warcContentType () {\n    return this.warcHeader['Content-Type']\n  }\n\n  /**\n   * @return {number} WARC-HEADER:Content-Length\n   */\n  get warcContentLength () {\n    return this.warcHeader['Content-Length']\n  }\n}\n\n/**\n * @desc This class is this libraries attempt at being lenient about parsing.\n */\nclass WARCResourceRecord {\n  /**\n   * @desc Create a new WARCResponseRecord\n   * @param {Buffer[]} headerBuffers\n   * @param {Buffer[]} contentBuffers\n   */\n  constructor (headerBuffers, contentBuffers) {\n    /**\n     * @type {Object}\n     */\n    this.warcHeader = parseWarcRecordHeader(headerBuffers)\n\n    /**\n     * @type {Buffer}\n     */\n    this.contentBuffers = Buffer.concat(contentBuffers)\n\n    /**\n     * @type {string}\n     */\n    this.type = 'resource'\n  }\n}\n\n/**\n * @desc This class is this libraries attempt at being lenient about parsing.\n * This class is only used if this library cannot automatically correct the common ``off by one`` error\n * other WARC parsing libraries stop immediately at when encountered (especially during indexing).\n *\n * This library knows does not think missing a single ``CTRL-LF`` should stop you from reading a WARC\n *\n * Now if something went terribly wrong during WARC creation that's on you but we still think you should know about it by having\n * as much of that messed up data as we can parse before moving on to the next record.\n */\nclass WARCUnknownRecord {\n  /**\n   * @desc Create a new WARCResponseRecord\n   * @param {Buffer[]} headerBuffers\n   * @param {Buffer[]} otherBuffers\n   */\n  constructor (headerBuffers, ...otherBuffers) {\n    /**\n     * @type {Object}\n     */\n    this.warcHeader = parseWarcRecordHeader(headerBuffers)\n\n    /**\n     * @type {Buffer[][]}\n     */\n    this.otherBuffers = otherBuffers\n\n    /**\n     * @type {string}\n     */\n    this.type = 'unknown'\n  }\n}\n\nmodule.exports = {\n  WARCInfoRecord,\n  WARCMetaDataRecord,\n  WARCRequestRecord,\n  WARCResponseRecord,\n  WARCRevisitRecord,\n  WARCUnknownRecord,\n  WARCResourceRecord\n}\n",
    "static": true,
    "longname": "lib/warcRecords/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 185,
    "kind": "variable",
    "name": "parseWarcInfoMetaDataContent",
    "memberof": "lib/warcRecords/index.js",
    "static": true,
    "longname": "lib/warcRecords/index.js~parseWarcInfoMetaDataContent",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "class",
    "name": "WARCInfoRecord",
    "memberof": "lib/warcRecords/index.js",
    "static": true,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/index.js",
    "importStyle": null,
    "description": "WARC-TYPE: warcinfo",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 187,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecords/index.js~WARCInfoRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord#constructor",
    "access": null,
    "description": "Create a new WARCInfoRecord",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffers",
        "description": "the warc header fields"
      },
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "contentBuffers",
        "description": "the warc records contents"
      }
    ]
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "warcHeader",
    "memberof": "lib/warcRecords/index.js~WARCInfoRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord#warcHeader",
    "access": null,
    "description": "",
    "lineNumber": 17,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "content",
    "memberof": "lib/warcRecords/index.js~WARCInfoRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord#content",
    "access": null,
    "description": "",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 190,
    "kind": "member",
    "name": "type",
    "memberof": "lib/warcRecords/index.js~WARCInfoRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord#type",
    "access": null,
    "description": "",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 191,
    "kind": "get",
    "name": "warcType",
    "memberof": "lib/warcRecords/index.js~WARCInfoRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord#warcType",
    "access": null,
    "description": "",
    "lineNumber": 33,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-TYPE"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "get",
    "name": "warcFilename",
    "memberof": "lib/warcRecords/index.js~WARCInfoRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord#warcFilename",
    "access": null,
    "description": "",
    "lineNumber": 40,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Filename"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "get",
    "name": "recordId",
    "memberof": "lib/warcRecords/index.js~WARCInfoRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord#recordId",
    "access": null,
    "description": "",
    "lineNumber": 47,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Record-ID"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "get",
    "name": "warcContentType",
    "memberof": "lib/warcRecords/index.js~WARCInfoRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord#warcContentType",
    "access": null,
    "description": "",
    "lineNumber": 54,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Type"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "get",
    "name": "warcContentLength",
    "memberof": "lib/warcRecords/index.js~WARCInfoRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCInfoRecord#warcContentLength",
    "access": null,
    "description": "",
    "lineNumber": 61,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Length"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "class",
    "name": "WARCMetaDataRecord",
    "memberof": "lib/warcRecords/index.js",
    "static": true,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/index.js",
    "importStyle": null,
    "description": "WARC-TYPE: metadata",
    "lineNumber": 69,
    "interface": false
  },
  {
    "__docId__": 197,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord#constructor",
    "access": null,
    "description": "Create a new WARCMetaDataRecord",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffers",
        "description": "the warc header fields"
      },
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "contentBuffers",
        "description": "the warc records contents"
      }
    ]
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "warcHeader",
    "memberof": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord#warcHeader",
    "access": null,
    "description": "",
    "lineNumber": 79,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 199,
    "kind": "member",
    "name": "content",
    "memberof": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord#content",
    "access": null,
    "description": "",
    "lineNumber": 84,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "type",
    "memberof": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord#type",
    "access": null,
    "description": "",
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 201,
    "kind": "get",
    "name": "warcType",
    "memberof": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord#warcType",
    "access": null,
    "description": "",
    "lineNumber": 95,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-TYPE"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "get",
    "name": "recordId",
    "memberof": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord#recordId",
    "access": null,
    "description": "",
    "lineNumber": 102,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Record-ID"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "get",
    "name": "concurrentTo",
    "memberof": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord#concurrentTo",
    "access": null,
    "description": "",
    "lineNumber": 109,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Concurrent-To"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "get",
    "name": "warcContentType",
    "memberof": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord#warcContentType",
    "access": null,
    "description": "",
    "lineNumber": 116,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Type"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 205,
    "kind": "get",
    "name": "warcContentLength",
    "memberof": "lib/warcRecords/index.js~WARCMetaDataRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCMetaDataRecord#warcContentLength",
    "access": null,
    "description": "",
    "lineNumber": 123,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Length"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "class",
    "name": "WARCRequestRecord",
    "memberof": "lib/warcRecords/index.js",
    "static": true,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/index.js",
    "importStyle": null,
    "description": "WARC-TYPE: request",
    "lineNumber": 131,
    "interface": false
  },
  {
    "__docId__": 207,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#constructor",
    "access": null,
    "description": "Create a new WARCRequestRecord",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffers",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "httpBuffers",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "postBuffers",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 208,
    "kind": "member",
    "name": "type",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#type",
    "access": null,
    "description": "",
    "lineNumber": 142,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 209,
    "kind": "member",
    "name": "method",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#method",
    "access": null,
    "description": "",
    "lineNumber": 147,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 210,
    "kind": "member",
    "name": "requestLine",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#requestLine",
    "access": null,
    "description": "",
    "lineNumber": 152,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 211,
    "kind": "member",
    "name": "httpVersion",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#httpVersion",
    "access": null,
    "description": "",
    "lineNumber": 157,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 212,
    "kind": "member",
    "name": "warcHeader",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#warcHeader",
    "access": null,
    "description": "",
    "lineNumber": 162,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 213,
    "kind": "member",
    "name": "httpHeaders",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#httpHeaders",
    "access": null,
    "description": "",
    "lineNumber": 167,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "postBuffer",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#postBuffer",
    "access": null,
    "description": "The post data of the request. This property is only on a {@link WARCRequestRecord} if it corresponds to\na post request",
    "lineNumber": 175,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "_parseHttpHeaders",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#_parseHttpHeaders",
    "access": "private",
    "description": "Parses the request HTTP headers",
    "lineNumber": 185,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bufs",
        "description": "the request HTTP headers"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "requestLine",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#requestLine",
    "access": null,
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "method",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#method",
    "access": null,
    "description": null,
    "lineNumber": 198,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "member",
    "name": "httpVersion",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#httpVersion",
    "access": null,
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "get",
    "name": "recordId",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#recordId",
    "access": null,
    "description": "",
    "lineNumber": 223,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Record-ID"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "get",
    "name": "targetURI",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#targetURI",
    "access": null,
    "description": "",
    "lineNumber": 230,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Target-URI"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "get",
    "name": "warcContentType",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#warcContentType",
    "access": null,
    "description": "",
    "lineNumber": 237,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Type"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 222,
    "kind": "get",
    "name": "warcContentLength",
    "memberof": "lib/warcRecords/index.js~WARCRequestRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRequestRecord#warcContentLength",
    "access": null,
    "description": "",
    "lineNumber": 244,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Length"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 223,
    "kind": "class",
    "name": "WARCResponseRecord",
    "memberof": "lib/warcRecords/index.js",
    "static": true,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/index.js",
    "importStyle": null,
    "description": "WARC-TYPE: response",
    "lineNumber": 252,
    "interface": false
  },
  {
    "__docId__": 224,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#constructor",
    "access": null,
    "description": "Create a new WARCResponseRecord",
    "lineNumber": 259,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffers",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "httpBuffers",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bodyBuffers",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 225,
    "kind": "member",
    "name": "statusCode",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#statusCode",
    "access": null,
    "description": "",
    "lineNumber": 263,
    "type": {
      "nullable": true,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 226,
    "kind": "member",
    "name": "statusReason",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#statusReason",
    "access": null,
    "description": "",
    "lineNumber": 268,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 227,
    "kind": "member",
    "name": "statusLine",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#statusLine",
    "access": null,
    "description": "",
    "lineNumber": 273,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 228,
    "kind": "member",
    "name": "httpVersion",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#httpVersion",
    "access": null,
    "description": "",
    "lineNumber": 278,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 229,
    "kind": "member",
    "name": "warcHeader",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#warcHeader",
    "access": null,
    "description": "",
    "lineNumber": 283,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 230,
    "kind": "member",
    "name": "httpHeaders",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#httpHeaders",
    "access": null,
    "description": "",
    "lineNumber": 289,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 231,
    "kind": "member",
    "name": "bodyBuffer",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#bodyBuffer",
    "access": null,
    "description": "",
    "lineNumber": 294,
    "type": {
      "nullable": true,
      "types": [
        "Buffer",
        "?string[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 232,
    "kind": "member",
    "name": "httpHeaders",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#httpHeaders",
    "access": null,
    "description": "",
    "lineNumber": 299,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 233,
    "kind": "member",
    "name": "bodyBuffer",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#bodyBuffer",
    "access": null,
    "description": "",
    "lineNumber": 304,
    "type": {
      "nullable": true,
      "types": [
        "Buffer",
        "?string[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 234,
    "kind": "member",
    "name": "type",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#type",
    "access": null,
    "description": "",
    "lineNumber": 310,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "_parseHttpHeaders",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#_parseHttpHeaders",
    "access": "private",
    "description": "Parses the response HTTP headers",
    "lineNumber": 319,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bufs",
        "description": "the response HTTP headers"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 236,
    "kind": "member",
    "name": "statusLine",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#statusLine",
    "access": null,
    "description": null,
    "lineNumber": 328,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "member",
    "name": "statusCode",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#statusCode",
    "access": null,
    "description": null,
    "lineNumber": 330,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "member",
    "name": "statusReason",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#statusReason",
    "access": null,
    "description": null,
    "lineNumber": 331,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "member",
    "name": "httpVersion",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#httpVersion",
    "access": null,
    "description": null,
    "lineNumber": 332,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "get",
    "name": "recordId",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#recordId",
    "access": null,
    "description": "",
    "lineNumber": 361,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Record-ID"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 241,
    "kind": "get",
    "name": "targetURI",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#targetURI",
    "access": null,
    "description": "",
    "lineNumber": 368,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Target-URI"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "get",
    "name": "warcContentType",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#warcContentType",
    "access": null,
    "description": "",
    "lineNumber": 375,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Type"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 243,
    "kind": "get",
    "name": "warcContentLength",
    "memberof": "lib/warcRecords/index.js~WARCResponseRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResponseRecord#warcContentLength",
    "access": null,
    "description": "",
    "lineNumber": 382,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Length"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "class",
    "name": "WARCRevisitRecord",
    "memberof": "lib/warcRecords/index.js",
    "static": true,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/index.js",
    "importStyle": null,
    "description": "WARC-TYPE: revisit",
    "lineNumber": 390,
    "interface": false
  },
  {
    "__docId__": 245,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#constructor",
    "access": null,
    "description": "Create a new WARCResponseRecord",
    "lineNumber": 396,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffers",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "httpBuffers",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 246,
    "kind": "member",
    "name": "type",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#type",
    "access": null,
    "description": "",
    "lineNumber": 400,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 247,
    "kind": "member",
    "name": "statusCode",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#statusCode",
    "access": null,
    "description": "",
    "lineNumber": 405,
    "type": {
      "nullable": true,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 248,
    "kind": "member",
    "name": "statusReason",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#statusReason",
    "access": null,
    "description": "",
    "lineNumber": 410,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 249,
    "kind": "member",
    "name": "statusLine",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#statusLine",
    "access": null,
    "description": "",
    "lineNumber": 415,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 250,
    "kind": "member",
    "name": "httpVersion",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#httpVersion",
    "access": null,
    "description": "",
    "lineNumber": 420,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 251,
    "kind": "member",
    "name": "warcHeader",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#warcHeader",
    "access": null,
    "description": "",
    "lineNumber": 425,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 252,
    "kind": "member",
    "name": "httpHeaders",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#httpHeaders",
    "access": null,
    "description": "",
    "lineNumber": 430,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "_parseHttpHeaders",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#_parseHttpHeaders",
    "access": "private",
    "description": "Parses the response HTTP headers",
    "lineNumber": 439,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bufs",
        "description": "the response HTTP headers"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 254,
    "kind": "member",
    "name": "statusLine",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#statusLine",
    "access": null,
    "description": null,
    "lineNumber": 449,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "statusCode",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#statusCode",
    "access": null,
    "description": null,
    "lineNumber": 451,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "member",
    "name": "statusReason",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#statusReason",
    "access": null,
    "description": null,
    "lineNumber": 452,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "member",
    "name": "httpVersion",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#httpVersion",
    "access": null,
    "description": null,
    "lineNumber": 453,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "get",
    "name": "recordId",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#recordId",
    "access": null,
    "description": "",
    "lineNumber": 482,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Record-ID"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "get",
    "name": "targetURI",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#targetURI",
    "access": null,
    "description": "",
    "lineNumber": 489,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-Target-URI"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "get",
    "name": "warcContentType",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#warcContentType",
    "access": null,
    "description": "",
    "lineNumber": 496,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Type"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 261,
    "kind": "get",
    "name": "warcContentLength",
    "memberof": "lib/warcRecords/index.js~WARCRevisitRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCRevisitRecord#warcContentLength",
    "access": null,
    "description": "",
    "lineNumber": 503,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "WARC-HEADER:Content-Length"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "class",
    "name": "WARCResourceRecord",
    "memberof": "lib/warcRecords/index.js",
    "static": true,
    "longname": "lib/warcRecords/index.js~WARCResourceRecord",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/index.js",
    "importStyle": null,
    "description": "This class is this libraries attempt at being lenient about parsing.",
    "lineNumber": 511,
    "interface": false
  },
  {
    "__docId__": 263,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecords/index.js~WARCResourceRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResourceRecord#constructor",
    "access": null,
    "description": "Create a new WARCResponseRecord",
    "lineNumber": 517,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffers",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "contentBuffers",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 264,
    "kind": "member",
    "name": "warcHeader",
    "memberof": "lib/warcRecords/index.js~WARCResourceRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResourceRecord#warcHeader",
    "access": null,
    "description": "",
    "lineNumber": 521,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 265,
    "kind": "member",
    "name": "contentBuffers",
    "memberof": "lib/warcRecords/index.js~WARCResourceRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResourceRecord#contentBuffers",
    "access": null,
    "description": "",
    "lineNumber": 526,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 266,
    "kind": "member",
    "name": "type",
    "memberof": "lib/warcRecords/index.js~WARCResourceRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCResourceRecord#type",
    "access": null,
    "description": "",
    "lineNumber": 531,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 267,
    "kind": "class",
    "name": "WARCUnknownRecord",
    "memberof": "lib/warcRecords/index.js",
    "static": true,
    "longname": "lib/warcRecords/index.js~WARCUnknownRecord",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/index.js",
    "importStyle": null,
    "description": "This class is this libraries attempt at being lenient about parsing.\nThis class is only used if this library cannot automatically correct the common ``off by one`` error\nother WARC parsing libraries stop immediately at when encountered (especially during indexing).\n\nThis library knows does not think missing a single ``CTRL-LF`` should stop you from reading a WARC\n\nNow if something went terribly wrong during WARC creation that's on you but we still think you should know about it by having\nas much of that messed up data as we can parse before moving on to the next record.",
    "lineNumber": 545,
    "interface": false
  },
  {
    "__docId__": 268,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecords/index.js~WARCUnknownRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCUnknownRecord#constructor",
    "access": null,
    "description": "Create a new WARCResponseRecord",
    "lineNumber": 551,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffers",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "otherBuffers",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 269,
    "kind": "member",
    "name": "warcHeader",
    "memberof": "lib/warcRecords/index.js~WARCUnknownRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCUnknownRecord#warcHeader",
    "access": null,
    "description": "",
    "lineNumber": 555,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 270,
    "kind": "member",
    "name": "otherBuffers",
    "memberof": "lib/warcRecords/index.js~WARCUnknownRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCUnknownRecord#otherBuffers",
    "access": null,
    "description": "",
    "lineNumber": 560,
    "type": {
      "nullable": null,
      "types": [
        "Buffer[][]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 271,
    "kind": "member",
    "name": "type",
    "memberof": "lib/warcRecords/index.js~WARCUnknownRecord",
    "static": false,
    "longname": "lib/warcRecords/index.js~WARCUnknownRecord#type",
    "access": null,
    "description": "",
    "lineNumber": 565,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 272,
    "kind": "file",
    "name": "lib/warcRecords/warcContentParsers.js",
    "content": "/**\n * @desc Capture ``(key):\\s(value)`` separated pairs\n * @type {RegExp}\n */\nconst headerRe = /([^:]+):\\s(.+)/\n\n/**\n * @desc Capture the WARC Record Id or WARC Concurrent To Id\n * @type {RegExp}\n */\nconst recIdRE = /<[a-z]+:[a-z]+:([^>]+)>/\n\n/**\n * @desc Parse a WARC Records headers not HTTP Header parser\n * @param {Buffer[]} bufs the WARC Records header lines\n * @return {Object}\n */\nfunction parseWarcRecordHeader (bufs) {\n  let rheader = {}\n  let len = bufs.length\n  let i = 1\n  let line\n  let match\n  line = bufs[0].toString('utf8').trim()\n  rheader['WARC'] = line.slice(line.indexOf('/') + 1)\n  for (; i < len; ++i) {\n    line = bufs[i].toString('utf8').trim()\n    match = headerRe.exec(line)\n    if (match) {\n      // disabling eslint to account for ES6 array destructuring\n      let [str, m1, m2] = match // eslint-disable-line\n      if (m1 === 'WARC-Record-ID' || m1 === 'WARC-Concurrent-To') {\n        let [_, id] = recIdRE.exec(m2) // eslint-disable-line\n        rheader[m1] = id\n      } else if (m1 === 'Content-Length') {\n        rheader[m1] = parseInt(m2)\n      } else {\n        rheader[m1] = m2\n      }\n    } else {\n      console.log('boooo parseWarcRecordHeader', line)\n    }\n  }\n  return rheader\n}\n\n/**\n * @desc Parse a WARC Metadata records metadata content\n * @param {Buffer[]} bufs the WARC Metadata records content lines\n * @return {Object}\n */\nfunction parseWarcInfoMetaDataContent (bufs) {\n  let content = {}\n  let len = bufs.length\n  let i = 0\n  let line\n  let match\n  for (; i < len; ++i) {\n    line = bufs[i].toString('utf8').trim()\n    match = headerRe.exec(line)\n    if (match) {\n      // disabling eslint to account for ES6 array destructuring\n      let [str, m1, m2] = match // eslint-disable-line\n      if (m1 === 'outlink') {\n        if (!content[m1]) {\n          content[m1] = []\n        }\n        content[m1].push(m2)\n      } else {\n        content[m1] = m2\n      }\n    } else {\n      content[line] = ''\n    }\n  }\n  return content\n}\n\nmodule.exports = {\n  headerRe,\n  recIdRE,\n  parseWarcInfoMetaDataContent,\n  parseWarcRecordHeader\n}\n",
    "static": true,
    "longname": "lib/warcRecords/warcContentParsers.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 273,
    "kind": "variable",
    "name": "headerRe",
    "memberof": "lib/warcRecords/warcContentParsers.js",
    "static": true,
    "longname": "lib/warcRecords/warcContentParsers.js~headerRe",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/warcContentParsers.js",
    "importStyle": null,
    "description": "Capture ``(key):\\s(value)`` separated pairs",
    "lineNumber": 5,
    "type": {
      "nullable": null,
      "types": [
        "RegExp"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 274,
    "kind": "variable",
    "name": "recIdRE",
    "memberof": "lib/warcRecords/warcContentParsers.js",
    "static": true,
    "longname": "lib/warcRecords/warcContentParsers.js~recIdRE",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/warcContentParsers.js",
    "importStyle": null,
    "description": "Capture the WARC Record Id or WARC Concurrent To Id",
    "lineNumber": 11,
    "type": {
      "nullable": null,
      "types": [
        "RegExp"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 275,
    "kind": "function",
    "name": "parseWarcRecordHeader",
    "memberof": "lib/warcRecords/warcContentParsers.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecords/warcContentParsers.js~parseWarcRecordHeader",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/warcContentParsers.js",
    "importStyle": null,
    "description": "Parse a WARC Records headers not HTTP Header parser",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bufs",
        "description": "the WARC Records header lines"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 276,
    "kind": "function",
    "name": "parseWarcInfoMetaDataContent",
    "memberof": "lib/warcRecords/warcContentParsers.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecords/warcContentParsers.js~parseWarcInfoMetaDataContent",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/warcRecords/warcContentParsers.js",
    "importStyle": null,
    "description": "Parse a WARC Metadata records metadata content",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bufs",
        "description": "the WARC Metadata records content lines"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 277,
    "kind": "file",
    "name": "lib/writers/electron.js",
    "content": "/** @ignore */\nconst URL = require('url')\n/** @ignore */\nconst {STATUS_CODES} = require('http')\n/** @ignore */\nconst {isEmptyPlainObject, getResBodyElectron} = require('../utils')\nconst WARCWriterBase = require('./warcWriterBase')\nconst {CRLF} = require('./warcFields')\n\n/** @ignore */\nconst noGZ = /Content-Encoding.*gzip\\r\\n/gi\n/** @ignore */\nconst replaceContentLen = /Content-Length:.*\\r\\n/gi\n/** @ignore */\nconst UA = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.71 Safari/537.36'\n\n/**\n * @desc WARC Generator for use with Electron\n *\n * Expects request data from {@link ElectronRequestCapturer}\n * @see https://electron.atom.io/docs/\n * @see https://electron.atom.io/docs/api/debugger/\n * @link WARCWriterBase\n */\nclass ElectronWARCGenerator extends WARCWriterBase {\n  /**\n   * @desc Generates The Request Response WARC Records for POST\n   * @param {Object} nreq the captured HTTP request/response for the POST request\n   * @param {Object} wcDebugger the electron webcontents debugger object\n   * @return {Promise.<void>}\n   */\n  async generatePost (nreq, wcDebugger) {\n    let res\n    let requestHeaders\n    let responseHeaders\n    let purl\n    let headerKey\n    let head\n    res = nreq.res\n    /*\n      Chrome is HTTP/2 capable and NO KNOW REPLAY SYSTEM\n      can replay ANY request if it has an HTTP/2 protocol\n      but can if HTTP/2 -> HTTP/1.1 (man this hurts).\n      This is based off Pywb not being able too.\n      My general rule of thumb is if Pywb wont replay it :'(\n      then it is HIGHLY likely no other will\n    */\n    if (this._noHTTP2) {\n      if (!res) {\n        // request\n        purl = URL.parse(nreq.url)\n        if (!(nreq.headers.host || nreq.headers.Host)) {\n          nreq.headers['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = nreq.headers\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n        if (nreq.postData) {\n          await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)\n        } else {\n          await this.writeRequestRecord(nreq.url, requestHeaders)\n        }\n      } else {\n        // request\n        purl = URL.parse(nreq.url)\n        if (!(nreq.headers.host || nreq.headers.Host)) {\n          nreq.headers['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = nreq.headers\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n        // console.log(requestHeaders)\n        if (nreq.postData) {\n          await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)\n        } else {\n          await this.writeRequestRecord(nreq.url, requestHeaders)\n        }\n        // response\n        responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        head = res.headers\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n\n        // console.log(responseHeaders)\n        // if their is no response body these values are undefined\n        // do not request body if there is none or zero length body\n        let resData\n        let wasError = false\n        try {\n          let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        // console.log(responseHeaders)\n        // console.log(responseHeaders)\n        await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n      }\n    } else /* yes HTTP/2 */ {\n      if (!res) {\n        // request\n        purl = URL.parse(nreq.url)\n        if (!(nreq.headers.host || nreq.headers.Host)) {\n          nreq.headers['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = nreq.headers\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n        if (nreq.postData) {\n          await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)\n        } else {\n          await this.writeRequestRecord(nreq.url, requestHeaders)\n        }\n      } else {\n        // request\n        if (res.requestHeadersText) {\n          requestHeaders = res.requestHeadersText\n        } else {\n          purl = URL.parse(nreq.url)\n          if (!(nreq.headers.host || nreq.headers.Host)) {\n            nreq.headers['Host'] = purl.host\n          }\n          requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n          head = nreq.headers\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        }\n        // console.log(requestHeaders)\n\n        if (nreq.postData) {\n          await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)\n        } else {\n          await this.writeRequestRecord(nreq.url, requestHeaders)\n        }\n\n        // response\n        if (res.headersText) {\n          responseHeaders = res.headersText\n        } else {\n          responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n          head = res.headers\n          for (headerKey in head) {\n            responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          responseHeaders += `${CRLF}`\n        }\n\n        // console.log(responseHeaders)\n        // if their is no response body these values are undefined\n        // do not request body if there is none or zero length body\n        let resData\n        let wasError = false\n        try {\n          let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        // console.log(responseHeaders)\n        // console.log(responseHeaders)\n        await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n      }\n    }\n  }\n\n  /**\n   * @desc Special Case Handler To Correctly Serialize 3xx Responses.\n   *\n   * The browser will automatically chase down 3xx responses until terminal\n   * status is reached 2xx, 4xx, 5xx. So we must account for that fact and the\n   * redirectResponse is guarantied to be an array or plain object.\n   * @param {Object} nreq the captured HTTP request/response for the redirected request\n   * @param {Object} wcDebugger the electron webcontents debugger object\n   * @return {Promise.<void>}\n   */\n  async generateRedirectResponse (nreq, wcDebugger) {\n    // optimization for function speed by pulling up let decelerations\n    let purl // a parsed URL\n    let rderHeaders // a redirection responses HTTP headers string\n    let redirReses // an array of redirection responses\n    let head // a header object\n    let i // the one and only i\n    let aRedirect // a redirection response\n    let redirectLen\n    let requestHeaders // the HTTP headers string for the initial request that redirected\n    let res // the response object\n    let headerKey\n    let finalRequestHeaders\n    let finalResponseHeaders\n    let isMultiRedirect = Array.isArray(nreq.redirectResponse)\n\n    if (this._noHTTP2) {\n      /* The initial request */\n      if (isMultiRedirect) {\n        // multi redirection\n        head = nreq.headers\n        purl = URL.parse(nreq.url)\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        // no need for hasOwnProperty, https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Headers\n        // states headers is a json object\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        // single redirection\n        // the full request headers was not on the redirect\n        // must create it with the bare minimum info required\n        // emulates the dev tools and is what was actually sent\n        head = nreq.headers\n        purl = URL.parse(nreq.url)\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      }\n\n      await this.writeRequestRecord(nreq.url, requestHeaders)\n\n      /* the redirection or redirection chain */\n      if (isMultiRedirect) {\n        // multi redirection\n        // We handled the request for the first redirect, now for its response\n        head = nreq.redirectResponse[0].headers\n        aRedirect = nreq.redirectResponse[0]\n        rderHeaders = `HTTP/1.1 ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n        for (headerKey in head) {\n          rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        rderHeaders += `${CRLF}`\n        await this.writeResponseRecord(nreq.url, rderHeaders)\n        // now loop through the remaining redirection chain\n        redirectLen = nreq.redirectResponse.length\n        redirReses = nreq.redirectResponse\n        i = 1\n        for (; i < redirectLen; ++i) {\n          aRedirect = redirReses[i]\n          head = aRedirect.headers\n          purl = URL.parse(aRedirect.url)\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          requestHeaders = `${aRedirect.method} ${purl.path} HTTP/1.1${CRLF}`\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n          await this.writeRequestRecord(aRedirect.url, requestHeaders)\n          rderHeaders = `HTTP/1.1 ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n          head = aRedirect.headers\n          for (headerKey in head) {\n            rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          rderHeaders += `${CRLF}`\n          // console.log(rderHeaders)\n          rderHeaders = rderHeaders.replace(noGZ, '')\n          // console.log(rderHeaders)\n          await this.writeResponseRecord(aRedirect.url, rderHeaders)\n        }\n      } else {\n        // single redirection\n        // We handled the request for the redirect, now for its response\n        aRedirect = nreq.redirectResponse\n        rderHeaders = `HTTP/1.1 ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n        head = aRedirect.headers\n        for (headerKey in head) {\n          rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        rderHeaders += `${CRLF}`\n        // console.log(rderHeaders)\n        rderHeaders = rderHeaders.replace(noGZ, '')\n        // console.log(rderHeaders)\n        await this.writeResponseRecord(nreq.url, rderHeaders)\n      }\n\n      /* the final response (maybe has body) */\n      if (nreq.res) {\n        let isArray = Array.isArray(nreq.res)\n        res = nreq.res\n        if (isArray) {\n          res = res.shift()\n        }\n        // request for the final response in redirection / redirection chain\n        head = res.requestHeaders || nreq.headers\n        purl = URL.parse(res.url)\n\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        finalRequestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        for (headerKey in head) {\n          finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        finalRequestHeaders += `${CRLF}`\n\n        await this.writeRequestRecord(res.url, finalRequestHeaders)\n\n        // response for the final request in redirection / redirection chain\n        head = res.headers\n        finalResponseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        finalResponseHeaders += `${CRLF}`\n\n        // if their is no response body these values are undefined\n        // do not request body if there is none or zero length body\n        let resData\n        let wasError = false\n        try {\n          let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        // console.log(finalResponseHeaders)\n        if (!wasError) {\n          finalResponseHeaders = finalResponseHeaders.replace(noGZ, '')\n          finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        // console.log(finalResponseHeaders)\n        await this.writeResponseRecord(res.url, finalResponseHeaders, resData)\n        if (isArray && nreq.res.length > 0) {\n          let i = 0\n          let len = nreq.res.length\n          let anotherRes\n          for (; i < len; ++i) {\n            anotherRes = nreq.res[i]\n            if (anotherRes.url !== res.url ||\n              anotherRes.requestHeadersText !== res.requestHeadersText\n            ) {\n              head = anotherRes.requestHeaders || nreq.headers\n              purl = URL.parse(anotherRes.url)\n\n              if (!(head.host || head.Host)) {\n                head['Host'] = purl.host\n              }\n              finalRequestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n              for (headerKey in head) {\n                finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n              }\n              finalRequestHeaders += `${CRLF}`\n\n              await this.writeRequestRecord(anotherRes.url, finalRequestHeaders)\n\n              // anotherResponse for the final request in redirection / redirection chain\n              head = anotherRes.headers\n              finalResponseHeaders = `HTTP/1.1 ${anotherRes.status} ${anotherRes.statusText || STATUS_CODES[anotherRes.status]}${CRLF}`\n              for (headerKey in head) {\n                finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n              }\n              finalResponseHeaders += `${CRLF}`\n\n              // if their is no anotherResponse body these values are undefined\n              // do not request body if there is none or zero length body\n              let anotherResData\n              let wasError = false\n              try {\n                let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n                if (rbody.base64Encoded) {\n                  anotherResData = Buffer.from(rbody.body, 'base64')\n                } else {\n                  anotherResData = Buffer.from(rbody.body, 'utf8')\n                }\n              } catch (err) {\n                wasError = true\n              }\n              // console.log(finalResponseHeaders)\n              if (!wasError) {\n                finalResponseHeaders = finalResponseHeaders.replace(noGZ, '')\n                finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(anotherResData, 'utf8')}${CRLF}`)\n              }\n              // console.log(finalResponseHeaders)\n              await this.writeResponseRecord(anotherRes.url, finalResponseHeaders, anotherResData)\n            }\n          }\n        }\n      }\n    } else /* yes HTTP/2 */ {\n      /* The initial request */\n      if (isMultiRedirect) {\n        // multi redirection\n        // the full request headers is on the first redirect\n        if (nreq.redirectResponse[0].requestHeadersText) {\n          requestHeaders = nreq.redirectResponse[0].requestHeadersText\n        } else {\n          // the full request headers was not on the first redirect\n          // must create it with the bare minimum info required\n          // emulates the dev tools and is what was actually sent\n          head = nreq.headers\n          purl = URL.parse(nreq.url)\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          requestHeaders = `${nreq.method} ${purl.path} ${nreq.redirectResponse[0].protocol.toUpperCase()}${CRLF}`\n          // no need for hasOwnProperty, https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Headers\n          // states headers is a json object\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        }\n      } else {\n        // single redirection\n        if (nreq.redirectResponse.requestHeadersText) {\n          // the full request headers is on the redirect response\n          requestHeaders = nreq.redirectResponse.requestHeadersText\n        } else {\n          // the full request headers was not on the redirect\n          // must create it with the bare minimum info required\n          // emulates the dev tools and is what was actually sent\n          head = nreq.headers\n          purl = URL.parse(nreq.url)\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          requestHeaders = `${nreq.method} ${purl.path} ${nreq.redirectResponse.protocol.toUpperCase()}${CRLF}`\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        }\n      }\n\n      await this.writeRequestRecord(nreq.url, requestHeaders)\n\n      /* the redirection or redirection chain */\n      if (isMultiRedirect) {\n        // multi redirection\n        // We handled the request for the first redirect, now for its response\n        if (nreq.redirectResponse[0].headersText) {\n          // console.log(nreq.redirectResponse[0].headersText)\n          rderHeaders = nreq.redirectResponse[0].headersText\n        } else {\n          head = nreq.redirectResponse[0].headers\n          aRedirect = nreq.redirectResponse[0]\n          rderHeaders = `${aRedirect.protocol.toUpperCase()} ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n          for (headerKey in head) {\n            rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          rderHeaders += `${CRLF}`\n        }\n        await this.writeResponseRecord(nreq.url, rderHeaders)\n        // now loop through the remaining redirection chain\n        redirectLen = nreq.redirectResponse.length\n        redirReses = nreq.redirectResponse\n        i = 1\n        for (; i < redirectLen; ++i) {\n          aRedirect = redirReses[i]\n          if (aRedirect.requestHeadersText) {\n            requestHeaders = aRedirect.requestHeadersText\n          } else {\n            // the full request headers was not on the redirect\n            // must create it with the bare minimum info required\n            // emulates the dev tools and is what was actually sent\n            head = aRedirect.headers\n            purl = URL.parse(aRedirect.url)\n            if (!(head.host || head.Host)) {\n              head['Host'] = purl.host\n            }\n            requestHeaders = `${nreq.method} ${purl.path} ${aRedirect.protocol.toUpperCase()}${CRLF}`\n            for (headerKey in head) {\n              requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n            }\n            requestHeaders += `${CRLF}`\n          }\n          await this.writeRequestRecord(aRedirect.url, requestHeaders)\n          if (aRedirect.headersText) {\n            rderHeaders = aRedirect.headersText\n          } else {\n            rderHeaders = `${aRedirect.protocol.toUpperCase()} ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n            head = aRedirect.headers\n            for (headerKey in head) {\n              rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n            }\n            rderHeaders += `${CRLF}`\n          }\n          // console.log(rderHeaders)\n          rderHeaders = rderHeaders.replace(noGZ, '')\n          // console.log(rderHeaders)\n          await this.writeResponseRecord(aRedirect.url, rderHeaders)\n        }\n      } else {\n        // single redirection\n        // We handled the request for the redirect, now for its response\n        if (nreq.redirectResponse.headersText) {\n          rderHeaders = nreq.redirectResponse.headersText\n        } else {\n          aRedirect = nreq.redirectResponse\n          rderHeaders = `${aRedirect.protocol.toUpperCase()} ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n          head = aRedirect.headers\n          for (headerKey in head) {\n            rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          rderHeaders += `${CRLF}`\n        }\n        // console.log(rderHeaders)\n        rderHeaders = rderHeaders.replace(noGZ, '')\n        // console.log(rderHeaders)\n        await this.writeResponseRecord(nreq.url, rderHeaders)\n      }\n\n      /* the final response (maybe has body) */\n      if (nreq.res) {\n        let isArray = Array.isArray(nreq.res)\n        res = nreq.res\n        if (isArray) {\n          res = res.shift()\n        }\n        // request for the final response in redirection / redirection chain\n        if (res.requestHeadersText) {\n          finalRequestHeaders = res.requestHeadersText\n        } else {\n          head = res.requestHeaders || nreq.headers\n          purl = URL.parse(res.url)\n\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          finalRequestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n          for (headerKey in head) {\n            finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          finalRequestHeaders += `${CRLF}`\n        }\n\n        await this.writeRequestRecord(res.url, finalRequestHeaders)\n\n        // response for the final request in redirection / redirection chain\n        if (res.headersText) {\n          finalResponseHeaders = res.headersText\n        } else {\n          head = res.headers\n          finalResponseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n          for (headerKey in head) {\n            finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          finalResponseHeaders += `${CRLF}`\n        }\n\n        // if their is no response body these values are undefined\n        // do not request body if there is none or zero length body\n        let resData\n        let wasError = false\n        try {\n          let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        // console.log(finalResponseHeaders)\n        if (!wasError) {\n          finalResponseHeaders = finalResponseHeaders.replace(noGZ, '')\n          finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        // console.log(finalResponseHeaders)\n        await this.writeResponseRecord(res.url, finalResponseHeaders, resData)\n        if (isArray && nreq.res.length > 0) {\n          let i = 0\n          let len = nreq.res.length\n          let anotherRes\n          for (; i < len; ++i) {\n            anotherRes = nreq.res[i]\n            if (anotherRes.url !== res.url ||\n              anotherRes.requestHeadersText !== res.requestHeadersText\n            ) {\n              if (anotherRes.requestHeadersText) {\n                finalRequestHeaders = anotherRes.requestHeadersText\n              } else {\n                head = anotherRes.requestHeaders || nreq.headers\n                purl = URL.parse(anotherRes.url)\n                if (!(head.host || head.Host)) {\n                  head['Host'] = purl.host\n                }\n                finalRequestHeaders = `${nreq.method} ${purl.path} ${anotherRes.protocol.toUpperCase()}${CRLF}`\n                for (headerKey in head) {\n                  finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n                }\n                finalRequestHeaders += `${CRLF}`\n              }\n\n              await this.writeRequestRecord(anotherRes.url, finalRequestHeaders)\n\n              // anotherResponse for the final request in redirection / redirection chain\n              if (anotherRes.headersText) {\n                finalResponseHeaders = anotherRes.headersText\n              } else {\n                head = anotherRes.headers\n                finalResponseHeaders = `${anotherRes.protocol.toUpperCase()} ${anotherRes.status} ${anotherRes.statusText || STATUS_CODES[anotherRes.status]}${CRLF}`\n                for (headerKey in head) {\n                  finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n                }\n                finalResponseHeaders += `${CRLF}`\n              }\n\n              // if their is no anotherResponse body these values are undefined\n              // do not request body if there is none or zero length body\n              let anotherResData\n              let wasError = false\n              try {\n                let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n                if (rbody.base64Encoded) {\n                  anotherResData = Buffer.from(rbody.body, 'base64')\n                } else {\n                  anotherResData = Buffer.from(rbody.body, 'utf8')\n                }\n              } catch (err) {\n                wasError = true\n              }\n              // console.log(finalResponseHeaders)\n              if (!wasError) {\n                finalResponseHeaders = finalResponseHeaders.replace(noGZ, '')\n                finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(anotherResData, 'utf8')}${CRLF}`)\n              }\n              // console.log(finalResponseHeaders)\n              await this.writeResponseRecord(anotherRes.url, finalResponseHeaders, anotherResData)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @desc Generates The Request Response WARC Records for GET\n   * @param {Object} nreq the captured HTTP request/response for the GET request\n   * @param {Object} wcDebugger the electron webcontents debugger object\n   * @return {Promise.<void>}\n   */\n  async generateGet (nreq, wcDebugger) {\n    let res\n    let requestHeaders\n    let responseHeaders\n    let purl = URL.parse(nreq.url)\n    let headerKey\n    let head\n    let wasResArray = Array.isArray(nreq.res)\n    if (wasResArray) {\n      res = nreq.res.shift()\n    } else {\n      res = nreq.res\n    }\n    if (this._noHTTP2) {\n      if (res === null || res === undefined) {\n        // we do not have a response\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        if (!isEmptyPlainObject(nreq.headers)) {\n          // the headers object is present\n          head = nreq.headers\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        } else {\n          // the headers object is not present, recreate with minimal information\n          requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n        }\n\n        await this.writeRequestRecord(nreq.url, requestHeaders)\n        // console.log(requestHeaders)\n      } else {\n        if (res.protocol === 'data') {\n          return\n        }\n        if (!isEmptyPlainObject(res.requestHeaders)) {\n          // response did not have the full request headers string use object\n          requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n          head = res.requestHeaders\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        } else {\n          // response has no full request http headers information\n          requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n          if (!isEmptyPlainObject(nreq.headers)) {\n            // the request object has the request http header object\n            head = nreq.headers\n            if (!(head.host || head.Host)) {\n              head['Host'] = purl.host\n            }\n            for (headerKey in head) {\n              requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n            }\n            requestHeaders += `${CRLF}`\n          } else {\n            // the request object does not have the request http header information\n            // recreate with minimal information\n            requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n          }\n        }\n\n        await this.writeRequestRecord(nreq.url, requestHeaders)\n\n        if (!isEmptyPlainObject(res.headers)) {\n          head = res.headers\n          responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n          for (headerKey in head) {\n            responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          responseHeaders += `${CRLF}`\n        } else {\n          responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        }\n\n        let resData\n        let wasError = false\n        try {\n          let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n\n        if (wasResArray && nreq.res.length > 0) {\n          let i = 0\n          let len = nreq.res.length\n          for (; i < len; ++i) {\n            res = nreq.res[i]\n            if (!isEmptyPlainObject(res.headers)) {\n              head = res.headers\n              responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n              for (headerKey in head) {\n                responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n              }\n              responseHeaders += `${CRLF}`\n            } else {\n              continue\n            }\n\n            let resData\n            let wasError = false\n            try {\n              let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n              if (rbody.base64Encoded) {\n                resData = Buffer.from(rbody.body, 'base64')\n              } else {\n                resData = Buffer.from(rbody.body, 'utf8')\n              }\n            } catch (err) {\n              wasError = true\n            }\n\n            if (!wasError) {\n              responseHeaders = responseHeaders.replace(noGZ, '')\n              responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n            }\n            await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n          }\n        }\n      }\n    } else /* yes HTTP/2 */ {\n      if (res === null || res === undefined) {\n        // we do not have a response\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        if (!isEmptyPlainObject(nreq.headers)) {\n          // the headers object is present\n          head = nreq.headers\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        } else {\n          // the headers object is not present, recreate with minimal information\n          requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n        }\n\n        await this.writeRequestRecord(nreq.url, requestHeaders)\n        // console.log(requestHeaders)\n      } else {\n        if (res.protocol === 'data') {\n          return\n        }\n        if (res.requestHeadersText) {\n          // response has full request headers string\n          requestHeaders = res.requestHeadersText\n        } else if (!isEmptyPlainObject(res.requestHeaders)) {\n          // response did not have the full request headers string use object\n          requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n          head = res.requestHeaders\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        } else {\n          // response has no full request http headers information\n          requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n          if (!isEmptyPlainObject(nreq.headers)) {\n            // the request object has the request http header object\n            head = nreq.headers\n            if (!(head.host || head.Host)) {\n              head['Host'] = purl.host\n            }\n            for (headerKey in head) {\n              requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n            }\n            requestHeaders += `${CRLF}`\n          } else {\n            // the request object does not have the request http header information\n            // recreate with minimal information\n            requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n          }\n        }\n\n        await this.writeRequestRecord(nreq.url, requestHeaders)\n\n        if (res.headersText) {\n          responseHeaders = res.headersText\n        } else if (!isEmptyPlainObject(res.headers)) {\n          head = res.headers\n          responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n          for (headerKey in head) {\n            responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          responseHeaders += `${CRLF}`\n        } else {\n          responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        }\n\n        let resData\n        let wasError = false\n        try {\n          let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n\n        if (wasResArray && nreq.res.length > 0) {\n          let i = 0\n          let len = nreq.res.length\n          for (; i < len; ++i) {\n            res = nreq.res[i]\n            if (res.headersText) {\n              responseHeaders = res.headersText\n            } else if (!isEmptyPlainObject(res.headers)) {\n              head = res.headers\n              responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n              for (headerKey in head) {\n                responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n              }\n              responseHeaders += `${CRLF}`\n            } else {\n              continue\n            }\n            let resData\n            let wasError = false\n            try {\n              let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n              if (rbody.base64Encoded) {\n                resData = Buffer.from(rbody.body, 'base64')\n              } else {\n                resData = Buffer.from(rbody.body, 'utf8')\n              }\n            } catch (err) {\n              wasError = true\n            }\n\n            if (!wasError) {\n              responseHeaders = responseHeaders.replace(noGZ, '')\n              responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n            }\n            await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @desc Generates The Request Response WARC Records for OPTIONS\n   * @param {Object} nreq the captured HTTP request/response for the OPTIONS request\n   * @param {Object} wcDebugger the electron webcontents debugger object\n   * @return {Promise.<void>}\n   */\n  async generateOptions (nreq, wcDebugger) {\n    let res\n    let requestHeaders\n    let responseHeaders\n    let purl = URL.parse(nreq.url)\n    let headerKey\n    let head\n\n    if (Array.isArray(nreq.res)) {\n      res = nreq.res.shift()\n    } else {\n      res = nreq.res\n    }\n\n    if (this._noHTTP2) {\n      if (!isEmptyPlainObject(res.requestHeaders)) {\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = res.requestHeaders\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n      } else if (!isEmptyPlainObject(nreq.headers)) {\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = nreq.headers\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        return\n      }\n      await this.writeRequestRecord(nreq.url, requestHeaders)\n\n      if (!isEmptyPlainObject(res.headers)) {\n        head = res.headers\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n      } else {\n        return\n      }\n      await this.writeResponseRecord(nreq.url, responseHeaders)\n    } else /* yes HTTP2 */ {\n      if (res.requestHeadersText) {\n        requestHeaders = res.requestHeadersText\n      } else if (!isEmptyPlainObject(res.requestHeaders)) {\n        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n        head = res.requestHeaders\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n      } else if (!isEmptyPlainObject(nreq.headers)) {\n        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n        head = nreq.headers\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        return\n      }\n      await this.writeRequestRecord(nreq.url, requestHeaders)\n\n      if (res.headersText) {\n        responseHeaders = res.headersText\n      } else if (!isEmptyPlainObject(res.headers)) {\n        head = res.headers\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n      } else {\n        return\n      }\n      await this.writeResponseRecord(nreq.url, responseHeaders)\n    }\n  }\n\n  /**\n   * @desc Handle Non HTTP POST GET OPTIONS request. And yes the live web uses them all\n   * @param {Object} nreq the captured HTTP request/response\n   * @param {Object} wcDebugger the electron webcontents debugger object\n   * @return {Promise.<void>}\n   */\n  async generateOther (nreq, wcDebugger) {\n    // ducktape\n    if (!nreq.postData) {\n      await this.generateGet(nreq, wcDebugger)\n    } else {\n      await this.generatePost(nreq, wcDebugger)\n    }\n  }\n\n  /**\n   * @desc If a stray response comes in without a request HTTP/2 likely preserve it!\n   * @param {Object} nreq the captured HTTP response\n   * @param {Object} wcDebugger the electron webcontents debugger object\n   * @return {Promise.<void>}\n   */\n  async generateOnlyRes (nreq, wcDebugger) {\n    let res = nreq.res\n    let requestHeaders\n    let responseHeaders\n    let purl = URL.parse(res.url)\n    let headerKey\n    let head\n    res.protocol = res.protocol || 'http/1.1'\n    if (res.protocol === 'data') {\n      return\n    }\n\n    if (res.requestHeadersText) {\n      nreq.method = res.requestHeadersText.substring(0, res.requestHeadersText.indexOf(' '))\n    } else {\n      // we handle htt2 :method\n      return\n    }\n\n    if (this._noHTTP2) {\n      if (!isEmptyPlainObject(res.requestHeaders)) {\n        // response did not have the full request headers string use object\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = res.requestHeaders\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        // response has no full request http headers information\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        // the request object does not have the request http header information\n        // recreate with minimal information\n        requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n      }\n\n      await this.writeRequestRecord(res.url, requestHeaders)\n\n      if (!isEmptyPlainObject(res.headers)) {\n        head = res.headers\n        responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n      } else {\n        return\n      }\n\n      let resData\n      let wasError = false\n      try {\n        let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n        if (rbody.base64Encoded) {\n          resData = Buffer.from(rbody.body, 'base64')\n        } else {\n          resData = Buffer.from(rbody.body, 'utf8')\n        }\n      } catch (err) {\n        wasError = true\n      }\n\n      if (!wasError) {\n        responseHeaders = responseHeaders.replace(noGZ, '')\n        responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n      }\n      await this.writeResponseRecord(res.url, responseHeaders, resData)\n    } else /* yes HTTP/2 */ {\n      if (res.requestHeadersText) {\n        // response has full request headers string\n        requestHeaders = res.requestHeadersText\n      } else if (!isEmptyPlainObject(res.requestHeaders)) {\n        // response did not have the full request headers string use object\n        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n        head = res.requestHeaders\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        // response has no full request http headers information\n        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n        // the request object does not have the request http header information\n        // recreate with minimal information\n        requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n      }\n\n      await this.writeRequestRecord(res.url, requestHeaders)\n\n      if (res.headersText) {\n        responseHeaders = res.headersText\n      } else if (!isEmptyPlainObject(res.headers)) {\n        head = res.headers\n        responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n      } else {\n        return\n      }\n\n      let resData\n      let wasError = false\n      try {\n        let rbody = await getResBodyElectron(nreq.requestId, wcDebugger)\n        if (rbody.base64Encoded) {\n          resData = Buffer.from(rbody.body, 'base64')\n        } else {\n          resData = Buffer.from(rbody.body, 'utf8')\n        }\n      } catch (err) {\n        wasError = true\n      }\n\n      if (!wasError) {\n        responseHeaders = responseHeaders.replace(noGZ, '')\n        responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n      }\n      await this.writeResponseRecord(res.url, responseHeaders, resData)\n    }\n  }\n}\n\nmodule.exports = ElectronWARCGenerator\n",
    "static": true,
    "longname": "lib/writers/electron.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 278,
    "kind": "variable",
    "name": "URL",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~URL",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "variable",
    "name": "STATUS_CODES",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~STATUS_CODES",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "variable",
    "name": "isEmptyPlainObject",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~isEmptyPlainObject",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "variable",
    "name": "WARCWriterBase",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~WARCWriterBase",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "variable",
    "name": "CRLF",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~CRLF",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "variable",
    "name": "noGZ",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~noGZ",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "ignore": true,
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "variable",
    "name": "replaceContentLen",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~replaceContentLen",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "ignore": true,
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "variable",
    "name": "UA",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~UA",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "ignore": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "class",
    "name": "ElectronWARCGenerator",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": null,
    "description": "WARC Generator for use with Electron\n\nExpects request data from {@link ElectronRequestCapturer}",
    "see": [
      "https://electron.atom.io/docs/",
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@link",
        "tagValue": "WARCWriterBase"
      }
    ],
    "interface": false,
    "extends": [
      "WARCWriterBase"
    ]
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "generatePost",
    "memberof": "lib/writers/electron.js~ElectronWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator#generatePost",
    "access": null,
    "description": "Generates The Request Response WARC Records for POST",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response for the POST request"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the electron webcontents debugger object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "generateRedirectResponse",
    "memberof": "lib/writers/electron.js~ElectronWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator#generateRedirectResponse",
    "access": null,
    "description": "Special Case Handler To Correctly Serialize 3xx Responses.\n\nThe browser will automatically chase down 3xx responses until terminal\nstatus is reached 2xx, 4xx, 5xx. So we must account for that fact and the\nredirectResponse is guarantied to be an array or plain object.",
    "lineNumber": 205,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response for the redirected request"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the electron webcontents debugger object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "generateGet",
    "memberof": "lib/writers/electron.js~ElectronWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator#generateGet",
    "access": null,
    "description": "Generates The Request Response WARC Records for GET",
    "lineNumber": 674,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response for the GET request"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the electron webcontents debugger object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 290,
    "kind": "method",
    "name": "generateOptions",
    "memberof": "lib/writers/electron.js~ElectronWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator#generateOptions",
    "access": null,
    "description": "Generates The Request Response WARC Records for OPTIONS",
    "lineNumber": 952,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response for the OPTIONS request"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the electron webcontents debugger object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "generateOther",
    "memberof": "lib/writers/electron.js~ElectronWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator#generateOther",
    "access": null,
    "description": "Handle Non HTTP POST GET OPTIONS request. And yes the live web uses them all",
    "lineNumber": 1057,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the electron webcontents debugger object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "generateOnlyRes",
    "memberof": "lib/writers/electron.js~ElectronWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator#generateOnlyRes",
    "access": null,
    "description": "If a stray response comes in without a request HTTP/2 likely preserve it!",
    "lineNumber": 1072,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP response"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the electron webcontents debugger object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 293,
    "kind": "file",
    "name": "lib/writers/index.js",
    "content": "module.exports = {\n  ElectronWARCWriter: require('./electron'),\n  RemoteChromeWARCWriter: require('./remoteChrome')\n}\n",
    "static": true,
    "longname": "lib/writers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 294,
    "kind": "file",
    "name": "lib/writers/remoteChrome.js",
    "content": "/** @ignore */\nconst URL = require('url')\n/** @ignore */\nconst {STATUS_CODES} = require('http')\n/** @ignore */\nconst isEmptyPlainObject = require('../utils/isEmptyPlainObject')\nconst WARCWriterBase = require('./warcWriterBase')\nconst {CRLF} = require('./warcFields')\n\n/** @ignore */\nconst noGZ = /Content-Encoding.*gzip\\r\\n/gi\n/** @ignore */\nconst replaceContentLen = /Content-Length:.*\\r\\n/gi\n/** @ignore */\nconst UA = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.71 Safari/537.36'\n\n/**\n * @desc WARC Generator for use with chrome-remote-interface\n *\n * Expects request data from {@link RemoteChromeRequestCapturer}\n * @see https://github.com/cyrus-and/chrome-remote-interface\n * @link WARCWriterBase\n */\nclass RemoteChromeWARCGenerator extends WARCWriterBase {\n  /**\n   * @desc Generates The Request Response WARC Records for POST\n   * @param {Object} nreq the captured HTTP request/response for the POST request\n   * @param {Object} network the chrome-remote-interface Network object\n   * @return {Promise.<void>}\n   */\n  async generatePost (nreq, network) {\n    let res\n    let requestHeaders\n    let responseHeaders\n    let purl\n    let headerKey\n    let head\n    res = nreq.res\n    /*\n      Chrome is HTTP/2 capable and NO KNOW REPLAY SYSTEM\n      can replay ANY request if it has an HTTP/2 protocol\n      but can if HTTP/2 -> HTTP/1.1 (man this hurts).\n      This is based off Pywb not being able too.\n      My general rule of thumb is if Pywb wont replay it :'(\n      then it is HIGHLY likely no other will\n    */\n    if (this._noHTTP2) {\n      if (!res) {\n        // request\n        purl = URL.parse(nreq.url)\n        if (!(nreq.headers.host || nreq.headers.Host)) {\n          nreq.headers['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = nreq.headers\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n        if (nreq.postData) {\n          await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)\n        } else {\n          await this.writeRequestRecord(nreq.url, requestHeaders)\n        }\n      } else {\n        // request\n        purl = URL.parse(nreq.url)\n        if (!(nreq.headers.host || nreq.headers.Host)) {\n          nreq.headers['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = nreq.headers\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n        // console.log(requestHeaders)\n        if (nreq.postData) {\n          await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)\n        } else {\n          await this.writeRequestRecord(nreq.url, requestHeaders)\n        }\n        // response\n        responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        head = res.headers\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n\n        // console.log(responseHeaders)\n        // if their is no response body these values are undefined\n        // do not request body if there is none or zero length body\n        let resData\n        let wasError = false\n        try {\n          let rbody = await network.getResponseBody({requestId: nreq.requestId})\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        // console.log(responseHeaders)\n        // console.log(responseHeaders)\n        await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n      }\n    } else /* yes HTTP/2 */ {\n      if (!res) {\n        // request\n        purl = URL.parse(nreq.url)\n        if (!(nreq.headers.host || nreq.headers.Host)) {\n          nreq.headers['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = nreq.headers\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n        if (nreq.postData) {\n          await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)\n        } else {\n          await this.writeRequestRecord(nreq.url, requestHeaders)\n        }\n      } else {\n        // request\n        if (res.requestHeadersText) {\n          requestHeaders = res.requestHeadersText\n        } else {\n          purl = URL.parse(nreq.url)\n          if (!(nreq.headers.host || nreq.headers.Host)) {\n            nreq.headers['Host'] = purl.host\n          }\n          requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n          head = nreq.headers\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        }\n        // console.log(requestHeaders)\n\n        if (nreq.postData) {\n          await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)\n        } else {\n          await this.writeRequestRecord(nreq.url, requestHeaders)\n        }\n\n        // response\n        if (res.headersText) {\n          responseHeaders = res.headersText\n        } else {\n          responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n          head = res.headers\n          for (headerKey in head) {\n            responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          responseHeaders += `${CRLF}`\n        }\n\n        // console.log(responseHeaders)\n        // if their is no response body these values are undefined\n        // do not request body if there is none or zero length body\n        let resData\n        let wasError = false\n        try {\n          let rbody = await network.getResponseBody({requestId: nreq.requestId})\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        // console.log(responseHeaders)\n        // console.log(responseHeaders)\n        await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n      }\n    }\n  }\n\n  /**\n   * @desc Special Case Handler To Correctly Serialize 3xx Responses.\n   *\n   * The browser will automatically chase down 3xx responses until terminal\n   * status is reached 2xx, 4xx, 5xx. So we must account for that fact and the\n   * redirectResponse is guarantied to be an array or plain object.\n   * @param {Object} nreq the captured HTTP request/response for the redirected request\n   * @param {Object} network the chrome-remote-interface Network object\n   * @return {Promise.<void>}\n   */\n  async generateRedirectResponse (nreq, network) {\n    // optimization for function speed by pulling up let decelerations\n    let purl // a parsed URL\n    let rderHeaders // a redirection responses HTTP headers string\n    let redirReses // an array of redirection responses\n    let head // a header object\n    let i // the one and only i\n    let aRedirect // a redirection response\n    let redirectLen\n    let requestHeaders // the HTTP headers string for the initial request that redirected\n    let res // the response object\n    let headerKey\n    let finalRequestHeaders\n    let finalResponseHeaders\n    let isMultiRedirect = Array.isArray(nreq.redirectResponse)\n\n    if (this._noHTTP2) {\n      /* The initial request */\n      if (isMultiRedirect) {\n        // multi redirection\n        head = nreq.headers\n        purl = URL.parse(nreq.url)\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        // no need for hasOwnProperty, https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Headers\n        // states headers is a json object\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        // single redirection\n        // the full request headers was not on the redirect\n        // must create it with the bare minimum info required\n        // emulates the dev tools and is what was actually sent\n        head = nreq.headers\n        purl = URL.parse(nreq.url)\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      }\n\n      await this.writeRequestRecord(nreq.url, requestHeaders)\n\n      /* the redirection or redirection chain */\n      if (isMultiRedirect) {\n        // multi redirection\n        // We handled the request for the first redirect, now for its response\n        head = nreq.redirectResponse[0].headers\n        aRedirect = nreq.redirectResponse[0]\n        rderHeaders = `HTTP/1.1 ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n        for (headerKey in head) {\n          rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        rderHeaders += `${CRLF}`\n        await this.writeResponseRecord(nreq.url, rderHeaders)\n        // now loop through the remaining redirection chain\n        redirectLen = nreq.redirectResponse.length\n        redirReses = nreq.redirectResponse\n        i = 1\n        for (; i < redirectLen; ++i) {\n          aRedirect = redirReses[i]\n          head = aRedirect.headers\n          purl = URL.parse(aRedirect.url)\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          requestHeaders = `${aRedirect.method} ${purl.path} HTTP/1.1${CRLF}`\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n          await this.writeRequestRecord(aRedirect.url, requestHeaders)\n          rderHeaders = `HTTP/1.1 ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n          head = aRedirect.headers\n          for (headerKey in head) {\n            rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          rderHeaders += `${CRLF}`\n          // console.log(rderHeaders)\n          rderHeaders = rderHeaders.replace(noGZ, '')\n          // console.log(rderHeaders)\n          await this.writeResponseRecord(aRedirect.url, rderHeaders)\n        }\n      } else {\n        // single redirection\n        // We handled the request for the redirect, now for its response\n        aRedirect = nreq.redirectResponse\n        rderHeaders = `HTTP/1.1 ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n        head = aRedirect.headers\n        for (headerKey in head) {\n          rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        rderHeaders += `${CRLF}`\n        // console.log(rderHeaders)\n        rderHeaders = rderHeaders.replace(noGZ, '')\n        // console.log(rderHeaders)\n        await this.writeResponseRecord(nreq.url, rderHeaders)\n      }\n\n      /* the final response (maybe has body) */\n      if (nreq.res) {\n        let isArray = Array.isArray(nreq.res)\n        res = nreq.res\n        if (isArray) {\n          res = res.shift()\n        }\n        // request for the final response in redirection / redirection chain\n        head = res.requestHeaders || nreq.headers\n        purl = URL.parse(res.url)\n\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        finalRequestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        for (headerKey in head) {\n          finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        finalRequestHeaders += `${CRLF}`\n\n        await this.writeRequestRecord(res.url, finalRequestHeaders)\n\n        // response for the final request in redirection / redirection chain\n        head = res.headers\n        finalResponseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        finalResponseHeaders += `${CRLF}`\n\n        // if their is no response body these values are undefined\n        // do not request body if there is none or zero length body\n        let resData\n        let wasError = false\n        try {\n          let rbody = await network.getResponseBody({requestId: nreq.requestId})\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        // console.log(finalResponseHeaders)\n        if (!wasError) {\n          finalResponseHeaders = finalResponseHeaders.replace(noGZ, '')\n          finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        // console.log(finalResponseHeaders)\n        await this.writeResponseRecord(res.url, finalResponseHeaders, resData)\n        if (isArray && nreq.res.length > 0) {\n          let i = 0\n          let len = nreq.res.length\n          let anotherRes\n          for (; i < len; ++i) {\n            anotherRes = nreq.res[i]\n            if (anotherRes.url !== res.url ||\n              anotherRes.requestHeadersText !== res.requestHeadersText\n            ) {\n              head = anotherRes.requestHeaders || nreq.headers\n              purl = URL.parse(anotherRes.url)\n\n              if (!(head.host || head.Host)) {\n                head['Host'] = purl.host\n              }\n              finalRequestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n              for (headerKey in head) {\n                finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n              }\n              finalRequestHeaders += `${CRLF}`\n\n              await this.writeRequestRecord(anotherRes.url, finalRequestHeaders)\n\n              // anotherResponse for the final request in redirection / redirection chain\n              head = anotherRes.headers\n              finalResponseHeaders = `HTTP/1.1 ${anotherRes.status} ${anotherRes.statusText || STATUS_CODES[anotherRes.status]}${CRLF}`\n              for (headerKey in head) {\n                finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n              }\n              finalResponseHeaders += `${CRLF}`\n\n              // if their is no anotherResponse body these values are undefined\n              // do not request body if there is none or zero length body\n              let anotherResData\n              let wasError = false\n              try {\n                let rbody = await network.getResponseBody({requestId: nreq.requestId})\n                if (rbody.base64Encoded) {\n                  anotherResData = Buffer.from(rbody.body, 'base64')\n                } else {\n                  anotherResData = Buffer.from(rbody.body, 'utf8')\n                }\n              } catch (err) {\n                wasError = true\n              }\n              // console.log(finalResponseHeaders)\n              if (!wasError) {\n                finalResponseHeaders = finalResponseHeaders.replace(noGZ, '')\n                finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(anotherResData, 'utf8')}${CRLF}`)\n              }\n              // console.log(finalResponseHeaders)\n              await this.writeResponseRecord(anotherRes.url, finalResponseHeaders, anotherResData)\n            }\n          }\n        }\n      }\n    } else /* yes HTTP/2 */ {\n      /* The initial request */\n      if (isMultiRedirect) {\n        // multi redirection\n        // the full request headers is on the first redirect\n        if (nreq.redirectResponse[0].requestHeadersText) {\n          requestHeaders = nreq.redirectResponse[0].requestHeadersText\n        } else {\n          // the full request headers was not on the first redirect\n          // must create it with the bare minimum info required\n          // emulates the dev tools and is what was actually sent\n          head = nreq.headers\n          purl = URL.parse(nreq.url)\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          requestHeaders = `${nreq.method} ${purl.path} ${nreq.redirectResponse[0].protocol.toUpperCase()}${CRLF}`\n          // no need for hasOwnProperty, https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Headers\n          // states headers is a json object\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        }\n      } else {\n        // single redirection\n        if (nreq.redirectResponse.requestHeadersText) {\n          // the full request headers is on the redirect response\n          requestHeaders = nreq.redirectResponse.requestHeadersText\n        } else {\n          // the full request headers was not on the redirect\n          // must create it with the bare minimum info required\n          // emulates the dev tools and is what was actually sent\n          head = nreq.headers\n          purl = URL.parse(nreq.url)\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          requestHeaders = `${nreq.method} ${purl.path} ${nreq.redirectResponse.protocol.toUpperCase()}${CRLF}`\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        }\n      }\n\n      await this.writeRequestRecord(nreq.url, requestHeaders)\n\n      /* the redirection or redirection chain */\n      if (isMultiRedirect) {\n        // multi redirection\n        // We handled the request for the first redirect, now for its response\n        if (nreq.redirectResponse[0].headersText) {\n          // console.log(nreq.redirectResponse[0].headersText)\n          rderHeaders = nreq.redirectResponse[0].headersText\n        } else {\n          head = nreq.redirectResponse[0].headers\n          aRedirect = nreq.redirectResponse[0]\n          rderHeaders = `${aRedirect.protocol.toUpperCase()} ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n          for (headerKey in head) {\n            rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          rderHeaders += `${CRLF}`\n        }\n        await this.writeResponseRecord(nreq.url, rderHeaders)\n        // now loop through the remaining redirection chain\n        redirectLen = nreq.redirectResponse.length\n        redirReses = nreq.redirectResponse\n        i = 1\n        for (; i < redirectLen; ++i) {\n          aRedirect = redirReses[i]\n          if (aRedirect.requestHeadersText) {\n            requestHeaders = aRedirect.requestHeadersText\n          } else {\n            // the full request headers was not on the redirect\n            // must create it with the bare minimum info required\n            // emulates the dev tools and is what was actually sent\n            head = aRedirect.headers\n            purl = URL.parse(aRedirect.url)\n            if (!(head.host || head.Host)) {\n              head['Host'] = purl.host\n            }\n            requestHeaders = `${nreq.method} ${purl.path} ${aRedirect.protocol.toUpperCase()}${CRLF}`\n            for (headerKey in head) {\n              requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n            }\n            requestHeaders += `${CRLF}`\n          }\n          await this.writeRequestRecord(aRedirect.url, requestHeaders)\n          if (aRedirect.headersText) {\n            rderHeaders = aRedirect.headersText\n          } else {\n            rderHeaders = `${aRedirect.protocol.toUpperCase()} ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n            head = aRedirect.headers\n            for (headerKey in head) {\n              rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n            }\n            rderHeaders += `${CRLF}`\n          }\n          // console.log(rderHeaders)\n          rderHeaders = rderHeaders.replace(noGZ, '')\n          // console.log(rderHeaders)\n          await this.writeResponseRecord(aRedirect.url, rderHeaders)\n        }\n      } else {\n        // single redirection\n        // We handled the request for the redirect, now for its response\n        if (nreq.redirectResponse.headersText) {\n          rderHeaders = nreq.redirectResponse.headersText\n        } else {\n          aRedirect = nreq.redirectResponse\n          rderHeaders = `${aRedirect.protocol.toUpperCase()} ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`\n          head = aRedirect.headers\n          for (headerKey in head) {\n            rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          rderHeaders += `${CRLF}`\n        }\n        // console.log(rderHeaders)\n        rderHeaders = rderHeaders.replace(noGZ, '')\n        // console.log(rderHeaders)\n        await this.writeResponseRecord(nreq.url, rderHeaders)\n      }\n\n      /* the final response (maybe has body) */\n      if (nreq.res) {\n        let isArray = Array.isArray(nreq.res)\n        res = nreq.res\n        if (isArray) {\n          res = res.shift()\n        }\n        // request for the final response in redirection / redirection chain\n        if (res.requestHeadersText) {\n          finalRequestHeaders = res.requestHeadersText\n        } else {\n          head = res.requestHeaders || nreq.headers\n          purl = URL.parse(res.url)\n\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          finalRequestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n          for (headerKey in head) {\n            finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          finalRequestHeaders += `${CRLF}`\n        }\n\n        await this.writeRequestRecord(res.url, finalRequestHeaders)\n\n        // response for the final request in redirection / redirection chain\n        if (res.headersText) {\n          finalResponseHeaders = res.headersText\n        } else {\n          head = res.headers\n          finalResponseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n          for (headerKey in head) {\n            finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          finalResponseHeaders += `${CRLF}`\n        }\n\n        // if their is no response body these values are undefined\n        // do not request body if there is none or zero length body\n        let resData\n        let wasError = false\n        try {\n          let rbody = await network.getResponseBody({requestId: nreq.requestId})\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        // console.log(finalResponseHeaders)\n        if (!wasError) {\n          finalResponseHeaders = finalResponseHeaders.replace(noGZ, '')\n          finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        // console.log(finalResponseHeaders)\n        await this.writeResponseRecord(res.url, finalResponseHeaders, resData)\n        if (isArray && nreq.res.length > 0) {\n          let i = 0\n          let len = nreq.res.length\n          let anotherRes\n          for (; i < len; ++i) {\n            anotherRes = nreq.res[i]\n            if (anotherRes.url !== res.url ||\n              anotherRes.requestHeadersText !== res.requestHeadersText\n            ) {\n              if (anotherRes.requestHeadersText) {\n                finalRequestHeaders = anotherRes.requestHeadersText\n              } else {\n                head = anotherRes.requestHeaders || nreq.headers\n                purl = URL.parse(anotherRes.url)\n                if (!(head.host || head.Host)) {\n                  head['Host'] = purl.host\n                }\n                finalRequestHeaders = `${nreq.method} ${purl.path} ${anotherRes.protocol.toUpperCase()}${CRLF}`\n                for (headerKey in head) {\n                  finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n                }\n                finalRequestHeaders += `${CRLF}`\n              }\n\n              await this.writeRequestRecord(anotherRes.url, finalRequestHeaders)\n\n              // anotherResponse for the final request in redirection / redirection chain\n              if (anotherRes.headersText) {\n                finalResponseHeaders = anotherRes.headersText\n              } else {\n                head = anotherRes.headers\n                finalResponseHeaders = `${anotherRes.protocol.toUpperCase()} ${anotherRes.status} ${anotherRes.statusText || STATUS_CODES[anotherRes.status]}${CRLF}`\n                for (headerKey in head) {\n                  finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n                }\n                finalResponseHeaders += `${CRLF}`\n              }\n\n              // if their is no anotherResponse body these values are undefined\n              // do not request body if there is none or zero length body\n              let anotherResData\n              let wasError = false\n              try {\n                let rbody = await network.getResponseBody({requestId: nreq.requestId})\n                if (rbody.base64Encoded) {\n                  anotherResData = Buffer.from(rbody.body, 'base64')\n                } else {\n                  anotherResData = Buffer.from(rbody.body, 'utf8')\n                }\n              } catch (err) {\n                wasError = true\n              }\n              // console.log(finalResponseHeaders)\n              if (!wasError) {\n                finalResponseHeaders = finalResponseHeaders.replace(noGZ, '')\n                finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(anotherResData, 'utf8')}${CRLF}`)\n              }\n              // console.log(finalResponseHeaders)\n              await this.writeResponseRecord(anotherRes.url, finalResponseHeaders, anotherResData)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @desc Generates The Request Response WARC Records for GET\n   * @param {Object} nreq the captured HTTP request/response for the GET request\n   * @param {Object} network the chrome-remote-interface Network object\n   * @return {Promise.<void>}\n   */\n  async generateGet (nreq, network) {\n    let res\n    let requestHeaders\n    let responseHeaders\n    let purl = URL.parse(nreq.url)\n    let headerKey\n    let head\n    let wasResArray = Array.isArray(nreq.res)\n    if (wasResArray) {\n      res = nreq.res.shift()\n    } else {\n      res = nreq.res\n    }\n    if (this._noHTTP2) {\n      if (res === null || res === undefined) {\n        // we do not have a response\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        if (!isEmptyPlainObject(nreq.headers)) {\n          // the headers object is present\n          head = nreq.headers\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        } else {\n          // the headers object is not present, recreate with minimal information\n          requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n        }\n\n        await this.writeRequestRecord(nreq.url, requestHeaders)\n        // console.log(requestHeaders)\n      } else {\n        if (res.protocol === 'data') {\n          return\n        }\n        if (!isEmptyPlainObject(res.requestHeaders)) {\n          // response did not have the full request headers string use object\n          requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n          head = res.requestHeaders\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        } else {\n          // response has no full request http headers information\n          requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n          if (!isEmptyPlainObject(nreq.headers)) {\n            // the request object has the request http header object\n            head = nreq.headers\n            if (!(head.host || head.Host)) {\n              head['Host'] = purl.host\n            }\n            for (headerKey in head) {\n              requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n            }\n            requestHeaders += `${CRLF}`\n          } else {\n            // the request object does not have the request http header information\n            // recreate with minimal information\n            requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n          }\n        }\n\n        await this.writeRequestRecord(nreq.url, requestHeaders)\n\n        if (!isEmptyPlainObject(res.headers)) {\n          head = res.headers\n          responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n          for (headerKey in head) {\n            responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          responseHeaders += `${CRLF}`\n        } else {\n          responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        }\n\n        let resData\n        let wasError = false\n        try {\n          let rbody = await network.getResponseBody({requestId: nreq.requestId})\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n\n        if (wasResArray && nreq.res.length > 0) {\n          let i = 0\n          let len = nreq.res.length\n          for (; i < len; ++i) {\n            res = nreq.res[i]\n            if (!isEmptyPlainObject(res.headers)) {\n              head = res.headers\n              responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n              for (headerKey in head) {\n                responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n              }\n              responseHeaders += `${CRLF}`\n            } else {\n              continue\n            }\n\n            let resData\n            let wasError = false\n            try {\n              let rbody = await network.getResponseBody({requestId: nreq.requestId})\n              if (rbody.base64Encoded) {\n                resData = Buffer.from(rbody.body, 'base64')\n              } else {\n                resData = Buffer.from(rbody.body, 'utf8')\n              }\n            } catch (err) {\n              wasError = true\n            }\n\n            if (!wasError) {\n              responseHeaders = responseHeaders.replace(noGZ, '')\n              responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n            }\n            await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n          }\n        }\n      }\n    } else /* yes HTTP/2 */ {\n      if (res === null || res === undefined) {\n        // we do not have a response\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        if (!isEmptyPlainObject(nreq.headers)) {\n          // the headers object is present\n          head = nreq.headers\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        } else {\n          // the headers object is not present, recreate with minimal information\n          requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n        }\n\n        await this.writeRequestRecord(nreq.url, requestHeaders)\n        // console.log(requestHeaders)\n      } else {\n        if (res.protocol === 'data') {\n          return\n        }\n        if (res.requestHeadersText) {\n          // response has full request headers string\n          requestHeaders = res.requestHeadersText\n        } else if (!isEmptyPlainObject(res.requestHeaders)) {\n          // response did not have the full request headers string use object\n          requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n          head = res.requestHeaders\n          if (!(head.host || head.Host)) {\n            head['Host'] = purl.host\n          }\n          for (headerKey in head) {\n            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          requestHeaders += `${CRLF}`\n        } else {\n          // response has no full request http headers information\n          requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n          if (!isEmptyPlainObject(nreq.headers)) {\n            // the request object has the request http header object\n            head = nreq.headers\n            if (!(head.host || head.Host)) {\n              head['Host'] = purl.host\n            }\n            for (headerKey in head) {\n              requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n            }\n            requestHeaders += `${CRLF}`\n          } else {\n            // the request object does not have the request http header information\n            // recreate with minimal information\n            requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n          }\n        }\n\n        await this.writeRequestRecord(nreq.url, requestHeaders)\n\n        if (res.headersText) {\n          responseHeaders = res.headersText\n        } else if (!isEmptyPlainObject(res.headers)) {\n          head = res.headers\n          responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n          for (headerKey in head) {\n            responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n          }\n          responseHeaders += `${CRLF}`\n        } else {\n          responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        }\n\n        let resData\n        let wasError = false\n        try {\n          let rbody = await network.getResponseBody({requestId: nreq.requestId})\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n        }\n        await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n\n        if (wasResArray && nreq.res.length > 0) {\n          let i = 0\n          let len = nreq.res.length\n          for (; i < len; ++i) {\n            res = nreq.res[i]\n            if (res.headersText) {\n              responseHeaders = res.headersText\n            } else if (!isEmptyPlainObject(res.headers)) {\n              head = res.headers\n              responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n              for (headerKey in head) {\n                responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n              }\n              responseHeaders += `${CRLF}`\n            } else {\n              continue\n            }\n            let resData\n            let wasError = false\n            try {\n              let rbody = await network.getResponseBody({requestId: nreq.requestId})\n              if (rbody.base64Encoded) {\n                resData = Buffer.from(rbody.body, 'base64')\n              } else {\n                resData = Buffer.from(rbody.body, 'utf8')\n              }\n            } catch (err) {\n              wasError = true\n            }\n\n            if (!wasError) {\n              responseHeaders = responseHeaders.replace(noGZ, '')\n              responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n            }\n            await this.writeResponseRecord(nreq.url, responseHeaders, resData)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @desc Generates The Request Response WARC Records for OPTIONS\n   * @param {Object} nreq the captured HTTP request/response for the OPTIONS request\n   * @param {Object} network the chrome-remote-interface Network object\n   * @return {Promise.<void>}\n   */\n  async generateOptions (nreq, network) {\n    let res\n    let requestHeaders\n    let responseHeaders\n    let purl = URL.parse(nreq.url)\n    let headerKey\n    let head\n\n    if (Array.isArray(nreq.res)) {\n      res = nreq.res.shift()\n    } else {\n      res = nreq.res\n    }\n\n    if (this._noHTTP2) {\n      if (!isEmptyPlainObject(res.requestHeaders)) {\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = res.requestHeaders\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n      } else if (!isEmptyPlainObject(nreq.headers)) {\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = nreq.headers\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        return\n      }\n      await this.writeRequestRecord(nreq.url, requestHeaders)\n\n      if (!isEmptyPlainObject(res.headers)) {\n        head = res.headers\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n      } else {\n        return\n      }\n      await this.writeResponseRecord(nreq.url, responseHeaders)\n    } else /* yes HTTP2 */ {\n      if (res.requestHeadersText) {\n        requestHeaders = res.requestHeadersText\n      } else if (!isEmptyPlainObject(res.requestHeaders)) {\n        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n        head = res.requestHeaders\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n      } else if (!isEmptyPlainObject(nreq.headers)) {\n        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n        head = nreq.headers\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        return\n      }\n      await this.writeRequestRecord(nreq.url, requestHeaders)\n\n      if (res.headersText) {\n        responseHeaders = res.headersText\n      } else if (!isEmptyPlainObject(res.headers)) {\n        head = res.headers\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n      } else {\n        return\n      }\n      await this.writeResponseRecord(nreq.url, responseHeaders)\n    }\n  }\n\n  /**\n   * @desc Handle Non HTTP POST GET OPTIONS request. And yes the live web uses them all\n   * @param {Object} nreq the captured HTTP request/response\n   * @param {Object} network the chrome-remote-interface Network object\n   * @return {Promise.<void>}\n   */\n  async generateOther (nreq, network) {\n    // ducktape\n    if (!nreq.postData) {\n      await this.generateGet(nreq, network)\n    } else {\n      await this.generatePost(nreq, network)\n    }\n  }\n\n  /**\n   * @desc If a stray response comes in without a request HTTP/2 likely preserve it!\n   * @param {Object} nreq the captured HTTP response\n   * @param {Object} network the chrome-remote-interface Network object\n   * @return {Promise.<void>}\n   */\n  async generateOnlyRes (nreq, network) {\n    let res = nreq.res\n    let requestHeaders\n    let responseHeaders\n    let purl = URL.parse(res.url)\n    let headerKey\n    let head\n    res.protocol = res.protocol || 'http/1.1'\n    if (res.protocol === 'data') {\n      return\n    }\n\n    if (res.requestHeadersText) {\n      nreq.method = res.requestHeadersText.substring(0, res.requestHeadersText.indexOf(' '))\n    } else {\n      // we handle htt2 :method\n      return\n    }\n\n    if (this._noHTTP2) {\n      if (!isEmptyPlainObject(res.requestHeaders)) {\n        // response did not have the full request headers string use object\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        head = res.requestHeaders\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        // response has no full request http headers information\n        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`\n        // the request object does not have the request http header information\n        // recreate with minimal information\n        requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n      }\n\n      await this.writeRequestRecord(res.url, requestHeaders)\n\n      if (!isEmptyPlainObject(res.headers)) {\n        head = res.headers\n        responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n      } else {\n        return\n      }\n\n      let resData\n      let wasError = false\n      try {\n        let rbody = await network.getResponseBody({requestId: nreq.requestId})\n        if (rbody.base64Encoded) {\n          resData = Buffer.from(rbody.body, 'base64')\n        } else {\n          resData = Buffer.from(rbody.body, 'utf8')\n        }\n      } catch (err) {\n        wasError = true\n      }\n\n      if (!wasError) {\n        responseHeaders = responseHeaders.replace(noGZ, '')\n        responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n      }\n      await this.writeResponseRecord(res.url, responseHeaders, resData)\n    } else /* yes HTTP/2 */ {\n      if (res.requestHeadersText) {\n        // response has full request headers string\n        requestHeaders = res.requestHeadersText\n      } else if (!isEmptyPlainObject(res.requestHeaders)) {\n        // response did not have the full request headers string use object\n        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n        head = res.requestHeaders\n        if (!(head.host || head.Host)) {\n          head['Host'] = purl.host\n        }\n        for (headerKey in head) {\n          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        requestHeaders += `${CRLF}`\n      } else {\n        // response has no full request http headers information\n        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`\n        // the request object does not have the request http header information\n        // recreate with minimal information\n        requestHeaders += `Host: ${purl.host}\\r\\nUser-Agent: ${UA}${CRLF}`\n      }\n\n      await this.writeRequestRecord(res.url, requestHeaders)\n\n      if (res.headersText) {\n        responseHeaders = res.headersText\n      } else if (!isEmptyPlainObject(res.headers)) {\n        head = res.headers\n        responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`\n        for (headerKey in head) {\n          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`\n        }\n        responseHeaders += `${CRLF}`\n      } else {\n        return\n      }\n\n      let resData\n      let wasError = false\n      try {\n        let rbody = await network.getResponseBody({requestId: nreq.requestId})\n        if (rbody.base64Encoded) {\n          resData = Buffer.from(rbody.body, 'base64')\n        } else {\n          resData = Buffer.from(rbody.body, 'utf8')\n        }\n      } catch (err) {\n        wasError = true\n      }\n\n      if (!wasError) {\n        responseHeaders = responseHeaders.replace(noGZ, '')\n        responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`)\n      }\n      await this.writeResponseRecord(res.url, responseHeaders, resData)\n    }\n  }\n}\n\nmodule.exports = RemoteChromeWARCGenerator\n",
    "static": true,
    "longname": "lib/writers/remoteChrome.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 295,
    "kind": "variable",
    "name": "URL",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~URL",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "variable",
    "name": "STATUS_CODES",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~STATUS_CODES",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "variable",
    "name": "isEmptyPlainObject",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~isEmptyPlainObject",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 298,
    "kind": "variable",
    "name": "WARCWriterBase",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~WARCWriterBase",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "variable",
    "name": "CRLF",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~CRLF",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "variable",
    "name": "noGZ",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~noGZ",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "ignore": true,
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "variable",
    "name": "replaceContentLen",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~replaceContentLen",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "ignore": true,
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "variable",
    "name": "UA",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~UA",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "ignore": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 303,
    "kind": "class",
    "name": "RemoteChromeWARCGenerator",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": null,
    "description": "WARC Generator for use with chrome-remote-interface\n\nExpects request data from {@link RemoteChromeRequestCapturer}",
    "see": [
      "https://github.com/cyrus-and/chrome-remote-interface"
    ],
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@link",
        "tagValue": "WARCWriterBase"
      }
    ],
    "interface": false,
    "extends": [
      "WARCWriterBase"
    ]
  },
  {
    "__docId__": 304,
    "kind": "method",
    "name": "generatePost",
    "memberof": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator#generatePost",
    "access": null,
    "description": "Generates The Request Response WARC Records for POST",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response for the POST request"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "the chrome-remote-interface Network object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "generateRedirectResponse",
    "memberof": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator#generateRedirectResponse",
    "access": null,
    "description": "Special Case Handler To Correctly Serialize 3xx Responses.\n\nThe browser will automatically chase down 3xx responses until terminal\nstatus is reached 2xx, 4xx, 5xx. So we must account for that fact and the\nredirectResponse is guarantied to be an array or plain object.",
    "lineNumber": 204,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response for the redirected request"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "the chrome-remote-interface Network object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "generateGet",
    "memberof": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator#generateGet",
    "access": null,
    "description": "Generates The Request Response WARC Records for GET",
    "lineNumber": 673,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response for the GET request"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "the chrome-remote-interface Network object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "generateOptions",
    "memberof": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator#generateOptions",
    "access": null,
    "description": "Generates The Request Response WARC Records for OPTIONS",
    "lineNumber": 951,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response for the OPTIONS request"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "the chrome-remote-interface Network object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "generateOther",
    "memberof": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator#generateOther",
    "access": null,
    "description": "Handle Non HTTP POST GET OPTIONS request. And yes the live web uses them all",
    "lineNumber": 1056,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP request/response"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "the chrome-remote-interface Network object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "generateOnlyRes",
    "memberof": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator#generateOnlyRes",
    "access": null,
    "description": "If a stray response comes in without a request HTTP/2 likely preserve it!",
    "lineNumber": 1071,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "the captured HTTP response"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "the chrome-remote-interface Network object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 310,
    "kind": "file",
    "name": "lib/writers/warcFields.js",
    "content": "const warcHeader =\n  'WARC/1.0\\r\\n' +\n  'WARC-Type: warcinfo\\r\\n' +\n  'WARC-Date: {{now}}\\r\\n' +\n  'WARC-Filename: {{fileName}}\\r\\n' +\n  'WARC-Record-ID: <urn:uuid:{{rid}}>\\r\\n' +\n  'Content-Type: application/warc-fields\\r\\n' +\n  'Content-Length: {{len}}\\r\\n'\n\nconst warcHeaderContent =\n  'software: node-warc/{{version}}\\r\\n' +\n  'format: WARC File Format 1.0\\r\\n' +\n  'conformsTo: http://bibnum.bnf.fr/WARC/WARC_ISO_28500_version1_latestdraft.pdf\\r\\n' +\n  'isPartOf: {{isPartOfV}}\\r\\n' +\n  'description: {{warcInfoDescription}}\\r\\n' +\n  'robots: ignore\\r\\n' +\n  'http-header-user-agent: {{ua}}\\r\\n'\n\nconst warcMetadataHeader =\n  'WARC/1.0\\r\\n' +\n  'WARC-Type: metadata\\r\\n' +\n  'WARC-Target-URI: {{targetURI}}\\r\\n' +\n  'WARC-Date: {{now}}\\r\\n' +\n  'WARC-Concurrent-To: <urn:uuid:{{concurrentTo}}>\\r\\n' +\n  'WARC-Record-ID: <urn:uuid:{{rid}}>\\r\\n' +\n  'Content-Type: application/warc-fields\\r\\n' +\n  'Content-Length: {{len}}\\r\\n'\n\nconst warcRequestHeader =\n  'WARC/1.0\\r\\n' +\n  'WARC-Type: request\\r\\n' +\n  'WARC-Target-URI: {{targetURI}}\\r\\n' +\n  'WARC-Date: {{now}}\\r\\n' +\n  'WARC-Concurrent-To: <urn:uuid:{{concurrentTo}}>\\r\\n' +\n  'WARC-Record-ID: <urn:uuid:{{rid}}>\\r\\n' +\n  'Content-Type: application/http; msgtype=request\\r\\n' +\n  'Content-Length: {{len}}\\r\\n'\n\nconst warcResponseHeader =\n  'WARC/1.0\\r\\n' +\n  'WARC-Type: response\\r\\n' +\n  'WARC-Target-URI: {{targetURI}}\\r\\n' +\n  'WARC-Date: {{now}}\\r\\n' +\n  'WARC-Record-ID: <urn:uuid:{{rid}}>\\r\\n' +\n  'Content-Type: application/http; msgtype=response\\r\\n' +\n  'Content-Length: {{len}}\\r\\n'\n\nconst CRLF = '\\r\\n'\nconst recordSeparator = `${CRLF}${CRLF}`\n\nconst warcFields = {\n  warcHeader,\n  warcHeaderContent,\n  warcRequestHeader,\n  warcResponseHeader,\n  warcMetadataHeader,\n  recordSeparator,\n  CRLF\n}\n\nmodule.exports = warcFields\n",
    "static": true,
    "longname": "lib/writers/warcFields.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 311,
    "kind": "variable",
    "name": "warcHeader",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~warcHeader",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "variable",
    "name": "warcHeaderContent",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~warcHeaderContent",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "variable",
    "name": "warcMetadataHeader",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~warcMetadataHeader",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "variable",
    "name": "warcRequestHeader",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~warcRequestHeader",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "variable",
    "name": "warcResponseHeader",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~warcResponseHeader",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "variable",
    "name": "CRLF",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~CRLF",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "variable",
    "name": "recordSeparator",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~recordSeparator",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "variable",
    "name": "warcFields",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~warcFields",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"warcHeader\": *, \"warcHeaderContent\": *, \"warcRequestHeader\": *, \"warcResponseHeader\": *, \"warcMetadataHeader\": *, \"recordSeparator\": *, \"CRLF\": *}"
      ]
    }
  },
  {
    "__docId__": 319,
    "kind": "file",
    "name": "lib/writers/warcWriterBase.js",
    "content": "/** @ignore */\nconst fs = require('fs-extra')\n/** @ignore */\nconst Promise = require('bluebird')\n/** @ignore */\nconst Path = require('path')\n/** @ignore */\nconst uuid = require('uuid/v1')\n/** @ignore */\nconst S = require('string')\nconst EventEmitter = require('eventemitter3')\nconst {\n  warcHeader,\n  warcHeaderContent,\n  warcRequestHeader,\n  warcResponseHeader,\n  warcMetadataHeader,\n  recordSeparator,\n  CRLF\n} = require('./warcFields')\n\n/**\n * The base class of {@link ElectronWARCGenerator} and {@link RemoteChromeWARCGenerator}\n */\nclass WARCWriterBase extends EventEmitter {\n  /**\n   * @desc Create a new WARCWriter\n   * @param {boolean} [noHTTP2=false] noHTTP2 - The web uses HTTP/2 but\n   * all known replay systems can only replay HTTP <= 1.1. But if you turn HTTP/2 into\n   * HTTP/1.1 it will replay for the most part. True means modify the HTTP headers False means\n   * leave the HTTP headers as they occurred\n   */\n  constructor (noHTTP2 = false) {\n    super()\n    this._warcOutStream = null\n    this._lastError = null\n    this._swapper = S('')\n    this._rid = null\n    this._now = null\n    this._fileName = null\n    this._noHTTP2 = noHTTP2\n    this._version = '1.1.1'\n    this._onFinish = this._onFinish.bind(this)\n    this._onError = this._onError.bind(this)\n  }\n\n  /**\n   * @desc Enable modification of HTTP/2 headers into HTTP/1.1\n   */\n  turnHTTP2IntoHTTP11 () {\n    this._noHTTP2 = true\n  }\n\n  /**\n   * @desc Disable modification of HTTP/2 headers into HTTP/1.1\n   */\n  keepHTTP2 () {\n    this._noHTTP2 = false\n  }\n\n  /**\n   * @desc Initialize the writer\n   * @param {string} warcPath - the path for the WARC file to be written\n   * @param {boolean} [appending=false] appending - append to a previously created WARC file\n   */\n  initWARC (warcPath, appending = false) {\n    if (appending) {\n      this._warcOutStream = fs.createWriteStream(warcPath, {flags: 'a'})\n    } else {\n      this._warcOutStream = fs.createWriteStream(warcPath)\n    }\n    this._warcOutStream.on('finish', this._onFinish)\n    this._warcOutStream.on('error', this._onError)\n    let now = new Date().toISOString()\n    this._now = now.substr(0, now.indexOf('.')) + 'Z'\n    this._rid = uuid()\n    this._fileName = Path.basename(warcPath)\n  }\n\n  /**\n   * @desc Write out the WARC-Type: info records\n   * @param {string} isPartOfV\n   * @param {string} warcInfoDescription\n   * @param {string} ua user agent\n   * @return {Promise.<void>}\n   */\n  writeWarcInfoRecord (isPartOfV, warcInfoDescription, ua) {\n    this._swapper.setValue(warcHeaderContent)\n    let whct = this._swapper.template({version: this._version, isPartOfV, warcInfoDescription, ua}).s\n    let whc = Buffer.from(`${CRLF}${whct}${CRLF}`, 'utf8')\n    let wh = Buffer.from(this._swapper.setValue(warcHeader).template({\n      fileName: this._fileName,\n      now: this._now,\n      len: whc.length,\n      rid: this._rid\n    }).s, 'utf8')\n    return this.writeRecordBlock(wh, whc, recordSeparator)\n  }\n\n  /**\n   * @desc Write WARC-Type: metadata for outlinks\n   * @param {string} targetURI\n   * @param {string} outlinks\n   * @return {Promise.<void>}\n   */\n  writeWarcMetadataOutlinks (targetURI, outlinks) {\n    let wmhc = Buffer.from(`${CRLF}${outlinks}${CRLF}`, 'utf8')\n    let wmh = Buffer.from(this._swapper.setValue(warcMetadataHeader).template({\n      targetURI,\n      now: this._now,\n      len: wmhc.length,\n      concurrentTo: this._rid,\n      rid: uuid()\n    }).s, 'utf8')\n    return this.writeRecordBlock(wmh, wmhc, recordSeparator)\n  }\n\n  /**\n   * @desc Write A Request Record\n   * @param {string} targetURI\n   * @param {string} httpHeaderString\n   * @param {string|Buffer?} requestData\n   * @return {Promise.<void>}\n   */\n  writeRequestRecord (targetURI, httpHeaderString, requestData) {\n    this._swapper.setValue(warcRequestHeader)\n    let reqHeadContentBuffer\n    if (requestData !== null && requestData !== undefined) {\n      reqHeadContentBuffer = Buffer.from(`${CRLF}${httpHeaderString}${requestData}${CRLF}`, 'utf8')\n    } else {\n      reqHeadContentBuffer = Buffer.from(`${CRLF}${httpHeaderString}`, 'utf8')\n    }\n    let reqWHeader = this._swapper.template({\n      targetURI,\n      concurrentTo: this._rid,\n      now: this._now,\n      rid: uuid(),\n      len: reqHeadContentBuffer.length\n    }).s\n    return this.writeRecordBlock(reqWHeader, reqHeadContentBuffer, recordSeparator)\n  }\n\n  /**\n   * @desc Write A Response Record\n   * @param {string} targetURI\n   * @param {string} httpHeaderString\n   * @param {string|Buffer?} responseData\n   * @return {Promise.<void>}\n   */\n  writeResponseRecord (targetURI, httpHeaderString, responseData) {\n    this._swapper.setValue(warcRequestHeader)\n    let resHeaderContentBuffer = Buffer.from(`${CRLF}${httpHeaderString}`, 'utf8')\n    let resDataLen = responseData ? responseData.length : 0\n    let respWHeader = this._swapper.setValue(warcResponseHeader).template({\n      targetURI,\n      now: this._now,\n      rid: uuid(),\n      len: resHeaderContentBuffer.length + resDataLen\n    }).s\n    if (responseData !== null && responseData !== undefined) {\n      return this.writeRecordBlock(respWHeader, resHeaderContentBuffer, responseData, CRLF, recordSeparator)\n    } else {\n      return this.writeRecordBlock(respWHeader, resHeaderContentBuffer, CRLF, recordSeparator)\n    }\n  }\n\n  /**\n   * @desc Write arbitrary number of items to the WARC\n   * @param {*} recordParts\n   * @return {Promise.<void>}\n   */\n  writeRecordBlock (...recordParts) {\n    return new Promise((resolve, reject) => {\n      let dataIter = recordParts[Symbol.iterator]()\n      this._doWrite(dataIter, resolve, reject)\n    })\n  }\n\n  /**\n   * @desc Close the underlying filestream to the WARC currently being written.\n   * The `finished` event will not be emitted until this method has been called\n   */\n  end () {\n    if (this._warcOutStream) {\n      this._warcOutStream.end()\n    }\n  }\n\n  /**\n   *\n   * @param {Symbol.iterator} dataIter\n   * @param resolve\n   * @param reject\n   * @private\n   */\n  _doWrite (dataIter, resolve, reject) {\n    let next = dataIter.next()\n    if (!next.done) {\n      this._warcOutStream.write(next.value, 'utf8', this._doWrite.bind(this, dataIter, resolve, reject))\n    } else {\n      resolve()\n    }\n  }\n\n  /**\n   * @desc Called when the WARC generation is finished\n   * @emits {finished} emitted when WARC generation is complete\n   * @private\n   */\n  _onFinish () {\n    let le = this._lastError\n    this._lastError = null\n    this._warcOutStream.destroy()\n    this._warcOutStream = null\n    this._rid = null\n    this._now = null\n    this._fileName = null\n    if (le) {\n      this.emit('finished', le)\n    } else {\n      this.emit('finished')\n    }\n  }\n\n  /**\n   * @desc Emits an error if one occurs\n   * @emits {error} The error that occurred\n   * @private\n   */\n  _onError (err) {\n    this._lastError = err\n    this.emit('error', err)\n  }\n}\n\nmodule.exports = WARCWriterBase\n",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 320,
    "kind": "variable",
    "name": "fs",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~fs",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "variable",
    "name": "Promise",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~Promise",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "variable",
    "name": "Path",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~Path",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "variable",
    "name": "uuid",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~uuid",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "variable",
    "name": "S",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~S",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "variable",
    "name": "EventEmitter",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~EventEmitter",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "variable",
    "name": "warcHeader",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~warcHeader",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "class",
    "name": "WARCWriterBase",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "access": null,
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": "The base class of {@link ElectronWARCGenerator} and {@link RemoteChromeWARCGenerator}",
    "lineNumber": 25,
    "interface": false,
    "extends": [
      "EventEmitter"
    ]
  },
  {
    "__docId__": 328,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#constructor",
    "access": null,
    "description": "Create a new WARCWriter",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "noHTTP2",
        "description": "noHTTP2 - The web uses HTTP/2 but\nall known replay systems can only replay HTTP <= 1.1. But if you turn HTTP/2 into\nHTTP/1.1 it will replay for the most part. True means modify the HTTP headers False means\nleave the HTTP headers as they occurred"
      }
    ]
  },
  {
    "__docId__": 329,
    "kind": "member",
    "name": "_warcOutStream",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_warcOutStream",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "member",
    "name": "_lastError",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_lastError",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "member",
    "name": "_swapper",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_swapper",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "member",
    "name": "_rid",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_rid",
    "access": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "member",
    "name": "_now",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_now",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "member",
    "name": "_fileName",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_fileName",
    "access": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 335,
    "kind": "member",
    "name": "_noHTTP2",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_noHTTP2",
    "access": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 336,
    "kind": "member",
    "name": "_version",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_version",
    "access": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 337,
    "kind": "member",
    "name": "_onFinish",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_onFinish",
    "access": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 338,
    "kind": "member",
    "name": "_onError",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_onError",
    "access": null,
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "method",
    "name": "turnHTTP2IntoHTTP11",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#turnHTTP2IntoHTTP11",
    "access": null,
    "description": "Enable modification of HTTP/2 headers into HTTP/1.1",
    "lineNumber": 50,
    "params": []
  },
  {
    "__docId__": 340,
    "kind": "member",
    "name": "_noHTTP2",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_noHTTP2",
    "access": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 341,
    "kind": "method",
    "name": "keepHTTP2",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#keepHTTP2",
    "access": null,
    "description": "Disable modification of HTTP/2 headers into HTTP/1.1",
    "lineNumber": 57,
    "params": []
  },
  {
    "__docId__": 342,
    "kind": "member",
    "name": "_noHTTP2",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_noHTTP2",
    "access": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "initWARC",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#initWARC",
    "access": null,
    "description": "Initialize the writer",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "warcPath",
        "description": "the path for the WARC file to be written"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "appending",
        "description": "appending - append to a previously created WARC file"
      }
    ]
  },
  {
    "__docId__": 344,
    "kind": "member",
    "name": "_warcOutStream",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_warcOutStream",
    "access": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "member",
    "name": "_warcOutStream",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_warcOutStream",
    "access": null,
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 346,
    "kind": "member",
    "name": "_now",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_now",
    "access": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "member",
    "name": "_rid",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_rid",
    "access": null,
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 348,
    "kind": "member",
    "name": "_fileName",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_fileName",
    "access": null,
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 349,
    "kind": "method",
    "name": "writeWarcInfoRecord",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeWarcInfoRecord",
    "access": null,
    "description": "Write out the WARC-Type: info records",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "isPartOfV",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "warcInfoDescription",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ua",
        "description": "user agent"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 350,
    "kind": "method",
    "name": "writeWarcMetadataOutlinks",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeWarcMetadataOutlinks",
    "access": null,
    "description": "Write WARC-Type: metadata for outlinks",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "outlinks",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "writeRequestRecord",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeRequestRecord",
    "access": null,
    "description": "Write A Request Record",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "httpHeaderString",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Buffer?"
        ],
        "spread": false,
        "optional": false,
        "name": "requestData",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 352,
    "kind": "method",
    "name": "writeResponseRecord",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeResponseRecord",
    "access": null,
    "description": "Write A Response Record",
    "lineNumber": 150,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "httpHeaderString",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Buffer?"
        ],
        "spread": false,
        "optional": false,
        "name": "responseData",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 353,
    "kind": "method",
    "name": "writeRecordBlock",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeRecordBlock",
    "access": null,
    "description": "Write arbitrary number of items to the WARC",
    "lineNumber": 172,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "recordParts",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 354,
    "kind": "method",
    "name": "end",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#end",
    "access": null,
    "description": "Close the underlying filestream to the WARC currently being written.\nThe `finished` event will not be emitted until this method has been called",
    "lineNumber": 183,
    "params": []
  },
  {
    "__docId__": 355,
    "kind": "method",
    "name": "_doWrite",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_doWrite",
    "access": "private",
    "description": "",
    "lineNumber": 196,
    "params": [
      {
        "nullable": null,
        "types": [
          "Symbol.iterator"
        ],
        "spread": false,
        "optional": false,
        "name": "dataIter",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "resolve",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "reject",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 356,
    "kind": "method",
    "name": "_onFinish",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_onFinish",
    "access": "private",
    "description": "Called when the WARC generation is finished",
    "lineNumber": 210,
    "params": [],
    "emits": [
      {
        "types": [
          "finished"
        ],
        "description": "emitted when WARC generation is complete"
      }
    ]
  },
  {
    "__docId__": 357,
    "kind": "member",
    "name": "_lastError",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_lastError",
    "access": null,
    "description": null,
    "lineNumber": 212,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 358,
    "kind": "member",
    "name": "_warcOutStream",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_warcOutStream",
    "access": null,
    "description": null,
    "lineNumber": 214,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 359,
    "kind": "member",
    "name": "_rid",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_rid",
    "access": null,
    "description": null,
    "lineNumber": 215,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 360,
    "kind": "member",
    "name": "_now",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_now",
    "access": null,
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "member",
    "name": "_fileName",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_fileName",
    "access": null,
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 362,
    "kind": "method",
    "name": "_onError",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_onError",
    "access": "private",
    "description": "Emits an error if one occurs",
    "lineNumber": 230,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      }
    ],
    "emits": [
      {
        "types": [
          "error"
        ],
        "description": "The error that occurred"
      }
    ]
  },
  {
    "__docId__": 363,
    "kind": "member",
    "name": "_lastError",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_lastError",
    "access": null,
    "description": null,
    "lineNumber": 231,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 365,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 366,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 367,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 368,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 369,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 370,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 371,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 372,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 373,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 374,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 375,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 376,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 377,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 378,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 379,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 380,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 381,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 382,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 383,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 384,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 385,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 386,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 387,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 388,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 389,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 390,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 391,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 392,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 393,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 394,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 395,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 396,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 397,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 398,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 399,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 400,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 401,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 402,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 403,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 404,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 405,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 406,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 407,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 408,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 409,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 410,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 411,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "lineNumber": 193,
    "builtinExternal": true
  },
  {
    "__docId__": 413,
    "kind": "external",
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 414,
    "kind": "external",
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 415,
    "kind": "external",
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 416,
    "kind": "external",
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 417,
    "kind": "external",
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 418,
    "kind": "external",
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 419,
    "kind": "external",
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 420,
    "kind": "external",
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "lineNumber": 34,
    "builtinExternal": true
  }
]