<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">lib/writers/remoteChrome.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="https://n0tan3rd.github.io/node-warc/">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/N0taN3rd/node-warc.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">parsers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/gzipDetector.js~GzipDetector.html">GzipDetector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/index.js~AutoWARCParser.html">AutoWARCParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/warcGzParser.js~WARCGzParser.html">WARCGzParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/warcParser.js~WARCParser.html">WARCParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-gzipMagicNum">gzipMagicNum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-gzipMagicNumLen">gzipMagicNumLen</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">requestCapturers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/requestCapturers/electron.js~ElectronRequestCapturer.html">ElectronRequestCapturer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer.html">RemoteChromeRequestCapturer</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/utils/electronGetResError.js~ElectronGetResError.html">ElectronGetResError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getResBodyElectron">getResBodyElectron</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isEmptyPlainObject">isEmptyPlainObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ElectronGetResError">ElectronGetResError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-isEmpty">isEmpty</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">warcRecordBuilder</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/warcRecordBuilder/index.js~WARCRecorderBuilder.html">WARCRecorderBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-buildKeys">buildKeys</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-fieldIdentifiers">fieldIdentifiers</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">warcRecords</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/warcRecords/index.js~WARCInfoRecord.html">WARCInfoRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/warcRecords/index.js~WARCMetaDataRecord.html">WARCMetaDataRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/warcRecords/index.js~WARCRequestRecord.html">WARCRequestRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/warcRecords/index.js~WARCResourceRecord.html">WARCResourceRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/warcRecords/index.js~WARCResponseRecord.html">WARCResponseRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/warcRecords/index.js~WARCRevisitRecord.html">WARCRevisitRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/warcRecords/index.js~WARCUnknownRecord.html">WARCUnknownRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseWarcInfoMetaDataContent">parseWarcInfoMetaDataContent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseWarcRecordHeader">parseWarcRecordHeader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-headerRe">headerRe</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-recIdRE">recIdRE</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">writers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/writers/electron.js~ElectronWARCGenerator.html">ElectronWARCGenerator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/writers/remoteChrome.js~RemoteChromeWARCGenerator.html">RemoteChromeWARCGenerator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/writers/warcWriterBase.js~WARCWriterBase.html">WARCWriterBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CRLF">CRLF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-WARCWriterBase">WARCWriterBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CRLF">CRLF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-WARCWriterBase">WARCWriterBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CRLF">CRLF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-recordSeparator">recordSeparator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-warcFields">warcFields</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-warcHeader">warcHeader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-warcHeaderContent">warcHeaderContent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-warcMetadataHeader">warcMetadataHeader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-warcRequestHeader">warcRequestHeader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-warcResponseHeader">warcResponseHeader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EventEmitter">EventEmitter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-warcHeader">warcHeader</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/writers/remoteChrome.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/** @ignore */
const URL = require(&apos;url&apos;)
/** @ignore */
const {STATUS_CODES} = require(&apos;http&apos;)
/** @ignore */
const isEmptyPlainObject = require(&apos;../utils/isEmptyPlainObject&apos;)
const WARCWriterBase = require(&apos;./warcWriterBase&apos;)
const {CRLF} = require(&apos;./warcFields&apos;)

/** @ignore */
const noGZ = /Content-Encoding.*gzip\r\n/gi
/** @ignore */
const replaceContentLen = /Content-Length:.*\r\n/gi
/** @ignore */
const UA = &apos;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.71 Safari/537.36&apos;

/**
 * @desc WARC Generator for use with chrome-remote-interface
 *
 * Expects request data from {@link RemoteChromeRequestCapturer}
 * @see https://github.com/cyrus-and/chrome-remote-interface
 * @link WARCWriterBase
 */
class RemoteChromeWARCGenerator extends WARCWriterBase {
  /**
   * @desc Generates The Request Response WARC Records for POST
   * @param {Object} nreq the captured HTTP request/response for the POST request
   * @param {Object} network the chrome-remote-interface Network object
   * @return {Promise.&lt;void&gt;}
   */
  async generatePost (nreq, network) {
    let res
    let requestHeaders
    let responseHeaders
    let purl
    let headerKey
    let head
    res = nreq.res
    if (!res) {
      // request
      purl = URL.parse(nreq.url)
      if (!(nreq.headers.host || nreq.headers.Host)) {
        nreq.headers[&apos;Host&apos;] = purl.host
      }
      requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
      head = nreq.headers
      for (headerKey in head) {
        requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
      }
      requestHeaders += `${CRLF}`
      if (nreq.postData) {
        await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)
      } else {
        await this.writeRequestRecord(nreq.url, requestHeaders)
      }
    } else {
      // request
      if (res.requestHeadersText) {
        requestHeaders = res.requestHeadersText
      } else {
        purl = URL.parse(nreq.url)
        if (!(nreq.headers.host || nreq.headers.Host)) {
          nreq.headers[&apos;Host&apos;] = purl.host
        }
        if (this._noHTTP2) {
          requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
        } else {
          requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`
        }

        head = nreq.headers
        for (headerKey in head) {
          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        requestHeaders += `${CRLF}`
      }
      // console.log(requestHeaders)

      if (nreq.postData) {
        await this.writeRequestRecord(nreq.url, requestHeaders, nreq.postData)
      } else {
        await this.writeRequestRecord(nreq.url, requestHeaders)
      }

      // response
      if (res.headersText) {
        responseHeaders = res.headersText
      } else {
        if (this._noHTTP2) {
          responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
        } else {
          responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
        }
        head = res.headers
        for (headerKey in head) {
          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        responseHeaders += `${CRLF}`
      }

      // console.log(responseHeaders)
      // if their is no response body these values are undefined
      // do not request body if there is none or zero length body
      let resData
      let wasError = false
      try {
        let rbody = await network.getResponseBody({requestId: nreq.requestId})
        if (rbody.base64Encoded) {
          resData = Buffer.from(rbody.body, &apos;base64&apos;)
        } else {
          resData = Buffer.from(rbody.body, &apos;utf8&apos;)
        }
      } catch (err) {
        wasError = true
      }
      if (!wasError) {
        responseHeaders = responseHeaders.replace(noGZ, &apos;&apos;)
        responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, &apos;utf8&apos;)}${CRLF}`)
      }
      // console.log(responseHeaders)
      // console.log(responseHeaders)
      await this.writeResponseRecord(nreq.url, responseHeaders, resData)
    }
  }

  /**
   * @desc Special Case Handler To Correctly Serialize 3xx Responses.
   *
   * The browser will automatically chase down 3xx responses until terminal
   * status is reached 2xx, 4xx, 5xx. So we must account for that fact and the
   * redirectResponse is guarantied to be an array or plain object.
   * @param {Object} nreq the captured HTTP request/response for the redirected request
   * @param {Object} network the chrome-remote-interface Network object
   * @return {Promise.&lt;void&gt;}
   */
  async generateRedirectResponse (nreq, network) {
    // optimization for function speed by pulling up let decelerations
    let purl // a parsed URL
    let rderHeaders // a redirection responses HTTP headers string
    let redirReses // an array of redirection responses
    let head // a header object
    let i // the one and only i
    let aRedirect // a redirection response
    let redirectLen
    let requestHeaders // the HTTP headers string for the initial request that redirected
    let res // the response object
    let headerKey
    let finalRequestHeaders
    let finalResponseHeaders
    let isMultiRedirect = Array.isArray(nreq.redirectResponse)

    /* The initial request */
    if (isMultiRedirect) {
      // multi redirection
      // the full request headers is on the first redirect
      if (nreq.redirectResponse[0].requestHeadersText) {
        requestHeaders = nreq.redirectResponse[0].requestHeadersText
      } else {
        // the full request headers was not on the first redirect
        // must create it with the bare minimum info required
        // emulates the dev tools and is what was actually sent
        head = nreq.headers
        purl = URL.parse(nreq.url)
        if (!(head.host || head.Host)) {
          head[&apos;Host&apos;] = purl.host
        }
        if (this._noHTTP2) {
          requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
        } else {
          requestHeaders = `${nreq.method} ${purl.path} ${nreq.redirectResponse[0].protocol.toUpperCase()}${CRLF}`
        }
        // no need for hasOwnProperty, https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Headers
        // states headers is a json object
        for (headerKey in head) {
          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        requestHeaders += `${CRLF}`
      }
    } else {
      // single redirection
      if (nreq.redirectResponse.requestHeadersText) {
        // the full request headers is on the redirect response
        requestHeaders = nreq.redirectResponse.requestHeadersText
      } else {
        // the full request headers was not on the redirect
        // must create it with the bare minimum info required
        // emulates the dev tools and is what was actually sent
        head = nreq.headers
        purl = URL.parse(nreq.url)
        if (!(head.host || head.Host)) {
          head[&apos;Host&apos;] = purl.host
        }
        requestHeaders = `${nreq.method} ${purl.path} ${nreq.redirectResponse.protocol.toUpperCase()}${CRLF}`
        for (headerKey in head) {
          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        requestHeaders += `${CRLF}`
      }
    }

    await this.writeRequestRecord(nreq.url, requestHeaders)

    /* the redirection or redirection chain */
    if (isMultiRedirect) {
      // multi redirection
      // We handled the request for the first redirect, now for its response
      if (nreq.redirectResponse[0].headersText) {
        // console.log(nreq.redirectResponse[0].headersText)
        rderHeaders = nreq.redirectResponse[0].headersText
      } else {
        head = nreq.redirectResponse[0].headers
        aRedirect = nreq.redirectResponse[0]
        if (this._noHTTP2) {
          rderHeaders = `HTTP/1.1 ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`
        } else {
          rderHeaders = `${aRedirect.protocol.toUpperCase()} ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`
        }
        for (headerKey in head) {
          rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        rderHeaders += `${CRLF}`
      }
      await this.writeResponseRecord(nreq.url, rderHeaders)
      // now loop through the remaining redirection chain
      redirectLen = nreq.redirectResponse.length
      redirReses = nreq.redirectResponse
      i = 1
      for (; i &lt; redirectLen; ++i) {
        aRedirect = redirReses[i]
        if (aRedirect.requestHeadersText) {
          requestHeaders = aRedirect.requestHeadersText
        } else {
          // the full request headers was not on the redirect
          // must create it with the bare minimum info required
          // emulates the dev tools and is what was actually sent
          head = aRedirect.headers
          purl = URL.parse(aRedirect.url)
          if (!(head.host || head.Host)) {
            head[&apos;Host&apos;] = purl.host
          }
          if (this._noHTTP2) {
            requestHeaders = `HTTP/1.1 ${purl.path} ${aRedirect.protocol.toUpperCase()}${CRLF}`
          } else {
            requestHeaders = `${nreq.method} ${purl.path} ${aRedirect.protocol.toUpperCase()}${CRLF}`
          }
          for (headerKey in head) {
            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
          }
          requestHeaders += `${CRLF}`
        }
        await this.writeRequestRecord(aRedirect.url, requestHeaders)
        if (aRedirect.headersText) {
          rderHeaders = aRedirect.headersText
        } else {
          if (this._noHTTP2) {
            rderHeaders = `HTTP/1.1 ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`
          } else {
            rderHeaders = `${aRedirect.protocol.toUpperCase()} ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`
          }
          head = aRedirect.headers
          for (headerKey in head) {
            rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
          }
          rderHeaders += `${CRLF}`
        }
        // console.log(rderHeaders)
        rderHeaders = rderHeaders.replace(noGZ, &apos;&apos;)
        // console.log(rderHeaders)
        await this.writeResponseRecord(aRedirect.url, rderHeaders)
      }
    } else {
      // single redirection
      // We handled the request for the redirect, now for its response
      if (nreq.redirectResponse.headersText) {
        rderHeaders = nreq.redirectResponse.headersText
      } else {
        aRedirect = nreq.redirectResponse
        if (this._noHTTP2) {
          rderHeaders = `HTTP/1.1 ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`
        } else {
          rderHeaders = `${aRedirect.protocol.toUpperCase()} ${aRedirect.status} ${aRedirect.statusText || STATUS_CODES[aRedirect.status]}${CRLF}`
        }
        head = aRedirect.headers
        for (headerKey in head) {
          rderHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        rderHeaders += `${CRLF}`
      }
      // console.log(rderHeaders)
      rderHeaders = rderHeaders.replace(noGZ, &apos;&apos;)
      // console.log(rderHeaders)
      await this.writeResponseRecord(nreq.url, rderHeaders)
    }

    /* the final response (maybe has body) */
    if (nreq.res) {
      let isArray = Array.isArray(nreq.res)
      res = nreq.res
      if (isArray) {
        res = res.shift()
      }
      // request for the final response in redirection / redirection chain
      if (res.requestHeadersText) {
        finalRequestHeaders = res.requestHeadersText
      } else {
        head = res.requestHeaders || nreq.headers
        purl = URL.parse(res.url)

        if (!(head.host || head.Host)) {
          head[&apos;Host&apos;] = purl.host
        }
        if (this._noHTTP2) {
          finalRequestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
        } else {
          finalRequestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`
        }
        for (headerKey in head) {
          finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        finalRequestHeaders += `${CRLF}`
      }

      await this.writeRequestRecord(res.url, finalRequestHeaders)

      // response for the final request in redirection / redirection chain
      if (res.headersText) {
        finalResponseHeaders = res.headersText
      } else {
        head = res.headers
        if (this._noHTTP2) {
          finalResponseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
        } else {
          finalResponseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
        }
        for (headerKey in head) {
          finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        finalResponseHeaders += `${CRLF}`
      }

      // if their is no response body these values are undefined
      // do not request body if there is none or zero length body
      let resData
      let wasError = false
      try {
        let rbody = await network.getResponseBody({requestId: nreq.requestId})
        if (rbody.base64Encoded) {
          resData = Buffer.from(rbody.body, &apos;base64&apos;)
        } else {
          resData = Buffer.from(rbody.body, &apos;utf8&apos;)
        }
      } catch (err) {
        wasError = true
      }
      // console.log(finalResponseHeaders)
      if (!wasError) {
        finalResponseHeaders = finalResponseHeaders.replace(noGZ, &apos;&apos;)
        finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, &apos;utf8&apos;)}${CRLF}`)
      }
      // console.log(finalResponseHeaders)
      await this.writeResponseRecord(res.url, finalResponseHeaders, resData)
      if (isArray &amp;&amp; nreq.res.length &gt; 0) {
        let i = 0
        let len = nreq.res.length
        let anotherRes
        for (; i &lt; len; ++i) {
          anotherRes = nreq.res[i]
          if (anotherRes.url !== res.url ||
            anotherRes.requestHeadersText !== res.requestHeadersText
          ) {
            if (anotherRes.requestHeadersText) {
              finalRequestHeaders = anotherRes.requestHeadersText
            } else {
              head = anotherRes.requestHeaders || nreq.headers
              purl = URL.parse(anotherRes.url)

              if (!(head.host || head.Host)) {
                head[&apos;Host&apos;] = purl.host
              }
              if (this._noHTTP2) {
                finalRequestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
              } else {
                finalRequestHeaders = `${nreq.method} ${purl.path} ${anotherRes.protocol.toUpperCase()}${CRLF}`
              }
              for (headerKey in head) {
                finalRequestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
              }
              finalRequestHeaders += `${CRLF}`
            }

            await this.writeRequestRecord(anotherRes.url, finalRequestHeaders)

            // anotherResponse for the final request in redirection / redirection chain
            if (anotherRes.headersText) {
              finalResponseHeaders = anotherRes.headersText
            } else {
              head = anotherRes.headers
              if (this._noHTTP2) {
                finalResponseHeaders = `HTTP/1.1 ${anotherRes.status} ${anotherRes.statusText || STATUS_CODES[anotherRes.status]}${CRLF}`
              } else {
                finalResponseHeaders = `${anotherRes.protocol.toUpperCase()} ${anotherRes.status} ${anotherRes.statusText || STATUS_CODES[anotherRes.status]}${CRLF}`
              }
              for (headerKey in head) {
                finalResponseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
              }
              finalResponseHeaders += `${CRLF}`
            }

            // if their is no anotherResponse body these values are undefined
            // do not request body if there is none or zero length body
            let anotherResData
            let wasError = false
            try {
              let rbody = await network.getResponseBody({requestId: nreq.requestId})
              if (rbody.base64Encoded) {
                anotherResData = Buffer.from(rbody.body, &apos;base64&apos;)
              } else {
                anotherResData = Buffer.from(rbody.body, &apos;utf8&apos;)
              }
            } catch (err) {
              wasError = true
            }
            // console.log(finalResponseHeaders)
            if (!wasError) {
              finalResponseHeaders = finalResponseHeaders.replace(noGZ, &apos;&apos;)
              finalResponseHeaders = finalResponseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(anotherResData, &apos;utf8&apos;)}${CRLF}`)
            }
            // console.log(finalResponseHeaders)
            await this.writeResponseRecord(anotherRes.url, finalResponseHeaders, anotherResData)
          }
        }
      }
    }
  }

  /**
   * @desc Generates The Request Response WARC Records for GET
   * @param {Object} nreq the captured HTTP request/response for the GET request
   * @param {Object} network the chrome-remote-interface Network object
   * @return {Promise.&lt;void&gt;}
   */
  async generateGet (nreq, network) {
    let res
    let requestHeaders
    let responseHeaders
    let purl = URL.parse(nreq.url)
    let headerKey
    let head
    let wasResArray = Array.isArray(nreq.res)
    if (wasResArray) {
      // no idea why this would happen
      res = nreq.res.pop()
    } else {
      res = nreq.res
    }
    if (res === null || res === undefined) {
      // we do not have a response
      requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
      if (!isEmptyPlainObject(nreq.headers)) {
        // the headers object is present
        head = nreq.headers
        if (!(head.host || head.Host)) {
          head[&apos;Host&apos;] = purl.host
        }
        for (headerKey in head) {
          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        requestHeaders += `${CRLF}`
      } else {
        // the headers object is not present, recreate with minimal information
        requestHeaders += `Host: ${purl.host}\r\nUser-Agent: ${UA}${CRLF}`
      }

      await this.writeRequestRecord(nreq.url, requestHeaders)
      // console.log(requestHeaders)
    } else {
      if (res.protocol === &apos;data&apos;) {
        return
      }
      if (res.requestHeadersText) {
        // response has full request headers string
        requestHeaders = res.requestHeadersText
      } else if (!isEmptyPlainObject(res.requestHeaders)) {
        // response did not have the full request headers string use object
        if (this._noHTTP2) {
          requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
        } else {
          requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`
        }
        head = res.requestHeaders
        if (!(head.host || head.Host)) {
          head[&apos;Host&apos;] = purl.host
        }
        for (headerKey in head) {
          requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        requestHeaders += `${CRLF}`
      } else {
        // response has no full request http headers information
        if (this._noHTTP2) {
          requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
        } else {
          requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`
        }
        if (!isEmptyPlainObject(nreq.headers)) {
          // the request object has the request http header object
          head = nreq.headers
          if (!(head.host || head.Host)) {
            head[&apos;Host&apos;] = purl.host
          }
          for (headerKey in head) {
            requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
          }
          requestHeaders += `${CRLF}`
        } else {
          // the request object does not have the request http header information
          // recreate with minimal information
          requestHeaders += `Host: ${purl.host}\r\nUser-Agent: ${UA}${CRLF}`
        }
      }

      await this.writeRequestRecord(nreq.url, requestHeaders)

      if (res.headersText) {
        responseHeaders = res.headersText
      } else if (!isEmptyPlainObject(res.headers)) {
        head = res.headers
        if (this._noHTTP2) {
          responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
        } else {
          responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
        }
        for (headerKey in head) {
          responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
        }
        responseHeaders += `${CRLF}`
      } else {
        console.log(&apos;the response headers are empty GET&apos;)
        if (this._noHTTP2) {
          responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
        } else {
          responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
        }
      }

      let resData
      let wasError = false
      try {
        let rbody = await network.getResponseBody({requestId: nreq.requestId})
        if (rbody.base64Encoded) {
          resData = Buffer.from(rbody.body, &apos;base64&apos;)
        } else {
          resData = Buffer.from(rbody.body, &apos;utf8&apos;)
        }
      } catch (err) {
        wasError = true
      }

      if (!wasError) {
        responseHeaders = responseHeaders.replace(noGZ, &apos;&apos;)
        responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, &apos;utf8&apos;)}${CRLF}`)
      }
      await this.writeResponseRecord(nreq.url, responseHeaders, resData)
      if (wasResArray &amp;&amp; nreq.res.length &gt; 0) {
        let i = 0
        let len = nreq.res.length
        for (; i &lt; len; ++i) {
          res = nreq.res[i]
          if (res.headersText) {
            responseHeaders = res.headersText
          } else if (!isEmptyPlainObject(res.headers)) {
            head = res.headers
            if (this._noHTTP2) {
              responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
            } else {
              responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
            }
            for (headerKey in head) {
              responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
            }
            responseHeaders += `${CRLF}`
          } else {
            continue
          }

          let resData
          let wasError = false
          try {
            let rbody = await network.getResponseBody({requestId: nreq.requestId})
            if (rbody.base64Encoded) {
              resData = Buffer.from(rbody.body, &apos;base64&apos;)
            } else {
              resData = Buffer.from(rbody.body, &apos;utf8&apos;)
            }
          } catch (err) {
            wasError = true
          }

          if (!wasError) {
            responseHeaders = responseHeaders.replace(noGZ, &apos;&apos;)
            responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, &apos;utf8&apos;)}${CRLF}`)
          }
          await this.writeResponseRecord(nreq.url, responseHeaders, resData)
        }
      }
    }
  }

  /**
   * @desc Generates The Request Response WARC Records for OPTIONS
   * @param {Object} nreq the captured HTTP request/response for the OPTIONS request
   * @param {Object} network the chrome-remote-interface Network object
   * @return {Promise.&lt;void&gt;}
   */
  async generateOptions (nreq, network) {
    let res
    let requestHeaders
    let responseHeaders
    let purl = URL.parse(nreq.url)
    let headerKey
    let head

    // https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-RequestId states that
    // the requestId we use as the key is unique to the request so we take the last element
    // no clue why we have two responses
    if (Array.isArray(nreq.res)) {
      res = nreq.res.pop()
    } else {
      res = nreq.res
    }

    if (res.requestHeadersText) {
      requestHeaders = res.requestHeadersText
    } else if (!isEmptyPlainObject(res.requestHeaders)) {
      requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`
      head = res.requestHeaders
      if (!(head.host || head.Host)) {
        head[&apos;Host&apos;] = purl.host
      }
      for (headerKey in head) {
        requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
      }
    } else if (!isEmptyPlainObject(nreq.headers)) {
      requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`
      head = nreq.headers
      if (!(head.host || head.Host)) {
        head[&apos;Host&apos;] = purl.host
      }
      for (headerKey in head) {
        requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
      }
      requestHeaders += `${CRLF}`
    } else {
      console.log(&apos;the request headers are both empty&apos;)
    }
    await this.writeRequestRecord(nreq.url, requestHeaders)

    if (res.headersText) {
      responseHeaders = res.headersText
    } else if (!isEmptyPlainObject(res.headers)) {
      head = res.headers
      if (!(head.host || head.Host)) {
        head[&apos;Host&apos;] = purl.host
      }
      responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
      for (headerKey in head) {
        responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
      }
      responseHeaders += `${CRLF}`
    } else {
      if (this._noHTTP2) {
        responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
      } else {
        responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
      }
    }
    await this.writeResponseRecord(nreq.url, responseHeaders)
  }

  /**
   * @desc Handle Non HTTP POST GET OPTIONS request. And yes the live web uses them all
   * @param {Object} nreq the captured HTTP request/response
   * @param {Object} network the chrome-remote-interface Network object
   * @return {Promise.&lt;void&gt;}
   */
  async generateOther (nreq, network) {
    // ducktape
    if (!nreq.postData) {
      await this.generateGet(nreq, network)
    } else {
      await this.generatePost(nreq, network)
    }
  }

  /**
   * @desc If a stray response comes in without a request HTTP/2 likely preserve it!
   * @param {Object} nreq the captured HTTP response
   * @param {Object} network the chrome-remote-interface Network object
   * @return {Promise.&lt;void&gt;}
   */
  async generateOnlyRes (nreq, network) {
    let res = nreq.res
    let requestHeaders
    let responseHeaders
    let purl = URL.parse(res.url)
    let headerKey
    let head
    res.protocol = res.protocol || &apos;http/1.1&apos;
    if (res.protocol === &apos;data&apos;) {
      return
    }

    if (res.requestHeadersText) {
      nreq.method = res.requestHeadersText.substring(0, res.requestHeadersText.indexOf(&apos; &apos;))
    } else {
      // we handle htt2 :method
      return
    }

    if (res.requestHeadersText) {
      // response has full request headers string
      requestHeaders = res.requestHeadersText
    } else if (!isEmptyPlainObject(res.requestHeaders)) {
      // response did not have the full request headers string use object
      if (this._noHTTP2) {
        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
      } else {
        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`
      }
      head = res.requestHeaders
      if (!(head.host || head.Host)) {
        head[&apos;Host&apos;] = purl.host
      }
      for (headerKey in head) {
        requestHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
      }
      requestHeaders += `${CRLF}`
    } else {
      // response has no full request http headers information
      if (this._noHTTP2) {
        requestHeaders = `${nreq.method} ${purl.path} HTTP/1.1${CRLF}`
      } else {
        requestHeaders = `${nreq.method} ${purl.path} ${res.protocol.toUpperCase()}${CRLF}`
      }
      // the request object does not have the request http header information
      // recreate with minimal information
      requestHeaders += `Host: ${purl.host}\r\nUser-Agent: ${UA}${CRLF}`
    }

    await this.writeRequestRecord(res.url, requestHeaders)

    if (res.headersText) {
      responseHeaders = res.headersText
    } else if (!isEmptyPlainObject(res.headers)) {
      head = res.headers
      if (this._noHTTP2) {
        responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
      } else {
        responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
      }
      for (headerKey in head) {
        responseHeaders += `${headerKey}: ${head[headerKey]}${CRLF}`
      }
      responseHeaders += `${CRLF}`
    } else {
      if (this._noHTTP2) {
        responseHeaders = `HTTP/1.1 ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
      } else {
        responseHeaders = `${res.protocol.toUpperCase()} ${res.status} ${res.statusText || STATUS_CODES[res.status]}${CRLF}`
      }
    }

    let resData
    let wasError = false
    try {
      let rbody = await network.getResponseBody({requestId: nreq.requestId})
      if (rbody.base64Encoded) {
        resData = Buffer.from(rbody.body, &apos;base64&apos;)
      } else {
        resData = Buffer.from(rbody.body, &apos;utf8&apos;)
      }
    } catch (err) {
      wasError = true
    }

    if (!wasError) {
      responseHeaders = responseHeaders.replace(noGZ, &apos;&apos;)
      responseHeaders = responseHeaders.replace(replaceContentLen, `Content-Length: ${Buffer.byteLength(resData, &apos;utf8&apos;)}${CRLF}`)
    }
    await this.writeResponseRecord(res.url, responseHeaders, resData)
  }
}

module.exports = RemoteChromeWARCGenerator
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
