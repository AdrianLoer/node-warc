[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 49,
    "kind": "external",
    "name": "Buffer",
    "externalLink": "https://nodejs.org/api/buffer.html",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~Buffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 50,
    "kind": "external",
    "name": "Transform",
    "externalLink": "https://nodejs.org/api/stream.html#stream_class_stream_transform",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~Transform",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 51,
    "kind": "external",
    "name": "Readable",
    "externalLink": "https://nodejs.org/api/stream.html#stream_class_stream_readable",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~Readable",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 52,
    "kind": "external",
    "name": "Gunzip",
    "externalLink": "https://nodejs.org/api/zlib.html#zlib_class_zlib_gunzip",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~Gunzip",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 53,
    "kind": "external",
    "name": "ReadStream",
    "externalLink": "https://nodejs.org/api/fs.html#fs_class_fs_readstream",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~ReadStream",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 54,
    "kind": "external",
    "name": "Request",
    "externalLink": "https://pptr.dev/#?product=Puppeteer&version=v1.9.0&show=api-class-request",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~Request",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 55,
    "kind": "external",
    "name": "Page",
    "externalLink": "https://pptr.dev/#?product=Puppeteer&version=v1.9.0&show=api-class-page",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~Page",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 56,
    "kind": "external",
    "name": "CDPSession",
    "externalLink": "https://pptr.dev/#?product=Puppeteer&version=v1.9.0&show=api-class-cdpsession",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~CDPSession",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 57,
    "kind": "external",
    "name": "EventEmitter",
    "externalLink": "https://github.com/primus/eventemitter3",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~EventEmitter",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 58,
    "kind": "external",
    "name": "AsyncIterator",
    "externalLink": "https://github.com/tc39/proposal-async-iteration",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~AsyncIterator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 59,
    "kind": "external",
    "name": "symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "lib/.externs.js",
    "static": true,
    "longname": "lib/.externs.js~symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 60,
    "kind": "file",
    "name": "lib/parsers/_canUseRecordIterator.js",
    "content": "/**\n * @type {boolean}\n */\nlet asyncGenFns = true\ntry {\n  new Function('async function* test(){yield await Promise.resolve(1)}')\n} catch (error) {\n  asyncGenFns = false\n}\n\n/**\n * @type {boolean}\n */\nmodule.exports = asyncGenFns && typeof Symbol.asyncIterator !== 'undefined'\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/parsers/_canUseRecordIterator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 61,
    "kind": "variable",
    "name": "asyncGenFns",
    "memberof": "lib/parsers/_canUseRecordIterator.js",
    "static": true,
    "longname": "lib/parsers/_canUseRecordIterator.js~asyncGenFns",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/parsers/_canUseRecordIterator.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 4,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 62,
    "kind": "file",
    "name": "lib/parsers/autoWARCParser.js",
    "content": "const fs = require('fs-extra')\nconst zlib = require('zlib')\nconst EventEmitter = require('eventemitter3')\nconst untildify = require('untildify')\nconst WARCStreamTransform = require('./warcStreamTransform')\nconst GzipDetector = require('./gzipDetector')\nconst canUseRecordIterator = require('./_canUseRecordIterator')\n\n/**\n * @desc Parses a WARC file automatically detecting if it is gzipped.\n * @extends {EventEmitter}\n * @example\n *  const parser = new AutoWARCParser('<path-to-warcfile>')\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('error', error => { console.error(error) })\n *  parser.start()\n * @example\n *  const parser = new AutoWARCParser()\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('error', error => { console.error(error) })\n *  parser.parseWARC('<path-to-warcfile>')\n *  @example\n *  // requires node >= 10\n *  for await (const record of new AutoWARCParser('<path-to-warcfile>')) {\n *    console.log(record)\n *  }\n */\nclass AutoWARCParser extends EventEmitter {\n  /**\n   * @desc Create a new AutoWARCParser\n   * @param {?string} [wp] - path to the warc file to be parsed\n   */\n  constructor (wp) {\n    super()\n    /**\n     * @type {?string} the path to the WARC file to be parsed\n     * @private\n     */\n    this._wp = wp\n\n    /**\n     * @type {boolean} is the parser currently parsing the WARC\n     * @private\n     */\n    this._parsing = false\n\n    this._onRecord = this._onRecord.bind(this)\n    this._onEnd = this._onEnd.bind(this)\n    this._onError = this._onError.bind(this)\n\n    if (canUseRecordIterator) {\n      const recordIterator = require('./recordterator')\n      /**\n       * @returns {AsyncIterator<WARCRecord>}\n       */\n      this[Symbol.asyncIterator] = () => {\n        return recordIterator(this._getStream())\n      }\n    }\n  }\n\n  /**\n   * @desc Begin parsing the WARC file. Once the start method has been called the parser will begin emitting\n   * @emits {record} emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record\n   * @emits {done} emitted when the WARC file has been completely parsed\n   * @emits {error} emitted if an exception occurs, the argument supplied to the listener will be the error that occurred.\n   * @return {boolean}  if the parser has begun or is currently parsing a WARC file\n   * - true: indicates the parser has begun parsing the WARC file true\n   * - false: indicated the parser is currently parsing a WARC file\n   * @throws {Error} if the path to the WARC file is null or undefined or another error occurred\n   */\n  start () {\n    let startedParsing = false\n    if (!this._parsing) {\n      if (this._wp == null) {\n        throw new Error('The supplied path to the WARC file is null/undefined')\n      }\n      this._parsing = true\n      this._getStream()\n        .pipe(new WARCStreamTransform())\n        .on('data', this._onRecord)\n        .on('error', this._onError)\n        .on('end', this._onEnd)\n      startedParsing = true\n    }\n    return startedParsing\n  }\n\n  /**\n   * @desc Alias for {@link start} except that you can supply the path to the WARC file to be parsed\n   * if one was not supplied via the constructor or to parse another WARC file. If the path to WARC file\n   * to be parsed was supplied via the constructor and you supply a different path to this method.\n   * It will override the one supplied via the constructor\n   * @param {?string} [wp] - path to the WARC file to be parsed\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC file\n   * @throws {Error} if the path to the WARC file is null or undefined or another error occurred\n   */\n  parseWARC (wp) {\n    if (!this._parsing) {\n      this._wp = wp || this._wp\n    }\n    return this.start()\n  }\n\n  /**\n   * @desc Listener for a parsers record event\n   * @param {WARCRecord} record\n   * @private\n   */\n  _onRecord (record) {\n    this.emit('record', record)\n  }\n\n  /**\n   * @desc Listener for a parsers done event\n   * @private\n   */\n  _onEnd () {\n    this._parsing = false\n    this.emit('done')\n  }\n\n  /**\n   * @desc Listener for a parsers error event\n   * @param {Error} error\n   * @private\n   */\n  _onError (error) {\n    this.emit('error', error)\n  }\n\n  /**\n   * @desc Returns a ReadStream for the WARC to be parsed.\n   * If the WARC file is gziped the returned value will the\n   * results of ``ReadStream.pipe(zlib.createGunzip())``\n   * @returns {ReadStream|Gunzip}\n   * @private\n   */\n  _getStream () {\n    const isGz = GzipDetector.isGzippedSync(this._wp)\n    const stream = fs.createReadStream(untildify(this._wp))\n    if (isGz) return stream.pipe(zlib.createGunzip())\n    return stream\n  }\n}\n\n/**\n * @type {AutoWARCParser}\n */\nmodule.exports = AutoWARCParser\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/parsers/autoWARCParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 63,
    "kind": "class",
    "name": "AutoWARCParser",
    "memberof": "lib/parsers/autoWARCParser.js",
    "static": true,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/parsers/autoWARCParser.js",
    "importStyle": "AutoWARCParser",
    "description": "Parses a WARC file automatically detecting if it is gzipped.",
    "examples": [
      " const parser = new AutoWARCParser('<path-to-warcfile>')\n parser.on('record', record => { console.log(record) })\n parser.on('error', error => { console.error(error) })\n parser.start()",
      " const parser = new AutoWARCParser()\n parser.on('record', record => { console.log(record) })\n parser.on('error', error => { console.error(error) })\n parser.parseWARC('<path-to-warcfile>')",
      " // requires node >= 10\n for await (const record of new AutoWARCParser('<path-to-warcfile>')) {\n   console.log(record)\n }"
    ],
    "lineNumber": 28,
    "interface": false,
    "extends": [
      "EventEmitter"
    ]
  },
  {
    "__docId__": 64,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#constructor",
    "access": "public",
    "description": "Create a new AutoWARCParser",
    "lineNumber": 33,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "wp",
        "description": "path to the warc file to be parsed"
      }
    ]
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "_wp",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#_wp",
    "access": "private",
    "description": "",
    "lineNumber": 39,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#_parsing",
    "access": "private",
    "description": "",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 70,
    "kind": "member",
    "name": "[Symbol.asyncIterator]",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#[Symbol.asyncIterator]",
    "access": "public",
    "description": "",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AsyncIterator<WARCRecord>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AsyncIterator<WARCRecord>"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "start",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#start",
    "access": "public",
    "description": "Begin parsing the WARC file. Once the start method has been called the parser will begin emitting",
    "lineNumber": 72,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "if the parser has begun or is currently parsing a WARC file\n- true: indicates the parser has begun parsing the WARC file true\n- false: indicated the parser is currently parsing a WARC file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC file is null or undefined or another error occurred"
      }
    ],
    "emits": [
      {
        "types": [
          "record"
        ],
        "description": "emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record"
      },
      {
        "types": [
          "done"
        ],
        "description": "emitted when the WARC file has been completely parsed"
      },
      {
        "types": [
          "error"
        ],
        "description": "emitted if an exception occurs, the argument supplied to the listener will be the error that occurred."
      }
    ],
    "params": []
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "parseWARC",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#parseWARC",
    "access": "public",
    "description": "Alias for {@link start} except that you can supply the path to the WARC file to be parsed\nif one was not supplied via the constructor or to parse another WARC file. If the path to WARC file\nto be parsed was supplied via the constructor and you supply a different path to this method.\nIt will override the one supplied via the constructor",
    "lineNumber": 98,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "wp",
        "description": "path to the WARC file to be parsed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC file is null or undefined or another error occurred"
      }
    ]
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "_onRecord",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#_onRecord",
    "access": "private",
    "description": "Listener for a parsers record event",
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCRecord"
        ],
        "spread": false,
        "optional": false,
        "name": "record",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "_onEnd",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#_onEnd",
    "access": "private",
    "description": "Listener for a parsers done event",
    "lineNumber": 118,
    "params": [],
    "return": null
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "_onError",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#_onError",
    "access": "private",
    "description": "Listener for a parsers error event",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "_getStream",
    "memberof": "lib/parsers/autoWARCParser.js~AutoWARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/autoWARCParser.js~AutoWARCParser#_getStream",
    "access": "private",
    "description": "Returns a ReadStream for the WARC to be parsed.\nIf the WARC file is gziped the returned value will the\nresults of ``ReadStream.pipe(zlib.createGunzip())``",
    "lineNumber": 139,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReadStream|Gunzip}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReadStream",
        "Gunzip"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 80,
    "kind": "file",
    "name": "lib/parsers/gzipDetector.js",
    "content": "const fs = require('fs-extra')\nconst untildify = require('untildify')\n\n/**\n * @see https://en.wikipedia.org/wiki/Gzip\n * @desc Gizped warc magic num:\n * - Buffer.from('1f8b08', 'hex')\n * - Uint8Array [ 31, 139, 8 ]\n * Not gziped warc magic num:\n * - Uint8Array [ 87, 65, 82 ]\n * @type {Buffer}\n */\nconst gzipMagicNum = Buffer.from('1f8b08', 'hex')\n\n/**\n * @type {number} length of the gzip magic number _header 3 bytes\n */\nconst gzipMagicNumLen = gzipMagicNum.length\n\n/**\n * Utility class that provides the means to detect if a file is gzipped or not\n */\nclass GzipDetector {\n  /**\n   * @desc Determines if a file is gzipped or not by reading its the magic number\n   * @param {string} filePath - path to the file to detect\n   * @return {Promise<boolean>} Promise that resolves to true if the file is gzipped false otherwise\n   * @throws {Error} if the filePath is null or undefined or if another error occurred\n   */\n  static async isGzipped (filePath) {\n    if (filePath == null) {\n      throw new Error(`The filePath path is ${filePath}`)\n    }\n    filePath = untildify(filePath)\n    const fd = await fs.open(filePath, 'r')\n    const fillMe = Buffer.allocUnsafe(3)\n    await fs.read(fd, fillMe, 0, 3, undefined)\n    await fs.close(fd)\n    let i = 0\n    let isGzipped = true\n    // should never happen as we create the Unit8Array to be size 3\n    // but just in case\n    if (gzipMagicNumLen !== fillMe.length) {\n      return false\n    }\n    for (; i < gzipMagicNumLen; ++i) {\n      if (gzipMagicNum[i] !== fillMe[i]) {\n        isGzipped = false\n        break\n      }\n    }\n    return isGzipped\n  }\n\n  /**\n   * @desc Synchronous version of {@link isGzipped}\n   * @param {string} filePath - path to the file to detect\n   * @return {boolean} true if the file is gzipped false otherwise\n   * @throws {Error} if the filePath is null or undefined or if another error occurred\n   */\n  static isGzippedSync (filePath) {\n    if (filePath == null) {\n      throw new Error(`The filePath path is ${filePath}`)\n    }\n    filePath = untildify(filePath)\n    const fd = fs.openSync(filePath, 'r')\n    const fillMe = Buffer.allocUnsafe(3)\n    fs.readSync(fd, fillMe, 0, 3, undefined)\n    fs.closeSync(fd)\n    let i = 0\n    let isGzipped = true\n    // should never happen as we create the Unit8Array to be size 3\n    // but just in case\n    if (gzipMagicNumLen !== fillMe.length) {\n      return false\n    }\n    for (; i < gzipMagicNumLen; ++i) {\n      if (gzipMagicNum[i] !== fillMe[i]) {\n        isGzipped = false\n        break\n      }\n    }\n    return isGzipped\n  }\n}\n\n/**\n * @type {GzipDetector}\n */\nmodule.exports = GzipDetector\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/parsers/gzipDetector.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 81,
    "kind": "variable",
    "name": "gzipMagicNum",
    "memberof": "lib/parsers/gzipDetector.js",
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~gzipMagicNum",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/parsers/gzipDetector.js",
    "importStyle": null,
    "description": "Gizped warc magic num:\n- Buffer.from('1f8b08', 'hex')\n- Uint8Array [ 31, 139, 8 ]\nNot gziped warc magic num:\n- Uint8Array [ 87, 65, 82 ]",
    "see": [
      "https://en.wikipedia.org/wiki/Gzip"
    ],
    "lineNumber": 13,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 82,
    "kind": "variable",
    "name": "gzipMagicNumLen",
    "memberof": "lib/parsers/gzipDetector.js",
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~gzipMagicNumLen",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/parsers/gzipDetector.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 83,
    "kind": "class",
    "name": "GzipDetector",
    "memberof": "lib/parsers/gzipDetector.js",
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~GzipDetector",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/parsers/gzipDetector.js",
    "importStyle": "GzipDetector",
    "description": "Utility class that provides the means to detect if a file is gzipped or not",
    "lineNumber": 23,
    "interface": false
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "isGzipped",
    "memberof": "lib/parsers/gzipDetector.js~GzipDetector",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~GzipDetector.isGzipped",
    "access": "public",
    "description": "Determines if a file is gzipped or not by reading its the magic number",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "path to the file to detect"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "Promise that resolves to true if the file is gzipped false otherwise"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the filePath is null or undefined or if another error occurred"
      }
    ]
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "isGzippedSync",
    "memberof": "lib/parsers/gzipDetector.js~GzipDetector",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parsers/gzipDetector.js~GzipDetector.isGzippedSync",
    "access": "public",
    "description": "Synchronous version of {@link isGzipped}",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "path to the file to detect"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the file is gzipped false otherwise"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the filePath is null or undefined or if another error occurred"
      }
    ]
  },
  {
    "__docId__": 86,
    "kind": "file",
    "name": "lib/parsers/recordterator.js",
    "content": "'use strict'\nconst WARCStreamTransform = require('./warcStreamTransform')\n\n/**\n * @desc Creates async iterator that yields {@link WARCRecord}s given a readable stream of a WARC file\n * @param {ReadStream|Gunzip} warcStream\n * @returns {AsyncIterator<WARCRecord>}\n */\nmodule.exports = async function * recordIterator (warcStream) {\n  const recordStream = warcStream.pipe(new WARCStreamTransform())\n  const recordIterator = recordStream[Symbol.asyncIterator]()\n  let nextRecord\n  while (true) {\n    nextRecord = await recordIterator.next()\n    if (nextRecord.done) break\n    yield nextRecord.value\n  }\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/parsers/recordterator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 87,
    "kind": "function",
    "name": "recordIterator",
    "memberof": "lib/parsers/recordterator.js",
    "generator": true,
    "async": true,
    "static": true,
    "longname": "lib/parsers/recordterator.js~recordIterator",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/parsers/recordterator.js",
    "importStyle": "recordIterator",
    "description": "Creates async iterator that yields {@link WARCRecord}s given a readable stream of a WARC file",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AsyncIterator<WARCRecord>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ReadStream",
          "Gunzip"
        ],
        "spread": false,
        "optional": false,
        "name": "warcStream",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AsyncIterator<WARCRecord>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 88,
    "kind": "file",
    "name": "lib/parsers/warcGzParser.js",
    "content": "const untildify = require('untildify')\nconst fs = require('fs-extra')\nconst zlib = require('zlib')\nconst EventEmitter = require('eventemitter3')\nconst WARCStreamTransform = require('./warcStreamTransform')\nconst canUseRecordIterator = require('./_canUseRecordIterator')\n\n/**\n * @desc Parse a WARC.gz file\n * @extends {EventEmitter}\n * @example\n *  const parser = new WARCGzParser('<path-to-warcfile>')\n *  parser.on('record', record => { console.log(record); })\n *  parser.on('done', () => { console.log('finished'); })\n *  parser.on('error', error => { console.error(error); })\n *  parser.start()\n * @example\n *  const parser = new WARCGzParser()\n *  parser.on('record', record => { console.log(record); })\n *  parser.on('done', () => { console.log('finished'); })\n *  parser.on('error', error => { console.error(error); })\n *  parser.parseWARC('<path-to-warcfile>')\n * @example\n *  // requires node >= 10\n *  for await (const record of new WARCGzParser('<path-to-warcfile>')) {\n *    console.log(record)\n *  }\n */\nclass WARCGzParser extends EventEmitter {\n  /**\n   * @desc Create a new WARCGzParser\n   * @param {?string} [wp] - path to the warc.gz file to be parsed\n   */\n  constructor (wp) {\n    super()\n    /**\n     * @type {?string} the path to the WARC.gz file to be parsed\n     * @private\n     */\n    this._wp = wp\n\n    /**\n     * @type {boolean} is the parser currently parsing the WARC.gz\n     * @private\n     */\n    this._parsing = false\n    this._onRecord = this._onRecord.bind(this)\n    this._onError = this._onError.bind(this)\n    this._onEnd = this._onEnd.bind(this)\n    if (canUseRecordIterator) {\n      const recordIterator = require('./recordterator')\n      /**\n       * @returns {AsyncIterator<WARCRecord>}\n       */\n      this[Symbol.asyncIterator] = () => {\n        return recordIterator(\n          fs.createReadStream(this._wp).pipe(zlib.createGunzip())\n        )\n      }\n    }\n  }\n\n  /**\n   * @desc Begin parsing the WARC.gz file. Once the start method has been called the parser will begin emitting\n   * @emits {record} emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record\n   * @emits {done} emitted when the WARC.gz file has been completely parsed, the argument supplied to the listener will be last record\n   * @emits {error} emitted if an exception occurs, the argument supplied to the listener will be the error that occurred.\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC.gz file\n   * - true: indicates the parser has begun parsing the WARC.gz file true\n   * - false: indicated the parser is currently parsing a WARC.gz file\n   * @throws {Error} if the path to the WARC.gz file is null or undefined or another error occurred\n   */\n  start () {\n    let start = false\n    if (!this._parsing) {\n      if (this._wp == null) {\n        throw new Error('The path to the WARC file is null/undefined')\n      }\n      this._parsing = true\n      start = true\n      fs\n        .createReadStream(untildify(this._wp))\n        .pipe(zlib.createGunzip())\n        .pipe(new WARCStreamTransform())\n        .on('data', this._onRecord)\n        .on('error', this._onError)\n        .on('end', this._onEnd)\n    }\n    return start\n  }\n\n  /**\n   * @desc Callback for the read stream data event\n   * @param {WARCRecord} record\n   * @private\n   */\n  _onRecord (record) {\n    this.emit('record', record)\n  }\n\n  /**\n   * @desc Callback for the read stream error event\n   * @param {Error} error\n   * @private\n   */\n  _onError (error) {\n    this.emit('error', error)\n  }\n\n  /**\n   * @desc Callback for the read stream end event\n   * @private\n   */\n  _onEnd () {\n    this._parsing = false\n    this.emit('done')\n  }\n\n  /**\n   * @desc Alias for {@link start} except that you can supply the path to the WARC.gz file to be parsed\n   * if one was not supplied via the constructor or to parse another WARC.gz file. If the path to WARC.gz file\n   * to be parsed was supplied via the constructor and you supply a different path to this method.\n   * It will override the one supplied via the constructor\n   * @param {?string} [wp] - path to the WARC file to be parsed\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC.gz file\n   * @throws {Error} if the path to the WARC.gz file is null or undefined or another error occurred\n   */\n  parseWARC (wp) {\n    if (!this._parsing) {\n      this._wp = wp || this._wp\n    }\n    return this.start()\n  }\n}\n\n/**\n * @type {WARCGzParser}\n */\nmodule.exports = WARCGzParser\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/parsers/warcGzParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 89,
    "kind": "class",
    "name": "WARCGzParser",
    "memberof": "lib/parsers/warcGzParser.js",
    "static": true,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/parsers/warcGzParser.js",
    "importStyle": "WARCGzParser",
    "description": "Parse a WARC.gz file",
    "examples": [
      " const parser = new WARCGzParser('<path-to-warcfile>')\n parser.on('record', record => { console.log(record); })\n parser.on('done', () => { console.log('finished'); })\n parser.on('error', error => { console.error(error); })\n parser.start()",
      " const parser = new WARCGzParser()\n parser.on('record', record => { console.log(record); })\n parser.on('done', () => { console.log('finished'); })\n parser.on('error', error => { console.error(error); })\n parser.parseWARC('<path-to-warcfile>')",
      " // requires node >= 10\n for await (const record of new WARCGzParser('<path-to-warcfile>')) {\n   console.log(record)\n }"
    ],
    "lineNumber": 29,
    "interface": false,
    "extends": [
      "EventEmitter"
    ]
  },
  {
    "__docId__": 90,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#constructor",
    "access": "public",
    "description": "Create a new WARCGzParser",
    "lineNumber": 34,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "wp",
        "description": "path to the warc.gz file to be parsed"
      }
    ]
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "_wp",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_wp",
    "access": "private",
    "description": "",
    "lineNumber": 40,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_parsing",
    "access": "private",
    "description": "",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "[Symbol.asyncIterator]",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#[Symbol.asyncIterator]",
    "access": "public",
    "description": "",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AsyncIterator<WARCRecord>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AsyncIterator<WARCRecord>"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "start",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#start",
    "access": "public",
    "description": "Begin parsing the WARC.gz file. Once the start method has been called the parser will begin emitting",
    "lineNumber": 73,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC.gz file\n- true: indicates the parser has begun parsing the WARC.gz file true\n- false: indicated the parser is currently parsing a WARC.gz file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC.gz file is null or undefined or another error occurred"
      }
    ],
    "emits": [
      {
        "types": [
          "record"
        ],
        "description": "emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record"
      },
      {
        "types": [
          "done"
        ],
        "description": "emitted when the WARC.gz file has been completely parsed, the argument supplied to the listener will be last record"
      },
      {
        "types": [
          "error"
        ],
        "description": "emitted if an exception occurs, the argument supplied to the listener will be the error that occurred."
      }
    ],
    "params": []
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "_onRecord",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_onRecord",
    "access": "private",
    "description": "Callback for the read stream data event",
    "lineNumber": 97,
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCRecord"
        ],
        "spread": false,
        "optional": false,
        "name": "record",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "_onError",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_onError",
    "access": "private",
    "description": "Callback for the read stream error event",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "_onEnd",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#_onEnd",
    "access": "private",
    "description": "Callback for the read stream end event",
    "lineNumber": 114,
    "params": [],
    "return": null
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "parseWARC",
    "memberof": "lib/parsers/warcGzParser.js~WARCGzParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcGzParser.js~WARCGzParser#parseWARC",
    "access": "public",
    "description": "Alias for {@link start} except that you can supply the path to the WARC.gz file to be parsed\nif one was not supplied via the constructor or to parse another WARC.gz file. If the path to WARC.gz file\nto be parsed was supplied via the constructor and you supply a different path to this method.\nIt will override the one supplied via the constructor",
    "lineNumber": 128,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "wp",
        "description": "path to the WARC file to be parsed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC.gz file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC.gz file is null or undefined or another error occurred"
      }
    ]
  },
  {
    "__docId__": 105,
    "kind": "file",
    "name": "lib/parsers/warcParser.js",
    "content": "const untildify = require('untildify')\nconst fs = require('fs-extra')\nconst EventEmitter = require('eventemitter3')\nconst WARCStreamTransform = require('./warcStreamTransform')\nconst canUseRecordIterator = require('./_canUseRecordIterator')\n\n/**\n * @desc Parse a WARC file\n * @extends {EventEmitter}\n * @example\n *  const parser = new WARCParser('<path-to-warcfile>')\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('done', () => { console.log('done') })\n *  parser.on('error', error => { console.error(error) })\n *  parser.start()\n * @example\n *  const parser = new WARCParser()\n *  parser.on('record', record => { console.log(record) })\n *  parser.on('done', () => { console.log('done') })\n *  parser.on('error', error => { console.error(error) })\n *  parser.parseWARC('<path-to-warcfile>')\n * @example\n *  // requires node >= 10\n *  for await (const record of new WARCParser('<path-to-warcfile>')) {\n *    console.log(record)\n *  }\n */\nclass WARCParser extends EventEmitter {\n  /**\n   * @desc Create a new WARCParser\n   * @param {?string} [wp] - path to the warc file to be parsed\n   */\n  constructor (wp) {\n    super()\n    /**\n     * @type {?string} the path to the WARC file to be parsed\n     * @private\n     */\n    this._wp = wp\n\n    /**\n     * @type {boolean} is the parser currently parsing the WARC\n     * @private\n     */\n    this._parsing = false\n    this._onRecord = this._onRecord.bind(this)\n    this._onError = this._onError.bind(this)\n    this._onEnd = this._onEnd.bind(this)\n    if (canUseRecordIterator) {\n      const recordIterator = require('./recordterator')\n      /**\n       * @returns {AsyncIterator<WARCRecord>}\n       */\n      this[Symbol.asyncIterator] = () => {\n        return recordIterator(fs.createReadStream(this._wp))\n      }\n    }\n  }\n\n  /**\n   * @desc Begin parsing the WARC file. Once the start method has been called the parser will begin emitting\n   * @emits {record} emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record\n   * @emits {done} emitted when the WARC file has been completely parsed, the argument supplied to the listener will be last record\n   * @emits {error} emitted if an exception occurs, the argument supplied to the listener will be the error that occurred.\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC file\n   * - true: indicates the parser has begun parsing the WARC file true\n   * - false: indicated the parser is currently parsing a WARC file\n   * @throws {Error} if the path to the WARC file is null or undefined or another error occurred\n   */\n  start () {\n    let start = false\n    if (!this._parsing) {\n      if (this._wp === null || this._wp === undefined) {\n        throw new Error('The path to the WARC file is undefined')\n      }\n      this._parsing = true\n      start = true\n      fs\n        .createReadStream(untildify(this._wp))\n        .pipe(new WARCStreamTransform())\n        .on('data', this._onRecord)\n        .on('error', this._onError)\n        .on('end', this._onEnd)\n    }\n    return start\n  }\n\n  /**\n   * @desc Callback for the read stream data event\n   * @param {WARCRecord} record\n   * @private\n   */\n  _onRecord (record) {\n    this.emit('record', record)\n  }\n\n  /**\n   * @desc Callback for the read stream error event\n   * @param {Error} error\n   * @private\n   */\n  _onError (error) {\n    this.emit('error', error)\n  }\n\n  /**\n   * @desc Callback for the read stream end event\n   * @private\n   */\n  _onEnd () {\n    this._parsing = false\n    this.emit('done')\n  }\n\n  /**\n   * @desc Alias for {@link start} except that you can supply the path to the WARC file to be parsed\n   * if one was not supplied via the constructor or to parse another WARC file. If the path to WARC file\n   * to be parsed was supplied via the constructor and you supply a different path to this method.\n   * It will override the one supplied via the constructor\n   * @param {?string} [wp] - path to the WARC file to be parsed\n   * @return {boolean} indication if the parser has begun or is currently parsing a WARC file\n   * @throws {Error} if the path to the WARC file is null or undefined or another error occurred\n   */\n  parseWARC (wp) {\n    if (!this._parsing) {\n      this._wp = wp || this._wp\n    }\n    return this.start()\n  }\n}\n\n/**\n * @type {WARCParser}\n */\nmodule.exports = WARCParser\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/parsers/warcParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 106,
    "kind": "class",
    "name": "WARCParser",
    "memberof": "lib/parsers/warcParser.js",
    "static": true,
    "longname": "lib/parsers/warcParser.js~WARCParser",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/parsers/warcParser.js",
    "importStyle": "WARCParser",
    "description": "Parse a WARC file",
    "examples": [
      " const parser = new WARCParser('<path-to-warcfile>')\n parser.on('record', record => { console.log(record) })\n parser.on('done', () => { console.log('done') })\n parser.on('error', error => { console.error(error) })\n parser.start()",
      " const parser = new WARCParser()\n parser.on('record', record => { console.log(record) })\n parser.on('done', () => { console.log('done') })\n parser.on('error', error => { console.error(error) })\n parser.parseWARC('<path-to-warcfile>')",
      " // requires node >= 10\n for await (const record of new WARCParser('<path-to-warcfile>')) {\n   console.log(record)\n }"
    ],
    "lineNumber": 28,
    "interface": false,
    "extends": [
      "EventEmitter"
    ]
  },
  {
    "__docId__": 107,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#constructor",
    "access": "public",
    "description": "Create a new WARCParser",
    "lineNumber": 33,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "wp",
        "description": "path to the warc file to be parsed"
      }
    ]
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_wp",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_wp",
    "access": "private",
    "description": "",
    "lineNumber": 39,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "_parsing",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_parsing",
    "access": "private",
    "description": "",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "[Symbol.asyncIterator]",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#[Symbol.asyncIterator]",
    "access": "public",
    "description": "",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AsyncIterator<WARCRecord>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AsyncIterator<WARCRecord>"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "start",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#start",
    "access": "public",
    "description": "Begin parsing the WARC file. Once the start method has been called the parser will begin emitting",
    "lineNumber": 70,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC file\n- true: indicates the parser has begun parsing the WARC file true\n- false: indicated the parser is currently parsing a WARC file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC file is null or undefined or another error occurred"
      }
    ],
    "emits": [
      {
        "types": [
          "record"
        ],
        "description": "emitted when the parser has parsed a full record, the argument supplied to the listener will be the parsed record"
      },
      {
        "types": [
          "done"
        ],
        "description": "emitted when the WARC file has been completely parsed, the argument supplied to the listener will be last record"
      },
      {
        "types": [
          "error"
        ],
        "description": "emitted if an exception occurs, the argument supplied to the listener will be the error that occurred."
      }
    ],
    "params": []
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "_onRecord",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_onRecord",
    "access": "private",
    "description": "Callback for the read stream data event",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCRecord"
        ],
        "spread": false,
        "optional": false,
        "name": "record",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "_onError",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_onError",
    "access": "private",
    "description": "Callback for the read stream error event",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "_onEnd",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#_onEnd",
    "access": "private",
    "description": "Callback for the read stream end event",
    "lineNumber": 110,
    "params": [],
    "return": null
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "parseWARC",
    "memberof": "lib/parsers/warcParser.js~WARCParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcParser.js~WARCParser#parseWARC",
    "access": "public",
    "description": "Alias for {@link start} except that you can supply the path to the WARC file to be parsed\nif one was not supplied via the constructor or to parse another WARC file. If the path to WARC file\nto be parsed was supplied via the constructor and you supply a different path to this method.\nIt will override the one supplied via the constructor",
    "lineNumber": 124,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "wp",
        "description": "path to the WARC file to be parsed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "indication if the parser has begun or is currently parsing a WARC file"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the path to the WARC file is null or undefined or another error occurred"
      }
    ]
  },
  {
    "__docId__": 122,
    "kind": "file",
    "name": "lib/parsers/warcStreamTransform.js",
    "content": "'use strict'\nconst { Transform } = require('stream')\nconst RecordBuilder = require('../warcRecord/builder')\nconst { crlf } = require('../warcRecord/fieldIdentifiers')\n\n/**\n * @desc Transforms a WARC file ReadStream into its individual {@link WARCRecord}s\n * @extends {Transform}\n * @example\n *  fs.createReadStream('someWARC.warc')\n *    .pipe(new WARCStreamTransform())\n *    .on('data', record => { console.log(record) })\n * @example\n *  fs.createReadStream('someWARC.warc.gz')\n *    .pipe(zlib.createGunzip())\n *    .pipe(new WARCStreamTransform())\n *    .on('data', record => { console.log(record) })\n */\nclass WARCStreamTransform extends Transform {\n  /**\n   * @desc Create a new WARCStreamTransform\n   */\n  constructor () {\n    super({\n      readableObjectMode: true\n    })\n    /**\n     * @type {?Buffer}\n     */\n    this.buffered = undefined\n\n    /**\n     * @type {RecordBuilder}\n     */\n    this.builder = new RecordBuilder()\n\n    /**\n     * @type {number}\n     */\n    this.sepLen = crlf.length\n  }\n\n  /**\n   * @desc Process the supplied chunk\n   * @param {Buffer} chunk  - The chunk to be processed\n   * @param {function} done - Function used to indicate we are done processing the chunk\n   * @param {boolean} [pushLast] - Boolean indicating if we attempt to build a record and push it once\n   * we are done processing the chunk IFF a record was built. Is only true when called from {@link _flush}\n   * @private\n   */\n  _consumeChunk (chunk, done, pushLast) {\n    let offset = 0\n    let lastMatch = 0\n    let idx\n    let maybeRecord\n    let chunkLen = chunk.length\n    while (true) {\n      idx = offset >= chunkLen ? -1 : chunk.indexOf(crlf, offset)\n      if (idx !== -1 && idx < chunk.length) {\n        maybeRecord = this.builder.consumeLine(\n          chunk.slice(lastMatch, idx + this.sepLen)\n        )\n        if (maybeRecord != null) this.push(maybeRecord)\n        offset = idx + this.sepLen\n        lastMatch = offset\n      } else {\n        this.buffered = chunk.slice(lastMatch)\n        if (pushLast) {\n          maybeRecord = this.builder.consumeLine(this.buffered)\n          if (maybeRecord) {\n            this.push(maybeRecord)\n          }\n          maybeRecord = this.builder.buildRecord()\n          if (maybeRecord) {\n            this.push(maybeRecord)\n          }\n        }\n        break\n      }\n    }\n    done()\n  }\n\n  /**\n   * @desc Process a chunk\n   * @param {Buffer} buf - The chunk to be processed\n   * @param {string} enc - The encoding of the chunk\n   * @param {function} done - Function used to indicate we are done processing the chunk\n   * @private\n   */\n  _transform (buf, enc, done) {\n    let chunk\n    if (this.buffered) {\n      chunk = Buffer.concat(\n        [this.buffered, buf],\n        this.buffered.length + buf.length\n      )\n      this.buffered = undefined\n    } else {\n      chunk = buf\n    }\n    this._consumeChunk(chunk, done)\n  }\n\n  /**\n   * @desc Flushes any remaining data\n   * @param {function} done - Function used to indicate we are done processing the chunk\n   * @private\n   */\n  _flush (done) {\n    if (this.buffered) {\n      this._consumeChunk(this.buffered, done, true)\n    }\n    done()\n  }\n}\n\n/**\n * @type {WARCStreamTransform}\n */\nmodule.exports = WARCStreamTransform\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/parsers/warcStreamTransform.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 123,
    "kind": "class",
    "name": "WARCStreamTransform",
    "memberof": "lib/parsers/warcStreamTransform.js",
    "static": true,
    "longname": "lib/parsers/warcStreamTransform.js~WARCStreamTransform",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/parsers/warcStreamTransform.js",
    "importStyle": "WARCStreamTransform",
    "description": "Transforms a WARC file ReadStream into its individual {@link WARCRecord}s",
    "examples": [
      " fs.createReadStream('someWARC.warc')\n   .pipe(new WARCStreamTransform())\n   .on('data', record => { console.log(record) })",
      " fs.createReadStream('someWARC.warc.gz')\n   .pipe(zlib.createGunzip())\n   .pipe(new WARCStreamTransform())\n   .on('data', record => { console.log(record) })"
    ],
    "lineNumber": 19,
    "interface": false,
    "extends": [
      "Transform"
    ]
  },
  {
    "__docId__": 124,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parsers/warcStreamTransform.js~WARCStreamTransform",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcStreamTransform.js~WARCStreamTransform#constructor",
    "access": "public",
    "description": "Create a new WARCStreamTransform",
    "lineNumber": 23
  },
  {
    "__docId__": 125,
    "kind": "member",
    "name": "buffered",
    "memberof": "lib/parsers/warcStreamTransform.js~WARCStreamTransform",
    "static": false,
    "longname": "lib/parsers/warcStreamTransform.js~WARCStreamTransform#buffered",
    "access": "public",
    "description": "",
    "lineNumber": 30,
    "type": {
      "nullable": true,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 126,
    "kind": "member",
    "name": "builder",
    "memberof": "lib/parsers/warcStreamTransform.js~WARCStreamTransform",
    "static": false,
    "longname": "lib/parsers/warcStreamTransform.js~WARCStreamTransform#builder",
    "access": "public",
    "description": "",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "RecordBuilder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 127,
    "kind": "member",
    "name": "sepLen",
    "memberof": "lib/parsers/warcStreamTransform.js~WARCStreamTransform",
    "static": false,
    "longname": "lib/parsers/warcStreamTransform.js~WARCStreamTransform#sepLen",
    "access": "public",
    "description": "",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "_consumeChunk",
    "memberof": "lib/parsers/warcStreamTransform.js~WARCStreamTransform",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcStreamTransform.js~WARCStreamTransform#_consumeChunk",
    "access": "private",
    "description": "Process the supplied chunk",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "chunk",
        "description": "The chunk to be processed"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "done",
        "description": "Function used to indicate we are done processing the chunk"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "pushLast",
        "description": "Boolean indicating if we attempt to build a record and push it once\nwe are done processing the chunk IFF a record was built. Is only true when called from {@link _flush}"
      }
    ],
    "return": null
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "_transform",
    "memberof": "lib/parsers/warcStreamTransform.js~WARCStreamTransform",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcStreamTransform.js~WARCStreamTransform#_transform",
    "access": "private",
    "description": "Process a chunk",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "buf",
        "description": "The chunk to be processed"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "enc",
        "description": "The encoding of the chunk"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "done",
        "description": "Function used to indicate we are done processing the chunk"
      }
    ],
    "return": null
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "_flush",
    "memberof": "lib/parsers/warcStreamTransform.js~WARCStreamTransform",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parsers/warcStreamTransform.js~WARCStreamTransform#_flush",
    "access": "private",
    "description": "Flushes any remaining data",
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "done",
        "description": "Function used to indicate we are done processing the chunk"
      }
    ],
    "return": null
  },
  {
    "__docId__": 133,
    "kind": "file",
    "name": "lib/requestCapturers/capturedRequest.js",
    "content": "const uuid = require('uuid/v1')\nconst CDPRequestInfo = require('./cdpRequestInfo')\n\n/**\n * @type {symbol}\n */\nconst isReq = Symbol('is_request')\n/**\n * @type {symbol}\n */\nconst isRedir = Symbol('is_redirection')\n/**\n * @type {symbol}\n */\nconst isRes = Symbol('is_response')\n\n/**\n * @desc Determine the type of the request\n * @param {Object} info\n * @return {symbol}\n */\nfunction determinRequestType (info) {\n  if (info.redirectResponse != null) {\n    return isRedir\n  } else if (info.request != null) {\n    return isReq\n  }\n  return isRes\n}\n\n/**\n * @desc Represents A Unique Request And Response Chain As Made By A Page\n * Consolidates The Modification Of HTTP/2 Into HTTP/1.1\n * Provides Utility Functionality For Serialization To WARC\n */\nclass CapturedRequest {\n  /**\n   * @param {Object} info - The object received from Network.requestWillBeSent or Network.responseReceived\n   */\n  constructor (info) {\n    /**\n     * @type {string}\n     */\n    this.requestId = info.requestId\n\n    /**\n     * @type {Map<string, CDPRequestInfo>}\n     */\n    this._reqs = new Map()\n    let rt = determinRequestType(info)\n    if (rt === isRedir) {\n      // redirection create response RequestInfo for redirect and request\n      let redirCR = CDPRequestInfo.fromRedir(info)\n      let cr = CDPRequestInfo.fromRequest(info)\n      this._reqs.set(redirCR.url, redirCR)\n      this._reqs.set(cr.url, cr)\n    } else if (rt === isReq) {\n      this._reqs.set(info.request.url, CDPRequestInfo.fromRequest(info))\n    } else {\n      this._reqs.set(info.response.url, CDPRequestInfo.fromResponse(info))\n    }\n  }\n\n  /**\n   * @desc Create a new CapturedRequest\n   * @param {Object} info - The object received from Network.requestWillBeSent or Network.responseReceived\n   * @return {CapturedRequest}\n   */\n  static newOne (info) {\n    return new CapturedRequest(info)\n  }\n\n  /**\n   * @desc Add request information\n   * @param {Object} info - The object received from Network.requestWillBeSent or Network.responseReceived\n   */\n  addRequestInfo (info) {\n    let rt = determinRequestType(info)\n    if (rt === isRedir) {\n      let haveRedir = this._reqs.has(info.redirectResponse.url)\n      if (haveRedir) {\n        this._reqs\n          .get(info.redirectResponse.url)\n          .addResponse(info.redirectResponse, false)\n      } else {\n        this._reqs.set(\n          info.redirectResponse.url,\n          CDPRequestInfo.fromRedir(info)\n        )\n      }\n      this._reqs.set(info.request.url, CDPRequestInfo.fromRequest(info))\n    } else if (rt === isReq) {\n      if (this._reqs.has(info.request.url)) {\n        this._reqs.set(\n          `${info.request.url}${uuid()}`,\n          CDPRequestInfo.fromRequest(info)\n        )\n      } else {\n        this._reqs.set(info.request.url, CDPRequestInfo.fromRequest(info))\n      }\n    } else {\n      if (!this._reqs.has(info.response.url)) {\n        this._reqs.set(info.response.url, CDPRequestInfo.fromResponse(info))\n      } else {\n        this._reqs.get(info.response.url).addResponse(info.response)\n      }\n    }\n  }\n\n  /**\n   * @desc Iterate over the RequestInfo associated with the CapturedRequests#requestId\n   * @return {Iterator<CDPRequestInfo>}\n   */\n  [Symbol.iterator] () {\n    return this._reqs.values()\n  }\n\n  /**\n   *\n   * @return {string|Array<string>}\n   */\n  url () {\n    let urls = Array.from(this._reqs.keys())\n    if (urls.length === 1) {\n      return urls[0]\n    }\n    return urls\n  }\n\n  /**\n   * @desc Iterate over the RequestInfo#url associated with the CapturedRequests#requestId\n   * @return {Iterator<string>}\n   */\n  keys () {\n    return this._reqs.keys()\n  }\n\n  /**\n   * @desc Iterate over the CDPRequestInfo associated with the CapturedRequests#requestId\n   * @return {Iterator<CDPRequestInfo>}\n   */\n  values () {\n    return this._reqs.values()\n  }\n}\n\n/**\n * @type {CapturedRequest}\n */\nmodule.exports = CapturedRequest\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/requestCapturers/capturedRequest.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 134,
    "kind": "variable",
    "name": "isReq",
    "memberof": "lib/requestCapturers/capturedRequest.js",
    "static": true,
    "longname": "lib/requestCapturers/capturedRequest.js~isReq",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/requestCapturers/capturedRequest.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 7,
    "type": {
      "nullable": null,
      "types": [
        "symbol"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 135,
    "kind": "variable",
    "name": "isRedir",
    "memberof": "lib/requestCapturers/capturedRequest.js",
    "static": true,
    "longname": "lib/requestCapturers/capturedRequest.js~isRedir",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/requestCapturers/capturedRequest.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 11,
    "type": {
      "nullable": null,
      "types": [
        "symbol"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 136,
    "kind": "variable",
    "name": "isRes",
    "memberof": "lib/requestCapturers/capturedRequest.js",
    "static": true,
    "longname": "lib/requestCapturers/capturedRequest.js~isRes",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/requestCapturers/capturedRequest.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 15,
    "type": {
      "nullable": null,
      "types": [
        "symbol"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 137,
    "kind": "function",
    "name": "determinRequestType",
    "memberof": "lib/requestCapturers/capturedRequest.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/requestCapturers/capturedRequest.js~determinRequestType",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/requestCapturers/capturedRequest.js",
    "importStyle": null,
    "description": "Determine the type of the request",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "symbol"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 138,
    "kind": "class",
    "name": "CapturedRequest",
    "memberof": "lib/requestCapturers/capturedRequest.js",
    "static": true,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/requestCapturers/capturedRequest.js",
    "importStyle": "CapturedRequest",
    "description": "Represents A Unique Request And Response Chain As Made By A Page\nConsolidates The Modification Of HTTP/2 Into HTTP/1.1\nProvides Utility Functionality For Serialization To WARC",
    "lineNumber": 36,
    "interface": false
  },
  {
    "__docId__": 139,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "The object received from Network.requestWillBeSent or Network.responseReceived"
      }
    ]
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "requestId",
    "memberof": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "static": false,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest#requestId",
    "access": "public",
    "description": "",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "_reqs",
    "memberof": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "static": false,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest#_reqs",
    "access": "private",
    "description": "",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "Map<string, CDPRequestInfo>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "newOne",
    "memberof": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest.newOne",
    "access": "public",
    "description": "Create a new CapturedRequest",
    "lineNumber": 69,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "The object received from Network.requestWillBeSent or Network.responseReceived"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CapturedRequest"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "addRequestInfo",
    "memberof": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest#addRequestInfo",
    "access": "public",
    "description": "Add request information",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "The object received from Network.requestWillBeSent or Network.responseReceived"
      }
    ],
    "return": null
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest#[Symbol.iterator]",
    "access": "public",
    "description": "Iterate over the RequestInfo associated with the CapturedRequests#requestId",
    "lineNumber": 114,
    "return": {
      "nullable": null,
      "types": [
        "Iterator<CDPRequestInfo>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "url",
    "memberof": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest#url",
    "access": "public",
    "description": "",
    "lineNumber": 122,
    "return": {
      "nullable": null,
      "types": [
        "string",
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "keys",
    "memberof": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest#keys",
    "access": "public",
    "description": "Iterate over the RequestInfo#url associated with the CapturedRequests#requestId",
    "lineNumber": 134,
    "return": {
      "nullable": null,
      "types": [
        "Iterator<string>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "values",
    "memberof": "lib/requestCapturers/capturedRequest.js~CapturedRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/capturedRequest.js~CapturedRequest#values",
    "access": "public",
    "description": "Iterate over the CDPRequestInfo associated with the CapturedRequests#requestId",
    "lineNumber": 142,
    "return": {
      "nullable": null,
      "types": [
        "Iterator<CDPRequestInfo>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 148,
    "kind": "file",
    "name": "lib/requestCapturers/cdpRequestInfo.js",
    "content": "const { STATUS_CODES } = require('http')\nconst { URL } = require('url')\nconst {\n  canReplayProtocols,\n  SPACE,\n  HTTP1D1,\n  H2Method\n} = require('../utils/constants')\nconst { CRLF } = require('../writers/warcFields')\nconst { stringifyHeaders } = require('../utils/headerSerializers')\n\n/**\n * @type {string}\n */\nconst HeaderTrailers = `${CRLF}${CRLF}`\n\n/**\n * @desc Represents a request and response\n */\nclass CDPRequestInfo {\n  /**\n   * @desc Construct a new CDPRequestInfo\n   */\n  constructor () {\n    /**\n     * @desc The id of the request\n     * @type {?string}\n     */\n    this.requestId = undefined\n\n    /**\n     * @desc The URL of the request. May not contain the fragment\n     * portion of the the URL if it had a fragment depending on if the\n     * representation of URL returned by the CDP separates it.\n     * @type {?string}\n     */\n    this._url = undefined\n\n    /**\n     * @desc The fragment portion of the requests URL.\n     * Only defined if representation of the URL returned by the CDP\n     * has this property.\n     * @type {?string}\n     */\n    this.urlFragment = undefined\n\n    /**\n     * @desc The HTTP method used to make this request\n     * @type {?string}\n     */\n    this.method = undefined\n\n    /**\n     * @desc The HTTP protocol used to make this request\n     * @type {?string}\n     */\n    this.protocol = undefined\n\n    /**\n     * @desc The HTTP status of the response\n     * @type {string|number}\n     */\n    this.status = undefined\n\n    /**\n     * @desc The HTTP status reasons text of the response\n     * @type {string}\n     */\n    this.statusText = undefined\n\n    /**\n     * @desc The post data of the request if any was sent\n     * @type {?string}\n     */\n    this.postData = undefined\n\n    /**\n     * @desc The request HTTP headers object on the CDP Response object\n     * @type {?Object}\n     */\n    this.requestHeaders = undefined\n\n    /**\n     * @desc The request HTTP headers object on the CDP Request object\n     * @type {?Object}\n     */\n    this.requestHeaders_ = undefined\n\n    /**\n     * @desc The raw request HTTP header string on the CDP Response object\n     * @type {string}\n     */\n    this.requestHeadersText = undefined\n\n    /**\n     * @desc The response HTTP header object on the CDP Response object\n     * @type {?Object}\n     */\n    this.responseHeaders = undefined\n\n    /**\n     * @desc The raw response HTTP header string on the CDP Response object\n     * @type {string}\n     */\n    this.responseHeadersText = undefined\n\n    /**\n     * @desc Boolean indicating if the response body should be retrieved\n     * @type {boolean}\n     */\n    this.getBody = false\n\n    /**\n     * @desc Boolean indicating if the requests post data should be retrieved\n     * @type {boolean}\n     */\n    this.hasPostData = false\n  }\n\n  /**\n   * @desc Create a new RequestInfo from a request\n   * @param {Object} info - The object received from Network.requestWillBeSent\n   * @return {CDPRequestInfo}\n   */\n  static fromRequest (info) {\n    const cr = new CDPRequestInfo()\n    cr.requestId = info.requestId\n    cr._url = info.request.url\n    cr.urlFragment = info.request.urlFragment\n    cr.method = info.request.method\n    cr.requestHeaders_ = info.request.headers\n    cr.postData = info.request.postData\n    cr.hasPostData = info.request.hasPostData\n    return cr\n  }\n\n  /**\n   * @desc Create a new RequestInfo from a request that redirected\n   * @param {Object} info - The object received from Network.requestWillBeSent\n   * @return {CDPRequestInfo}\n   */\n  static fromRedir (info) {\n    const redirCR = new CDPRequestInfo()\n    redirCR.requestId = info.requestId\n    redirCR._url = info.redirectResponse.url\n    redirCR.method = info.request.method\n    redirCR.requestHeaders = info.redirectResponse.requestHeaders\n    redirCR.requestHeadersText = info.redirectResponse.requestHeadersText\n    redirCR.responseHeaders = info.redirectResponse.headers\n    redirCR.responseHeadersText = info.redirectResponse.headersText\n    redirCR.status = info.redirectResponse.status\n    redirCR.statusText = info.redirectResponse.statusText\n    redirCR.protocol = info.redirectResponse.protocol\n    return redirCR\n  }\n\n  /**\n   * @desc Create a new RequestInfo from a response\n   * @param {Object} info - The object received from Network.responseReceived\n   * @return {CDPRequestInfo}\n   */\n  static fromResponse (info) {\n    const cr = new CDPRequestInfo()\n    cr.requestId = info.requestId\n    cr._url = info.response.url\n    cr.requestHeaders = info.response.requestHeaders\n    cr.requestHeadersText = info.response.requestHeadersText\n    cr.responseHeaders = info.response.headers\n    cr.responseHeadersText = info.response.headersText\n    cr.status = info.response.status\n    cr.statusText = info.response.statusText\n    cr.protocol = info.response.protocol\n    cr.getBody = true\n    return cr\n  }\n\n  /**\n   * @desc Add the requests response information\n   * @param {Object} res - The response object received from Network.responseReceived\n   * @param {boolean} [not3xx=true]\n   */\n  addResponse (res, not3xx = true) {\n    this._url = this._url || res.url\n    this.requestHeaders = res.requestHeaders\n    this.requestHeadersText = res.requestHeadersText\n    this.responseHeaders = res.headers\n    this.responseHeadersText = res.headersText\n    this.status = res.status\n    this.statusText = res.statusText\n    this.protocol = res.protocol\n    this.getBody = not3xx\n  }\n\n  /**\n   * @return {string}\n   */\n  get url () {\n    return this.urlFragment != null ? this._url + this.urlFragment : this._url\n  }\n\n  /**\n   * @desc Returns a URL object representing this requests URL\n   * @return {URL}\n   */\n  getParsedURL () {\n    return new URL(this.url)\n  }\n\n  /**\n   * @desc Returns the request headers text that is replay able\n   * @return {string}\n   * @private\n   */\n  _serializeRequestHeadersText () {\n    const fcrlfidx = this.requestHeadersText.indexOf(CRLF)\n    let fline = this.requestHeadersText.substring(0, fcrlfidx)\n    const rest = this.requestHeadersText.substring(fcrlfidx)\n    const protocol = fline.substring(fline.lastIndexOf(SPACE) + 1)\n    if (!canReplayProtocols.has(protocol)) {\n      fline = fline.replace(protocol, HTTP1D1)\n    }\n    const trailers = rest.substring(rest.length - 4)\n    return trailers === HeaderTrailers ? fline + rest : fline + rest + CRLF\n  }\n\n  /**\n   * @desc Returns the correct request header object or null if there is none\n   * @return {?Object}\n   * @private\n   */\n  _getReqHeaderObj () {\n    if (this.requestHeaders != null) {\n      return this.requestHeaders\n    }\n    if (this.requestHeaders_ != null) {\n      return this.requestHeaders_\n    }\n    return null\n  }\n\n  /**\n   * @private\n   */\n  _ensureProto () {\n    if (\n      this.protocol == null ||\n      !canReplayProtocols.has(this.protocol.toUpperCase())\n    ) {\n      this.protocol = HTTP1D1\n    }\n  }\n\n  /**\n   * @desc Serializes request headers object\n   * @return {string}\n   * @private\n   */\n  _serializeRequestHeadersObj () {\n    this._checkMethod()\n    this._ensureProto()\n    const purl = this.getParsedURL()\n    const headers = this._getReqHeaderObj()\n    const path = purl.pathname + purl.searchParams.toString() + purl.hash\n    const outString = `${this.method} ${path} ${this.protocol}${CRLF}`\n    if (headers != null) {\n      if (headers.host == null && headers.Host == null) {\n        headers.Host = purl.host\n      }\n      return outString + stringifyHeaders(headers)\n    }\n    return outString + `Host: ${purl.host}${CRLF}${CRLF}`\n  }\n\n  /**\n   * @desc Serialize the request headers for the WARC entry\n   * @return {string}\n   */\n  serializeRequestHeaders () {\n    if (this.requestHeadersText != null) {\n      return this._serializeRequestHeadersText()\n    }\n    return this._serializeRequestHeadersObj()\n  }\n\n  /**\n   * @desc Serialize the response headers for the WARC entry\n   * @return {string}\n   */\n  serializeResponseHeaders () {\n    let outString\n    if (this.responseHeadersText != null) {\n      const protocol = this.responseHeadersText.substring(\n        0,\n        this.responseHeadersText.indexOf(SPACE)\n      )\n      outString = canReplayProtocols.has(protocol)\n        ? this.responseHeadersText\n        : this.responseHeadersText.replace(protocol, HTTP1D1)\n      const trailers = outString.substring(outString.length - 4)\n      return trailers === HeaderTrailers ? outString : outString + CRLF\n    } else if (this.responseHeaders != null) {\n      this._ensureProto()\n      if (!this.statusText) {\n        this.statusText = STATUS_CODES[this.status]\n      }\n      outString = `${this.protocol} ${this.status} ${\n        this.statusText\n      }${CRLF}${stringifyHeaders(this.responseHeaders)}`\n    }\n    return outString\n  }\n\n  /**\n   * @desc Determine if we have enough information to serialize the response\n   * @return {boolean}\n   */\n  canSerializeResponse () {\n    if (this.url.indexOf('data:') === 0) return false\n    if (this.responseHeadersText != null) return true\n    return (\n      this.status != null &&\n      this.protocol != null &&\n      this.responseHeaders != null\n    )\n  }\n\n  /**\n   * @desc Ensure that the request info object has its method property set\n   * @private\n   */\n  _checkMethod () {\n    if (!this.method) {\n      let good = false\n      if (this.requestHeaders) {\n        let maybeMeth = this.requestHeaders[H2Method]\n        if (maybeMeth) {\n          this.method = maybeMeth\n          good = true\n        }\n      }\n      if (this.responseHeaders) {\n        let maybeMeth = this.responseHeaders[H2Method]\n        if (maybeMeth) {\n          this.method = maybeMeth\n          good = true\n        }\n      }\n      if (!good && this.requestHeadersText) {\n        this._methProtoFromReqHeadText(this.requestHeadersText)\n      }\n      if (this.method == null) {\n        this.method = this.postData != null || this.hasPostData ? 'POST' : 'GET'\n      }\n    }\n  }\n\n  /**\n   * @desc Set The Requests Method And Protocol From The Request Headers Text\n   * @param {?string} requestHeadersText - The Full HTTP Headers String\n   * @private\n   */\n  _methProtoFromReqHeadText (requestHeadersText) {\n    if (requestHeadersText) {\n      let httpString = requestHeadersText.substr(\n        0,\n        requestHeadersText.indexOf(CRLF)\n      )\n      if (httpString) {\n        let httpStringParts = httpString.split(SPACE)\n        if (httpStringParts) {\n          this.method = httpStringParts[0]\n          if (!this.protocol) {\n            this.protocol = this._correctProtocol(httpStringParts[2])\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @desc Ensure that the request info object has the correct protocol property\n   * @param {string} originalProtocol - The ordinal protocol of the request\n   * @return {string}\n   * @private\n   */\n  _correctProtocol (originalProtocol) {\n    let newProtocol\n    if (originalProtocol) {\n      newProtocol = originalProtocol.toUpperCase()\n      newProtocol = canReplayProtocols.has(newProtocol) ? newProtocol : HTTP1D1\n    } else {\n      newProtocol = HTTP1D1\n    }\n    if (!this.protocol) {\n      this.protocol = newProtocol\n    }\n    return newProtocol\n  }\n}\n\n/**\n * @type {CDPRequestInfo}\n */\nmodule.exports = CDPRequestInfo\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/requestCapturers/cdpRequestInfo.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 149,
    "kind": "variable",
    "name": "HeaderTrailers",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js",
    "static": true,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~HeaderTrailers",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/requestCapturers/cdpRequestInfo.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 15,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 150,
    "kind": "class",
    "name": "CDPRequestInfo",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js",
    "static": true,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/requestCapturers/cdpRequestInfo.js",
    "importStyle": "CDPRequestInfo",
    "description": "Represents a request and response",
    "lineNumber": 20,
    "interface": false
  },
  {
    "__docId__": 151,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#constructor",
    "access": "public",
    "description": "Construct a new CDPRequestInfo",
    "lineNumber": 24
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "requestId",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#requestId",
    "access": "public",
    "description": "The id of the request",
    "lineNumber": 29,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "_url",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#_url",
    "access": "private",
    "description": "The URL of the request. May not contain the fragment\nportion of the the URL if it had a fragment depending on if the\nrepresentation of URL returned by the CDP separates it.",
    "lineNumber": 37,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "urlFragment",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#urlFragment",
    "access": "public",
    "description": "The fragment portion of the requests URL.\nOnly defined if representation of the URL returned by the CDP\nhas this property.",
    "lineNumber": 45,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "method",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#method",
    "access": "public",
    "description": "The HTTP method used to make this request",
    "lineNumber": 51,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 156,
    "kind": "member",
    "name": "protocol",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#protocol",
    "access": "public",
    "description": "The HTTP protocol used to make this request",
    "lineNumber": 57,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 157,
    "kind": "member",
    "name": "status",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#status",
    "access": "public",
    "description": "The HTTP status of the response",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "string",
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 158,
    "kind": "member",
    "name": "statusText",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#statusText",
    "access": "public",
    "description": "The HTTP status reasons text of the response",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "postData",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#postData",
    "access": "public",
    "description": "The post data of the request if any was sent",
    "lineNumber": 75,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "requestHeaders",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#requestHeaders",
    "access": "public",
    "description": "The request HTTP headers object on the CDP Response object",
    "lineNumber": 81,
    "type": {
      "nullable": true,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 161,
    "kind": "member",
    "name": "requestHeaders_",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#requestHeaders_",
    "access": "public",
    "description": "The request HTTP headers object on the CDP Request object",
    "lineNumber": 87,
    "type": {
      "nullable": true,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 162,
    "kind": "member",
    "name": "requestHeadersText",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#requestHeadersText",
    "access": "public",
    "description": "The raw request HTTP header string on the CDP Response object",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 163,
    "kind": "member",
    "name": "responseHeaders",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#responseHeaders",
    "access": "public",
    "description": "The response HTTP header object on the CDP Response object",
    "lineNumber": 99,
    "type": {
      "nullable": true,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 164,
    "kind": "member",
    "name": "responseHeadersText",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#responseHeadersText",
    "access": "public",
    "description": "The raw response HTTP header string on the CDP Response object",
    "lineNumber": 105,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 165,
    "kind": "member",
    "name": "getBody",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#getBody",
    "access": "public",
    "description": "Boolean indicating if the response body should be retrieved",
    "lineNumber": 111,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "hasPostData",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#hasPostData",
    "access": "public",
    "description": "Boolean indicating if the requests post data should be retrieved",
    "lineNumber": 117,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "fromRequest",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo.fromRequest",
    "access": "public",
    "description": "Create a new RequestInfo from a request",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "The object received from Network.requestWillBeSent"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CDPRequestInfo"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "fromRedir",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo.fromRedir",
    "access": "public",
    "description": "Create a new RequestInfo from a request that redirected",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "The object received from Network.requestWillBeSent"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CDPRequestInfo"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "fromResponse",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo.fromResponse",
    "access": "public",
    "description": "Create a new RequestInfo from a response",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "The object received from Network.responseReceived"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CDPRequestInfo"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "addResponse",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#addResponse",
    "access": "public",
    "description": "Add the requests response information",
    "lineNumber": 182,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "res",
        "description": "The response object received from Network.responseReceived"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "not3xx",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 180,
    "kind": "get",
    "name": "url",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#url",
    "access": "public",
    "description": "",
    "lineNumber": 197,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "getParsedURL",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#getParsedURL",
    "access": "public",
    "description": "Returns a URL object representing this requests URL",
    "lineNumber": 205,
    "return": {
      "nullable": null,
      "types": [
        "URL"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "_serializeRequestHeadersText",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#_serializeRequestHeadersText",
    "access": "private",
    "description": "Returns the request headers text that is replay able",
    "lineNumber": 214,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "_getReqHeaderObj",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#_getReqHeaderObj",
    "access": "private",
    "description": "Returns the correct request header object or null if there is none",
    "lineNumber": 231,
    "return": {
      "nullable": true,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "_ensureProto",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#_ensureProto",
    "access": "private",
    "description": "",
    "lineNumber": 244,
    "params": [],
    "return": null
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "_serializeRequestHeadersObj",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#_serializeRequestHeadersObj",
    "access": "private",
    "description": "Serializes request headers object",
    "lineNumber": 258,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "serializeRequestHeaders",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#serializeRequestHeaders",
    "access": "public",
    "description": "Serialize the request headers for the WARC entry",
    "lineNumber": 278,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "serializeResponseHeaders",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#serializeResponseHeaders",
    "access": "public",
    "description": "Serialize the response headers for the WARC entry",
    "lineNumber": 289,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "canSerializeResponse",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#canSerializeResponse",
    "access": "public",
    "description": "Determine if we have enough information to serialize the response",
    "lineNumber": 317,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "_checkMethod",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#_checkMethod",
    "access": "private",
    "description": "Ensure that the request info object has its method property set",
    "lineNumber": 331,
    "params": [],
    "return": null
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "_methProtoFromReqHeadText",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#_methProtoFromReqHeadText",
    "access": "private",
    "description": "Set The Requests Method And Protocol From The Request Headers Text",
    "lineNumber": 362,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestHeadersText",
        "description": "The Full HTTP Headers String"
      }
    ],
    "return": null
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "_correctProtocol",
    "memberof": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/cdpRequestInfo.js~CDPRequestInfo#_correctProtocol",
    "access": "private",
    "description": "Ensure that the request info object has the correct protocol property",
    "lineNumber": 386,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "originalProtocol",
        "description": "The ordinal protocol of the request"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 200,
    "kind": "file",
    "name": "lib/requestCapturers/electron.js",
    "content": "const RequestHandler = require('./requestHandler')\n\n/**\n * @extends {RequestHandler}\n * @desc The remote electron request chapturer to use along side {@link ElectronWARCGenerator}\n * See the documentation for {@link attach} and {@link maybeNetworkMessage} for setup information\n * Controlled via {@link startCapturing} and {@link stopCapturing}\n * @see https://electron.atom.io/docs/api/debugger/\n * @see https://chromedevtools.github.io/devtools-protocol/tot/Network\n */\nclass ElectronRequestCapturer extends RequestHandler {\n  /**\n   * @desc Create a new ElectronRequestCapturer\n   */\n  constructor () {\n    super()\n    /** @ignore */\n    this.maybeNetworkMessage = this.maybeNetworkMessage.bind(this)\n    /** @ignore */\n    this.attach = this.attach.bind(this)\n    /** @ignore */\n    this.requestWillBeSent = this.requestWillBeSent.bind(this)\n    /** @ignore */\n    this.responseReceived = this.responseReceived.bind(this)\n  }\n\n  /**\n   * @desc Attach to the debugger {@link requestWillBeSent} and {@link responseReceived}\n   * @param {Object} wcDebugger - the debugger\n   * @see https://electron.atom.io/docs/api/debugger/\n   */\n  attach (wcDebugger) {\n    wcDebugger.on('message', (event, method, params) => {\n      if (method === 'Network.requestWillBeSent') {\n        this.requestWillBeSent(params)\n      } else if (method === 'Network.responseReceived') {\n        this.responseReceived(params)\n      }\n    })\n  }\n\n  /**\n   * @desc Rather than adding an additional listener to the debugger pass the two relevant parameters\n   * of the listener to this method. Useful if you are already listening to some other event.\n   * {@link attach}, {@link requestWillBeSent} and {@link responseReceived}\n   * @param {string} method the event method\n   * @param {Object} params the parameters of the event\n   * @see https://electron.atom.io/docs/api/debugger/\n   */\n  maybeNetworkMessage (method, params) {\n    if (method === 'Network.requestWillBeSent') {\n      this.requestWillBeSent(params)\n    } else if (method === 'Network.responseReceived') {\n      this.responseReceived(params)\n    }\n  }\n}\n\n/**\n * @type {ElectronRequestCapturer}\n */\nmodule.exports = ElectronRequestCapturer\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/requestCapturers/electron.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 201,
    "kind": "class",
    "name": "ElectronRequestCapturer",
    "memberof": "lib/requestCapturers/electron.js",
    "static": true,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/requestCapturers/electron.js",
    "importStyle": "ElectronRequestCapturer",
    "description": "The remote electron request chapturer to use along side {@link ElectronWARCGenerator}\nSee the documentation for {@link attach} and {@link maybeNetworkMessage} for setup information\nControlled via {@link startCapturing} and {@link stopCapturing}",
    "see": [
      "https://electron.atom.io/docs/api/debugger/",
      "https://chromedevtools.github.io/devtools-protocol/tot/Network"
    ],
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "RequestHandler"
    ]
  },
  {
    "__docId__": 202,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#constructor",
    "access": "public",
    "description": "Create a new ElectronRequestCapturer",
    "lineNumber": 15
  },
  {
    "__docId__": 205,
    "kind": "member",
    "name": "requestWillBeSent",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#requestWillBeSent",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "member",
    "name": "responseReceived",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#responseReceived",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "attach",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#attach",
    "access": "public",
    "description": "Attach to the debugger {@link requestWillBeSent} and {@link responseReceived}",
    "see": [
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the debugger"
      }
    ],
    "return": null
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "maybeNetworkMessage",
    "memberof": "lib/requestCapturers/electron.js~ElectronRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/electron.js~ElectronRequestCapturer#maybeNetworkMessage",
    "access": "public",
    "description": "Rather than adding an additional listener to the debugger pass the two relevant parameters\nof the listener to this method. Useful if you are already listening to some other event.\n{@link attach}, {@link requestWillBeSent} and {@link responseReceived}",
    "see": [
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "the event method"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "the parameters of the event"
      }
    ],
    "return": null
  },
  {
    "__docId__": 209,
    "kind": "file",
    "name": "lib/requestCapturers/index.js",
    "content": "/**\n * @type {{ElectronCapturer: ElectronRequestCapturer, RemoteChromeCapturer: RemoteChromeRequestCapturer, PuppeteerCDPCapturer: PuppeteerCDPRequestCapturer, PuppeteerCapturer: PuppeteerRequestCapturer, CDPRequestInfo: CDPRequestInfo, CapturedRequest: CapturedRequest, RequestHandler: RequestHandler}}\n */\nmodule.exports = {\n  ElectronCapturer: require('./electron'),\n  RemoteChromeCapturer: require('./remoteChrome'),\n  PuppeteerCDPCapturer: require('./puppeteerCDP'),\n  PuppeteerCapturer: require('./puppeteer'),\n  CDPRequestInfo: require('./cdpRequestInfo'),\n  CapturedRequest: require('./capturedRequest'),\n  RequestHandler: require('./requestHandler')\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/requestCapturers/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 210,
    "kind": "file",
    "name": "lib/requestCapturers/puppeteer.js",
    "content": "/**\n * @desc Puppeteer Request Capturer\n */\nclass PuppeteerRequestCapturer {\n  /**\n   * @param {?Page} [page] - The puppeteer page object\n   */\n  constructor (page) {\n    /**\n     * @desc To Capture Requests Or Not To Capture Requests\n     * @type {boolean}\n     * @private\n     */\n    this._capture = true\n\n    /**\n     * @desc A list of requests made\n     * @type {Array<Request>}\n     * @private\n     */\n    this._requests = []\n\n    this.requestWillBeSent = this.requestWillBeSent.bind(this)\n    this.attach(page)\n  }\n\n  attach (page) {\n    page.on('request', this.requestWillBeSent)\n  }\n\n  detach (page) {\n    page.removeListener('request', this.requestWillBeSent)\n  }\n\n  /**\n   * @desc Sets an internal flag to begin capturing network requests. Clears Any Previously Captured Request Information\n   */\n  startCapturing () {\n    this._requests.length = 0\n    this._capture = true\n  }\n\n  /**\n   * @desc Sets an internal flag to stop the capturing network requests\n   */\n  stopCapturing () {\n    this._capture = false\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n   * @desc Get An Iterator Over The Requests Captured\n   * @returns {Iterator<Request>}\n   */\n  [Symbol.iterator] () {\n    return this._requests[Symbol.iterator]()\n  }\n\n  /**\n   * @desc Remove All Requests\n   */\n  clear () {\n    this._requests.length = 0\n  }\n\n  /**\n   * @returns {Array<Request>}\n   */\n  requests () {\n    return this._requests\n  }\n\n  /**\n   * @return {Iterator<Request>}\n   */\n  * iterateRequests () {\n    let i = 0\n    let len = this._requests.length\n    for (; i < len; i++) {\n      yield this._requests[i]\n    }\n  }\n\n  /**\n   * @param {Request} r\n   */\n  requestWillBeSent (r) {\n    if (this._capture) {\n      this._requests.push(r)\n    }\n  }\n}\n\n/**\n * @type {PuppeteerRequestCapturer}\n */\nmodule.exports = PuppeteerRequestCapturer\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/requestCapturers/puppeteer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 211,
    "kind": "class",
    "name": "PuppeteerRequestCapturer",
    "memberof": "lib/requestCapturers/puppeteer.js",
    "static": true,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/requestCapturers/puppeteer.js",
    "importStyle": "PuppeteerRequestCapturer",
    "description": "Puppeteer Request Capturer",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 212,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 8,
    "params": [
      {
        "nullable": true,
        "types": [
          "Page"
        ],
        "spread": false,
        "optional": true,
        "name": "page",
        "description": "The puppeteer page object"
      }
    ]
  },
  {
    "__docId__": 213,
    "kind": "member",
    "name": "_capture",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#_capture",
    "access": "private",
    "description": "To Capture Requests Or Not To Capture Requests",
    "lineNumber": 14,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "_requests",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#_requests",
    "access": "private",
    "description": "A list of requests made",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Array<Request>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "attach",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#attach",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "page",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "detach",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#detach",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "page",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "startCapturing",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#startCapturing",
    "access": "public",
    "description": "Sets an internal flag to begin capturing network requests. Clears Any Previously Captured Request Information",
    "lineNumber": 38,
    "params": [],
    "return": null
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "stopCapturing",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#stopCapturing",
    "access": "public",
    "description": "Sets an internal flag to stop the capturing network requests",
    "lineNumber": 46,
    "params": [],
    "return": null
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#[Symbol.iterator]",
    "access": "public",
    "description": "Get An Iterator Over The Requests Captured",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator"
    ],
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator<Request>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator<Request>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "clear",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#clear",
    "access": "public",
    "description": "Remove All Requests",
    "lineNumber": 62,
    "params": [],
    "return": null
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "requests",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#requests",
    "access": "public",
    "description": "",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Request>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Request>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "iterateRequests",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#iterateRequests",
    "access": "public",
    "description": "",
    "lineNumber": 76,
    "return": {
      "nullable": null,
      "types": [
        "Iterator<Request>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "requestWillBeSent",
    "memberof": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteer.js~PuppeteerRequestCapturer#requestWillBeSent",
    "access": "public",
    "description": "",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "Request"
        ],
        "spread": false,
        "optional": false,
        "name": "r",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 227,
    "kind": "file",
    "name": "lib/requestCapturers/puppeteerCDP.js",
    "content": "const RequestHandler = require('./requestHandler')\n\n/**\n * @extends {RequestHandler}\n */\nclass PuppeteerCDPRequestCapturer extends RequestHandler {\n  /**\n   * @param {?CDPSession} [client] - The CDPSession client to be attached to\n   */\n  constructor (client) {\n    super()\n    this.requestWillBeSent = this.requestWillBeSent.bind(this)\n    this.responseReceived = this.responseReceived.bind(this)\n    this.attach(client)\n  }\n\n  /**\n   * @param {CDPSession} client - The CDPSession client to be attached to\n   */\n  attach (client) {\n    if (client) {\n      client.on('Network.requestWillBeSent', this.requestWillBeSent)\n      client.on('Network.responseReceived', this.responseReceived)\n    }\n  }\n\n  /**\n   * @param {CDPSession} client - The CDPSession client to detach from\n   */\n  detach (client) {\n    if (client) {\n      client.removeListener('Network.requestWillBeSent', this.requestWillBeSent)\n      client.removeListener('Network.responseReceived', this.responseReceived)\n    }\n  }\n}\n\n/**\n * @type {PuppeteerCDPRequestCapturer}\n */\nmodule.exports = PuppeteerCDPRequestCapturer\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/requestCapturers/puppeteerCDP.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 228,
    "kind": "class",
    "name": "PuppeteerCDPRequestCapturer",
    "memberof": "lib/requestCapturers/puppeteerCDP.js",
    "static": true,
    "longname": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/requestCapturers/puppeteerCDP.js",
    "importStyle": "PuppeteerCDPRequestCapturer",
    "description": "",
    "lineNumber": 6,
    "interface": false,
    "extends": [
      "RequestHandler"
    ]
  },
  {
    "__docId__": 229,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 10,
    "params": [
      {
        "nullable": true,
        "types": [
          "CDPSession"
        ],
        "spread": false,
        "optional": true,
        "name": "client",
        "description": "The CDPSession client to be attached to"
      }
    ]
  },
  {
    "__docId__": 230,
    "kind": "member",
    "name": "requestWillBeSent",
    "memberof": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer#requestWillBeSent",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "member",
    "name": "responseReceived",
    "memberof": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer#responseReceived",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "attach",
    "memberof": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer#attach",
    "access": "public",
    "description": "",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "CDPSession"
        ],
        "spread": false,
        "optional": false,
        "name": "client",
        "description": "The CDPSession client to be attached to"
      }
    ],
    "return": null
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "detach",
    "memberof": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/puppeteerCDP.js~PuppeteerCDPRequestCapturer#detach",
    "access": "public",
    "description": "",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "CDPSession"
        ],
        "spread": false,
        "optional": false,
        "name": "client",
        "description": "The CDPSession client to detach from"
      }
    ],
    "return": null
  },
  {
    "__docId__": 234,
    "kind": "file",
    "name": "lib/requestCapturers/remoteChrome.js",
    "content": "const RequestHandler = require('./requestHandler')\n\n/**\n * @extends {RequestHandler}\n * @desc The remote chrome request chapturer to use along side {@link RemoteChromeWARCGenerator}\n * The only setup required is to pass the chrome-remote-interface Network object\n * Controlled via {@link startCapturing} and {@link stopCapturing}\n * @see https://github.com/cyrus-and/chrome-remote-interface\n * @see https://chromedevtools.github.io/devtools-protocol/tot/Network\n */\nclass RemoteChromeRequestCapturer extends RequestHandler {\n  /**\n   * @param {?Object} [network] - The chrome-remote-interface Network object\n   */\n  constructor (network) {\n    super()\n    this.requestWillBeSent = this.requestWillBeSent.bind(this)\n    this.responseReceived = this.responseReceived.bind(this)\n    this.attach(network)\n  }\n\n  /**\n   * @param {Object} network - The chrome-remote-interface Network object to be attached to\n   */\n  attach (network) {\n    if (network) {\n      network.requestWillBeSent(this.requestWillBeSent)\n      network.responseReceived(this.responseReceived)\n    }\n  }\n\n  /**\n   * @param {Object} cdpClient - The chrome-remote-interface client object to detach from\n   */\n  detach (cdpClient) {\n    if (cdpClient) {\n      cdpClient.removeListener('Network.requestWillBeSent', this.requestWillBeSent)\n      cdpClient.removeListener('Network.responseReceived', this.responseReceived)\n    }\n  }\n}\n\n/**\n * @type {RemoteChromeRequestCapturer}\n */\nmodule.exports = RemoteChromeRequestCapturer\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/requestCapturers/remoteChrome.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 235,
    "kind": "class",
    "name": "RemoteChromeRequestCapturer",
    "memberof": "lib/requestCapturers/remoteChrome.js",
    "static": true,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/requestCapturers/remoteChrome.js",
    "importStyle": "RemoteChromeRequestCapturer",
    "description": "The remote chrome request chapturer to use along side {@link RemoteChromeWARCGenerator}\nThe only setup required is to pass the chrome-remote-interface Network object\nControlled via {@link startCapturing} and {@link stopCapturing}",
    "see": [
      "https://github.com/cyrus-and/chrome-remote-interface",
      "https://chromedevtools.github.io/devtools-protocol/tot/Network"
    ],
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "RequestHandler"
    ]
  },
  {
    "__docId__": 236,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 15,
    "params": [
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "network",
        "description": "The chrome-remote-interface Network object"
      }
    ]
  },
  {
    "__docId__": 237,
    "kind": "member",
    "name": "requestWillBeSent",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#requestWillBeSent",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "member",
    "name": "responseReceived",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#responseReceived",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "attach",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#attach",
    "access": "public",
    "description": "",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "The chrome-remote-interface Network object to be attached to"
      }
    ],
    "return": null
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "detach",
    "memberof": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/remoteChrome.js~RemoteChromeRequestCapturer#detach",
    "access": "public",
    "description": "",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "cdpClient",
        "description": "The chrome-remote-interface client object to detach from"
      }
    ],
    "return": null
  },
  {
    "__docId__": 241,
    "kind": "file",
    "name": "lib/requestCapturers/requestHandler.js",
    "content": "const CapturedRequest = require('./capturedRequest')\n\n/**\n * Class Responsible For Managing The Captured Request / Responses For A Page\n */\nclass RequestHandler {\n  /**\n   * @desc Create A New RequestHandler\n   */\n  constructor () {\n    /**\n     * @desc To Capture Requests Or Not To Capture Requests\n     * @type {boolean}\n     * @private\n     */\n    this._capture = true\n\n    /**\n     * @desc Association Of RequestIds To CapturedRequests\n     * @type {Map<string,CapturedRequest>}\n     * @private\n     */\n    this._requests = new Map()\n  }\n\n  /**\n   * @desc Sets an internal flag to begin capturing network requests.\n   * Clears Any Previously Captured Request Information\n   */\n  startCapturing () {\n    this._requests.clear()\n    this._capture = true\n  }\n\n  /**\n   * @desc Sets an internal flag to stop the capturing network requests\n   */\n  stopCapturing () {\n    this._capture = false\n  }\n\n  /**\n   * @desc Handles either the Network.requestWillBeSent or the Network.responseReceived events\n   * @see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent\n   * @see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived\n   * @param {Object} info\n   */\n  addRequestInfo (info) {\n    if (this._capture) {\n      if (this._requests.has(info.requestId)) {\n        this._requests.get(info.requestId).addRequestInfo(info)\n      } else {\n        this._requests.set(info.requestId, new CapturedRequest(info))\n      }\n    }\n  }\n\n  /**\n   * @desc Handles the Network.requestWillBeSent event\n   * @see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent\n   * @param {Object} info\n   */\n  requestWillBeSent (info) {\n    if (this._capture) {\n      if (this._requests.has(info.requestId)) {\n        this._requests.get(info.requestId).addRequestInfo(info)\n      } else {\n        this._requests.set(info.requestId, new CapturedRequest(info))\n      }\n    }\n  }\n\n  /**\n   * @desc Handles the Network.responseReceived event\n   * @see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived\n   * @param {Object} info\n   */\n  responseReceived (info) {\n    if (this._capture) {\n      if (!this._requests.has(info.requestId)) {\n        this._requests.set(info.requestId, new CapturedRequest(info))\n      } else {\n        this._requests.get(info.requestId).addRequestInfo(info)\n      }\n    }\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n   * @desc Get An Iterator Over The Request Id, Request Object Pairs\n   * @returns {Iterator}\n   */\n  [Symbol.iterator] () {\n    return this._requests[Symbol.iterator]()\n  }\n\n  /**\n   * @desc Remove All Requests\n   */\n  clear () {\n    this._requests.clear()\n  }\n\n  /**\n   * @desc Does The Interceptor Have The Request Object Associated With A Request Id\n   * @param {!string} requestId\n   * @returns {boolean}\n   */\n  has (requestId) {\n    return this._requests.has(requestId)\n  }\n\n  /**\n   * @desc Retrieve The Corresponding Request Object For A Request Id\n   * @param {!string} requestId\n   * @returns {CapturedRequest}\n   */\n  get (requestId) {\n    return this._requests.get(requestId)\n  }\n\n  /**\n   * @returns {number}\n   */\n  size () {\n    return this._requests.size\n  }\n\n  /**\n   * @desc Get An Iterator Over The Request Id, Request Object Pairs\n   * @returns {Iterator}\n   */\n  entries () {\n    return this._requests.entries()\n  }\n\n  /**\n   * @desc Get An Iterator Over The Request Ids\n   * @returns {Iterator<string>}\n   */\n  keys () {\n    return this._requests.keys()\n  }\n\n  /**\n   * @desc Get An Iterator Over The Request Objects\n   * @returns {Iterator<CapturedRequest>}\n   */\n  values () {\n    return this._requests.values()\n  }\n\n  /**\n   * @desc Apply An Iteratee Once For Each Mapped Request Id, Request Object Pair\n   * @param {!function} iteratee the function to be applied\n   * @param {*} [thisArg] optional this argument\n   */\n  forEach (iteratee, thisArg) {\n    this._requests.forEach(iteratee, thisArg)\n  }\n\n  /**\n   * @return {Iterator<CDPRequestInfo>}\n   */\n  * iterateRequests () {\n    for (let cr of this._requests.values()) {\n      for (let ri of cr.values()) {\n        yield ri\n      }\n    }\n  }\n}\n\n/**\n * @type {RequestHandler}\n */\nmodule.exports = RequestHandler\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/requestCapturers/requestHandler.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 242,
    "kind": "class",
    "name": "RequestHandler",
    "memberof": "lib/requestCapturers/requestHandler.js",
    "static": true,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/requestCapturers/requestHandler.js",
    "importStyle": "RequestHandler",
    "description": "Class Responsible For Managing The Captured Request / Responses For A Page",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 243,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#constructor",
    "access": "public",
    "description": "Create A New RequestHandler",
    "lineNumber": 10
  },
  {
    "__docId__": 244,
    "kind": "member",
    "name": "_capture",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#_capture",
    "access": "private",
    "description": "To Capture Requests Or Not To Capture Requests",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 245,
    "kind": "member",
    "name": "_requests",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#_requests",
    "access": "private",
    "description": "Association Of RequestIds To CapturedRequests",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "Map<string,CapturedRequest>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 246,
    "kind": "method",
    "name": "startCapturing",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#startCapturing",
    "access": "public",
    "description": "Sets an internal flag to begin capturing network requests.\nClears Any Previously Captured Request Information",
    "lineNumber": 30,
    "params": [],
    "return": null
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "stopCapturing",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#stopCapturing",
    "access": "public",
    "description": "Sets an internal flag to stop the capturing network requests",
    "lineNumber": 38,
    "params": [],
    "return": null
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "addRequestInfo",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#addRequestInfo",
    "access": "public",
    "description": "Handles either the Network.requestWillBeSent or the Network.responseReceived events",
    "see": [
      "https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent",
      "https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived"
    ],
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "requestWillBeSent",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#requestWillBeSent",
    "access": "public",
    "description": "Handles the Network.requestWillBeSent event",
    "see": [
      "https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent"
    ],
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "responseReceived",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#responseReceived",
    "access": "public",
    "description": "Handles the Network.responseReceived event",
    "see": [
      "https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived"
    ],
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#[Symbol.iterator]",
    "access": "public",
    "description": "Get An Iterator Over The Request Id, Request Object Pairs",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator"
    ],
    "lineNumber": 93,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "clear",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#clear",
    "access": "public",
    "description": "Remove All Requests",
    "lineNumber": 100,
    "params": [],
    "return": null
  },
  {
    "__docId__": 255,
    "kind": "method",
    "name": "has",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#has",
    "access": "public",
    "description": "Does The Interceptor Have The Request Object Associated With A Request Id",
    "lineNumber": 109,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "get",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#get",
    "access": "public",
    "description": "Retrieve The Corresponding Request Object For A Request Id",
    "lineNumber": 118,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{CapturedRequest}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CapturedRequest"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "size",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#size",
    "access": "public",
    "description": "",
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "entries",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#entries",
    "access": "public",
    "description": "Get An Iterator Over The Request Id, Request Object Pairs",
    "lineNumber": 133,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 259,
    "kind": "method",
    "name": "keys",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#keys",
    "access": "public",
    "description": "Get An Iterator Over The Request Ids",
    "lineNumber": 141,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator<string>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator<string>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 260,
    "kind": "method",
    "name": "values",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#values",
    "access": "public",
    "description": "Get An Iterator Over The Request Objects",
    "lineNumber": 149,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator<CapturedRequest>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator<CapturedRequest>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 261,
    "kind": "method",
    "name": "forEach",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#forEach",
    "access": "public",
    "description": "Apply An Iteratee Once For Each Mapped Request Id, Request Object Pair",
    "lineNumber": 158,
    "params": [
      {
        "nullable": false,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "the function to be applied"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "thisArg",
        "description": "optional this argument"
      }
    ],
    "return": null
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "iterateRequests",
    "memberof": "lib/requestCapturers/requestHandler.js~RequestHandler",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "lib/requestCapturers/requestHandler.js~RequestHandler#iterateRequests",
    "access": "public",
    "description": "",
    "lineNumber": 165,
    "return": {
      "nullable": null,
      "types": [
        "Iterator<CDPRequestInfo>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 263,
    "kind": "file",
    "name": "lib/utils/constants.js",
    "content": "/**\n * @type {Set<string>}\n */\nconst canReplayProtocols = new Set([\n  'HTTP/0.9',\n  'HTTP/1.0',\n  'HTTP/1.1',\n  'DATA',\n  'data'\n])\n\n/**\n * @type {{canReplayProtocols: Set<string>, SPACE: string, H2Method: string, HTTP1D1: string, DASH: string, H2path: string}}\n */\nmodule.exports = {\n  canReplayProtocols,\n  SPACE: ' ',\n  H2Method: ':method',\n  H2path: ':path',\n  HTTP1D1: 'HTTP/1.1',\n  DASH: '-'\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/utils/constants.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 264,
    "kind": "variable",
    "name": "canReplayProtocols",
    "memberof": "lib/utils/constants.js",
    "static": true,
    "longname": "lib/utils/constants.js~canReplayProtocols",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/utils/constants.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 4,
    "type": {
      "nullable": null,
      "types": [
        "Set<string>"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 265,
    "kind": "file",
    "name": "lib/utils/electron.js",
    "content": "const isEmpty = require('lodash/isEmpty')\n\n/**\n * @desc Electron requires the use of the debugger to retrieve the requests response body\n * @param {string} requestId - the request to fetch the response body for\n * @param {Object} wcDebugger - the Electron debugger to use to get the response body\n * @see https://electron.atom.io/docs/api/debugger/\n * @return {Promise<?Buffer>} body - the response body as a node buffer\n */\nfunction getResBody (requestId, wcDebugger) {\n  return new Promise((resolve) => {\n    wcDebugger.sendCommand(\n      'Network.getResponseBody',\n      { requestId },\n      (error, body) => {\n        resolve(!isEmpty(error) ? null : body)\n      }\n    )\n  })\n}\n\n/**\n * @desc Electron requires the use of the debugger to retrieve the requests post data\n * @param {string} requestId - the request to fetch the post data for\n * @param {Object} wcDebugger - the Electron debugger to use to get the post data\n * @see https://electron.atom.io/docs/api/debugger/\n * @return {Promise<?Buffer>} body - the response body as a node buffer\n */\nfunction getPostData (requestId, wcDebugger) {\n  return new Promise((resolve) => {\n    wcDebugger.sendCommand(\n      'Network.getRequestPostData',\n      { requestId },\n      (error, body) => {\n        resolve(!isEmpty(error) ? null : body)\n      }\n    )\n  })\n}\n\nmodule.exports = {\n  /**\n   * @type {function(string, Object): Promise<?Buffer>}\n   */\n  getResBody,\n  /**\n   * @type {function(string, Object): Promise<?Buffer>}\n   */\n  getPostData\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/utils/electron.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 266,
    "kind": "function",
    "name": "getResBody",
    "memberof": "lib/utils/electron.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/electron.js~getResBody",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/utils/electron.js",
    "importStyle": null,
    "description": "Electron requires the use of the debugger to retrieve the requests response body",
    "see": [
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestId",
        "description": "the request to fetch the response body for"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the Electron debugger to use to get the response body"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<?Buffer>"
      ],
      "spread": false,
      "description": "body - the response body as a node buffer"
    },
    "ignore": true
  },
  {
    "__docId__": 267,
    "kind": "function",
    "name": "getPostData",
    "memberof": "lib/utils/electron.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/electron.js~getPostData",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/utils/electron.js",
    "importStyle": null,
    "description": "Electron requires the use of the debugger to retrieve the requests post data",
    "see": [
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestId",
        "description": "the request to fetch the post data for"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the Electron debugger to use to get the post data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<?Buffer>"
      ],
      "spread": false,
      "description": "body - the response body as a node buffer"
    },
    "ignore": true
  },
  {
    "__docId__": 268,
    "kind": "file",
    "name": "lib/utils/electronGetResError.js",
    "content": "/**\n * @desc Electron debugger errors passed to the callback are plain objects not Errors\n * but contain information concerning the error.\n */\nclass ElectronGetResError extends Error {\n  /**\n   * @param {Object} oError - the error supplied to the callback\n   * @param {string} rid - the request id of the request retrieval of the response body failed for\n   */\n  constructor (oError, rid) {\n    super(\n      oError.message ||\n        `An Error Occurred retrieving the response body for ${rid}`\n    )\n\n    /**\n     * @desc the original error object supplied to the callback\n     * @type {Object}\n     */\n    this.oError = oError\n    /**\n     * @desc the request id of the request retrieval of the response body failed for\n     * @type {string}\n     */\n    this.rid = rid\n  }\n}\n\n/**\n * @type {ElectronGetResError}\n */\nmodule.exports = ElectronGetResError\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/utils/electronGetResError.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 269,
    "kind": "class",
    "name": "ElectronGetResError",
    "memberof": "lib/utils/electronGetResError.js",
    "static": true,
    "longname": "lib/utils/electronGetResError.js~ElectronGetResError",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/utils/electronGetResError.js",
    "importStyle": "ElectronGetResError",
    "description": "Electron debugger errors passed to the callback are plain objects not Errors\nbut contain information concerning the error.",
    "lineNumber": 5,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 270,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/utils/electronGetResError.js~ElectronGetResError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/utils/electronGetResError.js~ElectronGetResError#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "oError",
        "description": "the error supplied to the callback"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rid",
        "description": "the request id of the request retrieval of the response body failed for"
      }
    ]
  },
  {
    "__docId__": 271,
    "kind": "member",
    "name": "oError",
    "memberof": "lib/utils/electronGetResError.js~ElectronGetResError",
    "static": false,
    "longname": "lib/utils/electronGetResError.js~ElectronGetResError#oError",
    "access": "public",
    "description": "the original error object supplied to the callback",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 272,
    "kind": "member",
    "name": "rid",
    "memberof": "lib/utils/electronGetResError.js~ElectronGetResError",
    "static": false,
    "longname": "lib/utils/electronGetResError.js~ElectronGetResError#rid",
    "access": "public",
    "description": "the request id of the request retrieval of the response body failed for",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 273,
    "kind": "file",
    "name": "lib/utils/getResBodyElectron.js",
    "content": "const isEmpty = require('lodash/isEmpty')\nconst ElectronGetResError = require('./electronGetResError')\n\n/**\n * @desc Electron requires the use of the debugger to retrieve the requests response body\n * @param {string} requestId the request to fetch the response body for\n * @param {Object} wcDebugger the Electron debugger to use to get the response body\n * @see https://electron.atom.io/docs/api/debugger/\n * @return {Promise<Buffer>} body - the response body as a node buffer\n * @throws {ElectronGetResError} - rejects if the error parameter to the callback was set\n */\nmodule.exports = function getResBodyElectron (requestId, wcDebugger) {\n  return new Promise((resolve, reject) => {\n    wcDebugger.sendCommand(\n      'Network.getResponseBody',\n      { requestId },\n      (error, body) => {\n        if (!isEmpty(error)) {\n          reject(new ElectronGetResError(error, requestId))\n        } else {\n          resolve(body)\n        }\n      }\n    )\n  })\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/utils/getResBodyElectron.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 274,
    "kind": "function",
    "name": "getResBodyElectron",
    "memberof": "lib/utils/getResBodyElectron.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/getResBodyElectron.js~getResBodyElectron",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/utils/getResBodyElectron.js",
    "importStyle": "getResBodyElectron",
    "description": "Electron requires the use of the debugger to retrieve the requests response body",
    "see": [
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestId",
        "description": "the request to fetch the response body for"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the Electron debugger to use to get the response body"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Buffer>"
      ],
      "spread": false,
      "description": "body - the response body as a node buffer"
    },
    "throws": [
      {
        "types": [
          "ElectronGetResError"
        ],
        "description": "rejects if the error parameter to the callback was set"
      }
    ]
  },
  {
    "__docId__": 275,
    "kind": "file",
    "name": "lib/utils/headerSerializers.js",
    "content": "const startCase = require('lodash/startCase')\nconst { SPACE, DASH } = require('../utils/constants')\nconst { CRLF } = require('../writers/warcFields')\n\n/**\n * @param {string} headerKey\n * @return {string}\n */\nfunction ensureHTTP2Headers (headerKey) {\n  if (headerKey[0] === ':') return headerKey\n  return startCase(headerKey).replace(SPACE, DASH)\n}\n\n/**\n * @desc Converts an HTTP headers object into its string representation\n * @param {Object} headers - The HTTP header object to be stringified\n * @returns {string}\n */\nexports.stringifyHeaders = function stringifyHeaders (headers) {\n  let headerKey\n  let outString = []\n  for (headerKey in headers) {\n    outString.push(`${ensureHTTP2Headers(headerKey)}: ${headers[headerKey]}${CRLF}`)\n  }\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  // affects node\n  return outString.join('')\n}\n\n/**\n * @desc Converts an HTTP request headers object into its string representation\n * @param {Object} headers - The HTTP headers object for the request\n * @param {string} host - The host for the request to be used if the HTTP headers object does not contain the Host field\n * @returns {string}\n */\nexports.stringifyRequestHeaders = function stringifyRequestHeaders (headers, host) {\n  let hasHost = false\n  let headerKey\n  let outString = []\n  for (headerKey in headers) {\n    if (headerKey === 'host' || headerKey === 'Host') {\n      hasHost = true\n    }\n    outString.push(`${ensureHTTP2Headers(headerKey)}: ${headers[headerKey]}${CRLF}`)\n  }\n  if (!hasHost) {\n    outString.push(`Host: ${host}${CRLF}`)\n  }\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  // affects node\n  return outString.join('')\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/utils/headerSerializers.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 276,
    "kind": "function",
    "name": "ensureHTTP2Headers",
    "memberof": "lib/utils/headerSerializers.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/headerSerializers.js~ensureHTTP2Headers",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/utils/headerSerializers.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 9,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "headerKey",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 277,
    "kind": "function",
    "name": "stringifyHeaders",
    "memberof": "lib/utils/headerSerializers.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/headerSerializers.js~stringifyHeaders",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/utils/headerSerializers.js",
    "importStyle": "{stringifyHeaders}",
    "description": "Converts an HTTP headers object into its string representation",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "headers",
        "description": "The HTTP header object to be stringified"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 278,
    "kind": "function",
    "name": "stringifyRequestHeaders",
    "memberof": "lib/utils/headerSerializers.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/headerSerializers.js~stringifyRequestHeaders",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/utils/headerSerializers.js",
    "importStyle": "{stringifyRequestHeaders}",
    "description": "Converts an HTTP request headers object into its string representation",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "headers",
        "description": "The HTTP headers object for the request"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "host",
        "description": "The host for the request to be used if the HTTP headers object does not contain the Host field"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 279,
    "kind": "file",
    "name": "lib/utils/index.js",
    "content": "const {\n  stringifyHeaders,\n  stringifyRequestHeaders\n} = require('./headerSerializers')\n\n/**\n * @type {{isEmptyPlainObject: function(object: ?Object): boolean, getResBodyElectron: function(requestId: string, wcDebugger: Object): Promise<Buffer>, stringifyHeaders: function(headers: Object): string, stringifyRequestHeaders: function(reqHeaders: Object, host: string): string, constants: {canReplayProtocols: Set<string>, SPACE: string, H2Method: string, HTTP1D1: string, DASH: string, H2path: string}, ElectronGetResError: ElectronGetResError}}\n */\nmodule.exports = {\n  isEmptyPlainObject: require('./isEmptyPlainObject'),\n  getResBodyElectron: require('./getResBodyElectron'),\n  stringifyHeaders,\n  stringifyRequestHeaders,\n  constants: require('./constants'),\n  ElectronGetResError: require('./electronGetResError')\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/utils/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 280,
    "kind": "file",
    "name": "lib/utils/isEmptyPlainObject.js",
    "content": "'use strict'\nconst isEmpty = require('lodash/isEmpty')\n\n/**\n * @desc Test to see if a ``plain object`` is empty\n * @param {?Object} object\n * @return {boolean}\n */\nmodule.exports = function isEmptyPlainObject (object) {\n  if (object == null) {\n    return true\n  }\n  return isEmpty(object)\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/utils/isEmptyPlainObject.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 281,
    "kind": "function",
    "name": "isEmptyPlainObject",
    "memberof": "lib/utils/isEmptyPlainObject.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/utils/isEmptyPlainObject.js~isEmptyPlainObject",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/utils/isEmptyPlainObject.js",
    "importStyle": "isEmptyPlainObject",
    "description": "Test to see if a ``plain object`` is empty",
    "lineNumber": 9,
    "params": [
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 282,
    "kind": "file",
    "name": "lib/warcRecord/builder.js",
    "content": "'use strict'\nconst WARCRecord = require('./record')\nconst { crlf, begin } = require('./fieldIdentifiers')\n\n/**\n * @type {{header: symbol, content1: symbol, content2: symbol, consumeCRLFHeader: symbol, consumeCRLFContent1: symbol, consumeCRLFContent2: symbol}}\n */\nconst parsingStates = {\n  header: Symbol('warc-parsing-header'),\n  content1: Symbol('warc-parsing-content1'),\n  content2: Symbol('warc-parsing-content2'),\n  consumeCRLFHeader: Symbol('warc-parsing-comsume-crlf-header'),\n  consumeCRLFContent1: Symbol('warc-parsing-comsume-crlf-c1'),\n  consumeCRLFContent2: Symbol('warc-parsing-comsume-crlf-c2')\n}\n\n/**\n * @type {number}\n */\nconst WFIBeginLen = begin.length\n\n/**\n * @param {Buffer} line\n * @returns {boolean}\n */\nfunction isJustCRLF (line) {\n  if (line.length !== 2) return false\n  return line[0] === crlf[0] && line[1] === crlf[1]\n}\n\n/**\n * @param {Buffer} line\n * @returns {boolean}\n */\nfunction isWARCRevisionLine (line) {\n  if (line.length > 11) return false\n  let i = 0\n  while (i < WFIBeginLen) {\n    if (begin[i] !== line[i]) return false\n    i += 1\n  }\n  return true\n}\n\n/**\n * @desc Progressively builds warc records by consuming the file line by line\n */\nclass RecordBuilder {\n  /**\n   * @desc Create a new RecordBuilder\n   */\n  constructor () {\n    /**\n     * @type {{header: Buffer[], c1: Buffer[], c2: Buffer[]}}\n     * @private\n     */\n    this._parts = {\n      header: [],\n      c1: [],\n      c2: []\n    }\n\n    /**\n     * @type {symbol}\n     * @private\n     */\n    this._parsingState = parsingStates.header\n  }\n\n  /**\n   * @desc Returns a new WARC record if one can be created otherwise returns null\n   * @returns {?WARCRecord}\n   */\n  buildRecord () {\n    if (this._parts.header.length === 0) return null\n    const newRecord = new WARCRecord(this._parts)\n    this._parts.header = []\n    this._parts.c1 = []\n    this._parts.c2 = []\n    return newRecord\n  }\n\n  /**\n   * @desc Consumes a line of a WARC file.\n   * If a record can be built this function returns a new WARCRecord otherwise null\n   * @param {Buffer} line - The line to be consumed\n   * @returns {?WARCRecord}\n   */\n  consumeLine (line) {\n    let newRecord = null\n    if (isWARCRevisionLine(line)) {\n      this._parsingState = parsingStates.header\n      newRecord = this.buildRecord()\n    }\n    const isSep = isJustCRLF(line)\n    switch (this._parsingState) {\n      case parsingStates.header:\n        if (!isSep) {\n          this._parts.header.push(line)\n        } else {\n          this._parsingState = parsingStates.consumeCRLFHeader\n        }\n        break\n      case parsingStates.consumeCRLFHeader:\n        if (!isSep) {\n          this._parts.c1.push(line)\n          this._parsingState = parsingStates.content1\n        }\n        break\n      case parsingStates.content1:\n        if (!isSep) {\n          this._parts.c1.push(line)\n        } else {\n          this._parsingState = parsingStates.consumeCRLFContent1\n        }\n        break\n      case parsingStates.consumeCRLFContent1:\n        if (!isSep) {\n          this._parts.c2.push(line)\n          this._parsingState = parsingStates.content2\n        }\n        break\n      case parsingStates.content2:\n        if (!isSep) {\n          this._parts.c2.push(line)\n        } else {\n          this._parsingState = parsingStates.consumeCRLFContent2\n        }\n        break\n      case parsingStates.consumeCRLFContent2:\n        break\n    }\n    return newRecord\n  }\n}\n\n/**\n * @type {RecordBuilder}\n */\nmodule.exports = RecordBuilder\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/warcRecord/builder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 283,
    "kind": "variable",
    "name": "parsingStates",
    "memberof": "lib/warcRecord/builder.js",
    "static": true,
    "longname": "lib/warcRecord/builder.js~parsingStates",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/warcRecord/builder.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 8,
    "type": {
      "nullable": null,
      "types": [
        "{header: symbol, content1: symbol, content2: symbol, consumeCRLFHeader: symbol, consumeCRLFContent1: symbol, consumeCRLFContent2: symbol}"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 284,
    "kind": "variable",
    "name": "WFIBeginLen",
    "memberof": "lib/warcRecord/builder.js",
    "static": true,
    "longname": "lib/warcRecord/builder.js~WFIBeginLen",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/warcRecord/builder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 285,
    "kind": "function",
    "name": "isJustCRLF",
    "memberof": "lib/warcRecord/builder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/builder.js~isJustCRLF",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/warcRecord/builder.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 286,
    "kind": "function",
    "name": "isWARCRevisionLine",
    "memberof": "lib/warcRecord/builder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/builder.js~isWARCRevisionLine",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/warcRecord/builder.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 287,
    "kind": "class",
    "name": "RecordBuilder",
    "memberof": "lib/warcRecord/builder.js",
    "static": true,
    "longname": "lib/warcRecord/builder.js~RecordBuilder",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/warcRecord/builder.js",
    "importStyle": "RecordBuilder",
    "description": "Progressively builds warc records by consuming the file line by line",
    "lineNumber": 48,
    "interface": false
  },
  {
    "__docId__": 288,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecord/builder.js~RecordBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/builder.js~RecordBuilder#constructor",
    "access": "public",
    "description": "Create a new RecordBuilder",
    "lineNumber": 52
  },
  {
    "__docId__": 289,
    "kind": "member",
    "name": "_parts",
    "memberof": "lib/warcRecord/builder.js~RecordBuilder",
    "static": false,
    "longname": "lib/warcRecord/builder.js~RecordBuilder#_parts",
    "access": "private",
    "description": "",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "{header: Buffer[], c1: Buffer[], c2: Buffer[]}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 290,
    "kind": "member",
    "name": "_parsingState",
    "memberof": "lib/warcRecord/builder.js~RecordBuilder",
    "static": false,
    "longname": "lib/warcRecord/builder.js~RecordBuilder#_parsingState",
    "access": "private",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "buildRecord",
    "memberof": "lib/warcRecord/builder.js~RecordBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/builder.js~RecordBuilder#buildRecord",
    "access": "public",
    "description": "Returns a new WARC record if one can be created otherwise returns null",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{?WARCRecord}"
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "WARCRecord"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "consumeLine",
    "memberof": "lib/warcRecord/builder.js~RecordBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/builder.js~RecordBuilder#consumeLine",
    "access": "public",
    "description": "Consumes a line of a WARC file.\nIf a record can be built this function returns a new WARCRecord otherwise null",
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{?WARCRecord}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "The line to be consumed"
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "WARCRecord"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 299,
    "kind": "file",
    "name": "lib/warcRecord/fieldIdentifiers.js",
    "content": "'use strict'\n\n/**\n * @desc Buffers from hex strings representing the a WARC records WARC-TYPE or record/record-section separator\n * as seen by the parser. Due to the large size of WARC files and the binary data contained within it is more efficient\n * to parse the files contents looking for these sentinels than converting the buffer to an UTF-8 string first\n * @type {{begin: Buffer, info: Buffer, mdata: Buffer, req: Buffer, res: Buffer, revisit: Buffer, resource: Buffer, crlf: Buffer, empty: Buffer}}\n */\nmodule.exports = {\n  /**\n   * @type {Buffer}\n   */\n  begin: Buffer.from('574152432f', 'hex'),\n\n  /**\n   * @type {Buffer}\n   */\n  info: Buffer.from('574152432d547970653a2077617263696e666f', 'hex'),\n\n  /**\n   * @type {Buffer}\n   */\n  mdata: Buffer.from('574152432d547970653a206d65746164617461', 'hex'),\n\n  /**\n   * @type {Buffer}\n   */\n  req: Buffer.from('574152432d547970653a2072657175657374', 'hex'),\n\n  /**\n   * @type {Buffer}\n   */\n  res: Buffer.from('574152432d547970653a20726573706f6e7365', 'hex'),\n\n  /**\n   * @type {Buffer}\n   */\n  revisit: Buffer.from('574152432d547970653a2072657669736974', 'hex'),\n\n  /**\n   * @type {Buffer}\n   */\n  resource: Buffer.from('574152432d547970653a207265736f75726365', 'hex'),\n\n  /**\n   * @type {Buffer}\n   */\n  crlf: Buffer.from('0d0a', 'hex'),\n\n  /**\n   * @type {Buffer}\n   */\n  empty: Buffer.from('0d', 'hex')\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/warcRecord/fieldIdentifiers.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 300,
    "kind": "file",
    "name": "lib/warcRecord/index.js",
    "content": "/**\n * @type {{WARCRecord: WARCRecord, RecordBuilder: RecordBuilder, ContentParser: ContentParser}}\n */\nmodule.exports = {\n  /**\n   * @type {WARCRecord}\n   */\n  WARCRecord: require('./record'),\n\n  /**\n   * @type {RecordBuilder}\n   */\n  RecordBuilder: require('./builder'),\n\n  /**\n   * @type {ContentParser}\n   */\n  ContentParser: require('./warcContentParsers')\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/warcRecord/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 301,
    "kind": "file",
    "name": "lib/warcRecord/record.js",
    "content": "'use strict'\nconst ContentParser = require('./warcContentParsers')\n\n/**\n * @type {{warcinfo: string, metadata: string, request: string, response: string, revisit: string, resource: string, conversion: string, unknown: string, continuation: string}}\n */\nconst WARCTypes = {\n  warcinfo: 'warcinfo',\n  metadata: 'metadata',\n  request: 'request',\n  response: 'response',\n  revisit: 'revisit',\n  resource: 'resource',\n  conversion: 'conversion',\n  unknown: 'unknown',\n  continuation: 'continuation'\n}\n\n/**\n * @desc WARC record class. The WARC named fields are properties on this object\n */\nclass WARCRecord {\n  /**\n   * @desc Create a new WARCRecord\n   * @param {{header: Buffer[], c1: Buffer[], c2: Buffer[]}} warcParts - The parts of a warc record\n   */\n  constructor (warcParts) {\n    /**\n     * @desc An object containing the parsed WARC header\n     * @type {Object}\n     */\n    this.warcHeader = ContentParser.parseWarcRecordHeader(warcParts.header)\n\n    /**\n     * @desc An object containing the parsed request or response records HTTP information\n     * @type {?RequestHTTP|?ResponseHTTP}\n     */\n    this.httpInfo = null\n\n    /**\n     * @desc The content of the record.\n     * @type {Buffer}\n     */\n    this.content = null\n\n    const wt = this.warcType\n    switch (wt) {\n      case WARCTypes.request:\n      case WARCTypes.response:\n        this.httpInfo = ContentParser.parseHTTPPortion(\n          warcParts.c1,\n          wt === WARCTypes.request\n        )\n        this.content = Buffer.concat(warcParts.c2 || [])\n        break\n      case WARCTypes.revisit:\n        this.httpInfo = ContentParser.parseResHTTP(warcParts.c1)\n        break\n      default:\n        this.content = Buffer.concat(warcParts.c1 || [])\n        break\n    }\n  }\n\n  /**\n   * @desc Determine if this warc record header has the supplied WARC named field.\n   * If the supplied header key does not start with WARC then this it will be added.\n   * @example\n   *  // both ways are equivalent to determine if the record has the WARC-Type field\n   *  record.hasWARCHeader('WARC-Type')\n   *  record.hasWARCHeader('Type')\n   * @param {!string} headerKey - The WARC header key (named field)\n   * @return {boolean}\n   */\n  hasWARCHeader (headerKey) {\n    if (!headerKey.startsWith('WARC')) {\n      headerKey = `WARC-${headerKey}`\n    }\n    return this.warcHeader[headerKey] != null\n  }\n\n  /**\n   * @desc Retrieve the value of this records header field.\n   * If the supplied header key does not start with WARC then this it will be added.\n   * @example\n   *  // both ways are equivalent to retrieve WARC-Type field\n   *  record.getWARCHeader('WARC-Type')\n   *  record.getWARCHeader('Type')\n   * @param {!string} headerKey - The WARC header key (named field)\n   * @return {?string}\n   */\n  getWARCHeader (headerKey) {\n    if (!headerKey.startsWith('WARC')) {\n      headerKey = `WARC-${headerKey}`\n    }\n    return this.warcHeader[headerKey]\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcType () {\n    return this.warcHeader['WARC-Type']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcRecordID () {\n    return this.warcHeader['WARC-Record-ID']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcDate () {\n    return this.warcHeader['WARC-Date']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcContentLength () {\n    return this.warcHeader['Content-Length']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcContentType () {\n    return this.warcHeader['Content-Type']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcConcurrentTo () {\n    return this.warcHeader['WARC-Concurrent-To']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcBlockDigest () {\n    return this.warcHeader['WARC-Block-Digest']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcPayloadDigest () {\n    return this.warcHeader['WARC-Payload-Digest']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcIPAddress () {\n    return this.warcHeader['WARC-IP-Address']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcRefersTo () {\n    return this.warcHeader['WARC-Refers-To']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcRefersToTargetURI () {\n    return this.warcHeader['WARC-Refers-To-Target-URI']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcRefersToDate () {\n    return this.warcHeader['WARC-Refers-To-Date']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcTargetURI () {\n    return this.warcHeader['WARC-Target-URI']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcTruncated () {\n    return this.warcHeader['WARC-Truncated']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcWarcinfoID () {\n    return this.warcHeader['WARC-Warcinfo-ID']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcFilename () {\n    return this.warcHeader['WARC-Filename']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcProfile () {\n    return this.warcHeader['WARC-Profile']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcIdentifiedPayloadType () {\n    return this.warcHeader['WARC-Identified-Payload-Type']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcSegmentOriginID () {\n    return this.warcHeader['WARC-Segment-Origin-ID']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcSegmentNumber () {\n    return this.warcHeader['WARC-Segment-Number']\n  }\n\n  /**\n   * @return {?string}\n   */\n  get warcSegmentTotalLength () {\n    return this.warcHeader['WARC-Segment-Total-Length']\n  }\n}\n\n/**\n * @type {WARCRecord}\n */\nmodule.exports = WARCRecord\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/warcRecord/record.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 302,
    "kind": "variable",
    "name": "WARCTypes",
    "memberof": "lib/warcRecord/record.js",
    "static": true,
    "longname": "lib/warcRecord/record.js~WARCTypes",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/warcRecord/record.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 7,
    "type": {
      "nullable": null,
      "types": [
        "{warcinfo: string, metadata: string, request: string, response: string, revisit: string, resource: string, conversion: string, unknown: string, continuation: string}"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 303,
    "kind": "class",
    "name": "WARCRecord",
    "memberof": "lib/warcRecord/record.js",
    "static": true,
    "longname": "lib/warcRecord/record.js~WARCRecord",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/warcRecord/record.js",
    "importStyle": "WARCRecord",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 304,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#constructor",
    "access": "public",
    "description": "Create a new WARCRecord",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "{header: Buffer[], c1: Buffer[], c2: Buffer[]}"
        ],
        "spread": false,
        "optional": false,
        "name": "warcParts",
        "description": "The parts of a warc record"
      }
    ]
  },
  {
    "__docId__": 305,
    "kind": "member",
    "name": "warcHeader",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcHeader",
    "access": "public",
    "description": "An object containing the parsed WARC header",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 306,
    "kind": "member",
    "name": "httpInfo",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#httpInfo",
    "access": "public",
    "description": "An object containing the parsed request or response records HTTP information",
    "lineNumber": 38,
    "type": {
      "nullable": true,
      "types": [
        "RequestHTTP",
        "?ResponseHTTP"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 307,
    "kind": "member",
    "name": "content",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#content",
    "access": "public",
    "description": "The content of the record.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 312,
    "kind": "method",
    "name": "hasWARCHeader",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#hasWARCHeader",
    "access": "public",
    "description": "Determine if this warc record header has the supplied WARC named field.\nIf the supplied header key does not start with WARC then this it will be added.",
    "examples": [
      " // both ways are equivalent to determine if the record has the WARC-Type field\n record.hasWARCHeader('WARC-Type')\n record.hasWARCHeader('Type')"
    ],
    "lineNumber": 75,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "headerKey",
        "description": "The WARC header key (named field)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 313,
    "kind": "method",
    "name": "getWARCHeader",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#getWARCHeader",
    "access": "public",
    "description": "Retrieve the value of this records header field.\nIf the supplied header key does not start with WARC then this it will be added.",
    "examples": [
      " // both ways are equivalent to retrieve WARC-Type field\n record.getWARCHeader('WARC-Type')\n record.getWARCHeader('Type')"
    ],
    "lineNumber": 92,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "headerKey",
        "description": "The WARC header key (named field)"
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 314,
    "kind": "get",
    "name": "warcType",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcType",
    "access": "public",
    "description": "",
    "lineNumber": 102,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "get",
    "name": "warcRecordID",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcRecordID",
    "access": "public",
    "description": "",
    "lineNumber": 109,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "get",
    "name": "warcDate",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcDate",
    "access": "public",
    "description": "",
    "lineNumber": 116,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "get",
    "name": "warcContentLength",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcContentLength",
    "access": "public",
    "description": "",
    "lineNumber": 123,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "get",
    "name": "warcContentType",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcContentType",
    "access": "public",
    "description": "",
    "lineNumber": 130,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 319,
    "kind": "get",
    "name": "warcConcurrentTo",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcConcurrentTo",
    "access": "public",
    "description": "",
    "lineNumber": 137,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 320,
    "kind": "get",
    "name": "warcBlockDigest",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcBlockDigest",
    "access": "public",
    "description": "",
    "lineNumber": 144,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "get",
    "name": "warcPayloadDigest",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcPayloadDigest",
    "access": "public",
    "description": "",
    "lineNumber": 151,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "get",
    "name": "warcIPAddress",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcIPAddress",
    "access": "public",
    "description": "",
    "lineNumber": 158,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "get",
    "name": "warcRefersTo",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcRefersTo",
    "access": "public",
    "description": "",
    "lineNumber": 165,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "get",
    "name": "warcRefersToTargetURI",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcRefersToTargetURI",
    "access": "public",
    "description": "",
    "lineNumber": 172,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "get",
    "name": "warcRefersToDate",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcRefersToDate",
    "access": "public",
    "description": "",
    "lineNumber": 179,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "get",
    "name": "warcTargetURI",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcTargetURI",
    "access": "public",
    "description": "",
    "lineNumber": 186,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "get",
    "name": "warcTruncated",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcTruncated",
    "access": "public",
    "description": "",
    "lineNumber": 193,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "get",
    "name": "warcWarcinfoID",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcWarcinfoID",
    "access": "public",
    "description": "",
    "lineNumber": 200,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "get",
    "name": "warcFilename",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcFilename",
    "access": "public",
    "description": "",
    "lineNumber": 207,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "get",
    "name": "warcProfile",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcProfile",
    "access": "public",
    "description": "",
    "lineNumber": 214,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "get",
    "name": "warcIdentifiedPayloadType",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcIdentifiedPayloadType",
    "access": "public",
    "description": "",
    "lineNumber": 221,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "get",
    "name": "warcSegmentOriginID",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcSegmentOriginID",
    "access": "public",
    "description": "",
    "lineNumber": 228,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "get",
    "name": "warcSegmentNumber",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcSegmentNumber",
    "access": "public",
    "description": "",
    "lineNumber": 235,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "get",
    "name": "warcSegmentTotalLength",
    "memberof": "lib/warcRecord/record.js~WARCRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/warcRecord/record.js~WARCRecord#warcSegmentTotalLength",
    "access": "public",
    "description": "",
    "lineNumber": 242,
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 335,
    "kind": "file",
    "name": "lib/warcRecord/warcContentParsers.js",
    "content": "'use strict'\nconst { SPACE } = require('../utils/constants')\nconst WFI = require('./fieldIdentifiers')\n\n/**\n * @type {Buffer}\n */\nconst WARCVSlash = Buffer.from('/')\n\n/**\n * @type {Buffer}\n */\nconst ColonSpace = Buffer.from(': ')\n\n/**\n * @type {Buffer}\n */\nconst CRLF = WFI.crlf\n\n/**\n * @desc Utility class for parsing parts of WARC records\n */\nclass ContentParser {\n  /**\n   * @desc Slices the supplied buffer returning a UTF-8 string\n   * @param {Buffer} buf   - The buffer to slice\n   * @param {number} start - The start position of the slice\n   * @param {number} end   - The end position of the slice\n   * @return {string}\n   */\n  static utf8BufferSlice (buf, start, end) {\n    return buf.slice(start, end).toString('utf8')\n  }\n\n  /**\n   * @desc Returns the index of the end of the supplied buffer that does not include `\\r\\n`\n   * @param {Buffer} buf    - The buffer to receive the correct end index for\n   * @param {number} bufLen - The full length of the buffer\n   * @return {number}\n   */\n  static bufEndPosNoCRLF (buf, bufLen) {\n    if (buf[bufLen - 2] === CRLF[0] && buf[bufLen - 1] === CRLF[1]) {\n      return bufLen - 2\n    }\n    return bufLen\n  }\n\n  /**\n   * @desc Parses the HTTP information of WARC request and response records\n   * @param {Buffer[]} bufs - Buffers containing the HTTP header information\n   * @param {boolean} req   - Should the buffers be parsed as request or response\n   * @returns {RequestHTTP|ResponseHTTP}\n   */\n  static parseHTTPPortion (bufs, req) {\n    if (req) return ContentParser.parseReqHTTP(bufs)\n    return ContentParser.parseResHTTP(bufs)\n  }\n\n  /**\n   * @desc Parse a WARC Records headers not HTTP Header parser\n   * @param {Buffer[]} bufs - the WARC Records header lines\n   * @return {Object}\n   */\n  static parseWarcRecordHeader (bufs) {\n    let rheader = {}\n    let len = bufs.length\n    let i = 0\n    let currentBuffer\n    let curLen\n    let sepPos\n    let headerKey\n    let headerValue\n    while (i < len) {\n      currentBuffer = bufs[i]\n      curLen = currentBuffer.length\n      sepPos = currentBuffer.indexOf(ColonSpace)\n      if (sepPos !== -1) {\n        headerKey = ContentParser.utf8BufferSlice(currentBuffer, 0, sepPos)\n        headerValue = ContentParser.utf8BufferSlice(\n          currentBuffer,\n          sepPos + 2,\n          ContentParser.bufEndPosNoCRLF(currentBuffer, curLen)\n        )\n        rheader[headerKey] = headerValue\n      } else {\n        rheader['WARC'] = ContentParser.utf8BufferSlice(\n          currentBuffer,\n          currentBuffer.indexOf(WARCVSlash) + 1,\n          ContentParser.bufEndPosNoCRLF(currentBuffer, curLen)\n        )\n      }\n      i++\n    }\n    return rheader\n  }\n\n  /**\n   * @desc Parse a WARC Metadata records metadata content\n   * @param {Buffer[]} bufs - the WARC Metadata records content lines\n   * @return {Object}\n   */\n  static parseWarcInfoMetaDataContent (bufs) {\n    let content = {}\n    let len = bufs.length\n    let i = 0\n    let sepPos\n    let key\n    let value\n    let currentBuffer\n    let curLen\n    while (i < len) {\n      currentBuffer = bufs[i]\n      curLen = currentBuffer.length\n      sepPos = currentBuffer.indexOf(ColonSpace)\n      if (sepPos !== -1) {\n        key = ContentParser.utf8BufferSlice(currentBuffer, 0, sepPos)\n        value = ContentParser.utf8BufferSlice(\n          currentBuffer,\n          sepPos + 2,\n          ContentParser.bufEndPosNoCRLF(currentBuffer, curLen)\n        )\n        if (key === 'outlink') {\n          if (content.outlink == null) {\n            content.outlink = []\n          }\n          content.outlink.push(value)\n        } else {\n          content[key] = value\n        }\n      } else {\n        value = ContentParser.utf8BufferSlice(\n          currentBuffer,\n          0,\n          ContentParser.bufEndPosNoCRLF(currentBuffer, curLen)\n        )\n        if (content.unkeyed == null) {\n          content.unkeyed = []\n        }\n        content.unkeyed.push(value)\n      }\n      i++\n    }\n    return content\n  }\n\n  /**\n   * @desc Parses the request HTTP headers\n   * @param {Buffer[]} headerBuffs - the request HTTP headers\n   * @return {RequestHTTP}\n   */\n  static parseReqHTTP (headerBuffs) {\n    const content = {\n      requestLine: null,\n      path: null,\n      method: null,\n      httpVersion: null,\n      headers: null\n    }\n    if (headerBuffs.length === 0) {\n      return content\n    }\n    let currentBuffer = headerBuffs[0]\n    let curLen = currentBuffer.length\n    let requestLine = ContentParser.utf8BufferSlice(\n      currentBuffer,\n      0,\n      ContentParser.bufEndPosNoCRLF(currentBuffer, curLen)\n    )\n    content.requestLine = requestLine\n    let spaceIDX = requestLine.indexOf(SPACE)\n    content.method = requestLine.substring(0, spaceIDX)\n    let lastIDX = spaceIDX + 1\n    spaceIDX = requestLine.indexOf(SPACE, lastIDX)\n    content.path = requestLine.substring(lastIDX, spaceIDX)\n    content.httpVersion = requestLine.substring(spaceIDX + 1)\n    content.headers = ContentParser._parseHeaders(headerBuffs)\n    return content\n  }\n\n  /**\n   * @desc Parses the response HTTP headers\n   * @param {Buffer[]} headerBuffs - the response HTTP headers\n   * @return {ResponseHTTP}\n   */\n  static parseResHTTP (headerBuffs) {\n    const content = {\n      statusLine: null,\n      statusCode: null,\n      statusReason: null,\n      httpVersion: null,\n      headers: null\n    }\n    if (headerBuffs.length === 0) {\n      return content\n    }\n    let currentBuffer = headerBuffs[0]\n    let curLen = currentBuffer.length\n    let statusLine = ContentParser.utf8BufferSlice(\n      currentBuffer,\n      0,\n      ContentParser.bufEndPosNoCRLF(currentBuffer, curLen)\n    )\n    content.statusLine = statusLine\n    let spaceIDX = statusLine.indexOf(SPACE)\n    content.httpVersion = statusLine.substring(0, spaceIDX)\n    let lastIDX = spaceIDX + 1\n    spaceIDX = statusLine.indexOf(SPACE, lastIDX)\n    content.statusCode = statusLine.substring(lastIDX, spaceIDX)\n    content.statusReason = statusLine.substring(spaceIDX + 1)\n    content.headers = ContentParser._parseHeaders(headerBuffs)\n    return content\n  }\n\n  /**\n   * @desc Parses an array of buffers containing HTTP headers\n   * @param {Buffer[]} headerBuffs - The array of buffers representing HTTP headers\n   * @return {Object}\n   * @private\n   */\n  static _parseHeaders (headerBuffs) {\n    const headers = {}\n    let len = headerBuffs.length\n    let i = 1\n    let key\n    let lastKey = ''\n    let sepPos\n    let currentBuffer\n    let curLen\n    while (i < len) {\n      currentBuffer = headerBuffs[i]\n      curLen = currentBuffer.length\n      sepPos = currentBuffer.indexOf(ColonSpace)\n      if (sepPos !== -1) {\n        key = ContentParser.utf8BufferSlice(currentBuffer, 0, sepPos)\n        lastKey = key\n        headers[key] = ContentParser.utf8BufferSlice(\n          currentBuffer,\n          sepPos + 2,\n          ContentParser.bufEndPosNoCRLF(currentBuffer, curLen)\n        )\n      } else {\n        headers[lastKey] = ContentParser.utf8BufferSlice(\n          currentBuffer,\n          0,\n          ContentParser.bufEndPosNoCRLF(currentBuffer, curLen)\n        )\n      }\n      i++\n    }\n    return headers\n  }\n}\n\n/**\n * @type {ContentParser}\n */\nmodule.exports = ContentParser\n\n/**\n * @typedef {Object} RequestHTTP\n * @property {?string} requestLine - The HTTP request line\n * @property {?string} path - The path of the request\n * @property {?string} method - The HTTP method used\n * @property {?string} httpVersion - The HTTP version\n * @property {?Object} headers - The parsed headers\n */\n\n/**\n * @typedef {Object} ResponseHTTP\n * @property {?string} statusLine - The HTTP response line\n * @property {?string} statusCode - The response code\n * @property {?string} statusReason - The status reason\n * @property {?string} httpVersion - The HTTP version\n * @property {?Object} headers - The parsed headers\n */\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/warcRecord/warcContentParsers.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 336,
    "kind": "variable",
    "name": "WARCVSlash",
    "memberof": "lib/warcRecord/warcContentParsers.js",
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~WARCVSlash",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/warcRecord/warcContentParsers.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 8,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 337,
    "kind": "variable",
    "name": "ColonSpace",
    "memberof": "lib/warcRecord/warcContentParsers.js",
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ColonSpace",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/warcRecord/warcContentParsers.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 13,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 338,
    "kind": "variable",
    "name": "CRLF",
    "memberof": "lib/warcRecord/warcContentParsers.js",
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~CRLF",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/warcRecord/warcContentParsers.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 339,
    "kind": "class",
    "name": "ContentParser",
    "memberof": "lib/warcRecord/warcContentParsers.js",
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ContentParser",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/warcRecord/warcContentParsers.js",
    "importStyle": "ContentParser",
    "description": "Utility class for parsing parts of WARC records",
    "lineNumber": 23,
    "interface": false
  },
  {
    "__docId__": 340,
    "kind": "typedef",
    "name": "RequestHTTP",
    "memberof": "lib/warcRecord/warcContentParsers.js",
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~RequestHTTP",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestLine",
        "description": "The HTTP request line"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path of the request"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "The HTTP method used"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "httpVersion",
        "description": "The HTTP version"
      },
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "headers",
        "description": "The parsed headers"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "RequestHTTP"
    }
  },
  {
    "__docId__": 341,
    "kind": "typedef",
    "name": "ResponseHTTP",
    "memberof": "lib/warcRecord/warcContentParsers.js",
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ResponseHTTP",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "statusLine",
        "description": "The HTTP response line"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "statusCode",
        "description": "The response code"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "statusReason",
        "description": "The status reason"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "httpVersion",
        "description": "The HTTP version"
      },
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "headers",
        "description": "The parsed headers"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ResponseHTTP"
    }
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "utf8BufferSlice",
    "memberof": "lib/warcRecord/warcContentParsers.js~ContentParser",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ContentParser.utf8BufferSlice",
    "access": "public",
    "description": "Slices the supplied buffer returning a UTF-8 string",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "buf",
        "description": "The buffer to slice"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": "The start position of the slice"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": "The end position of the slice"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "bufEndPosNoCRLF",
    "memberof": "lib/warcRecord/warcContentParsers.js~ContentParser",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ContentParser.bufEndPosNoCRLF",
    "access": "public",
    "description": "Returns the index of the end of the supplied buffer that does not include `\\r\\n`",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "buf",
        "description": "The buffer to receive the correct end index for"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "bufLen",
        "description": "The full length of the buffer"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 344,
    "kind": "method",
    "name": "parseHTTPPortion",
    "memberof": "lib/warcRecord/warcContentParsers.js~ContentParser",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ContentParser.parseHTTPPortion",
    "access": "public",
    "description": "Parses the HTTP information of WARC request and response records",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{RequestHTTP|ResponseHTTP}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bufs",
        "description": "Buffers containing the HTTP header information"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "req",
        "description": "Should the buffers be parsed as request or response"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RequestHTTP",
        "ResponseHTTP"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 345,
    "kind": "method",
    "name": "parseWarcRecordHeader",
    "memberof": "lib/warcRecord/warcContentParsers.js~ContentParser",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ContentParser.parseWarcRecordHeader",
    "access": "public",
    "description": "Parse a WARC Records headers not HTTP Header parser",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bufs",
        "description": "the WARC Records header lines"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "parseWarcInfoMetaDataContent",
    "memberof": "lib/warcRecord/warcContentParsers.js~ContentParser",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ContentParser.parseWarcInfoMetaDataContent",
    "access": "public",
    "description": "Parse a WARC Metadata records metadata content",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bufs",
        "description": "the WARC Metadata records content lines"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "parseReqHTTP",
    "memberof": "lib/warcRecord/warcContentParsers.js~ContentParser",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ContentParser.parseReqHTTP",
    "access": "public",
    "description": "Parses the request HTTP headers",
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffs",
        "description": "the request HTTP headers"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RequestHTTP"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 348,
    "kind": "method",
    "name": "parseResHTTP",
    "memberof": "lib/warcRecord/warcContentParsers.js~ContentParser",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ContentParser.parseResHTTP",
    "access": "public",
    "description": "Parses the response HTTP headers",
    "lineNumber": 185,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffs",
        "description": "the response HTTP headers"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ResponseHTTP"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 349,
    "kind": "method",
    "name": "_parseHeaders",
    "memberof": "lib/warcRecord/warcContentParsers.js~ContentParser",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/warcRecord/warcContentParsers.js~ContentParser._parseHeaders",
    "access": "private",
    "description": "Parses an array of buffers containing HTTP headers",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "headerBuffs",
        "description": "The array of buffers representing HTTP headers"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 350,
    "kind": "file",
    "name": "lib/writers/constants.js",
    "content": "'use strict'\n\n/**\n * @desc Regex for removing the content encoding HTTP header\n * @type {RegExp}\n */\nconst noGZ = /Content-Encoding.*(?:gzip|br|deflate)\\r\\n/gi\n\n/**\n * @desc Regex for rewriting the content length HTTP header\n * @type {RegExp}\n */\nconst replaceContentLen = /Content-Length:.*\\r\\n/gi\n\n/**\n * @type {{noGZ: RegExp, replaceContentLen: RegExp}}\n */\nmodule.exports = {\n  noGZ,\n  replaceContentLen\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/writers/constants.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 351,
    "kind": "variable",
    "name": "noGZ",
    "memberof": "lib/writers/constants.js",
    "static": true,
    "longname": "lib/writers/constants.js~noGZ",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/constants.js",
    "importStyle": null,
    "description": "Regex for removing the content encoding HTTP header",
    "lineNumber": 7,
    "type": {
      "nullable": null,
      "types": [
        "RegExp"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 352,
    "kind": "variable",
    "name": "replaceContentLen",
    "memberof": "lib/writers/constants.js",
    "static": true,
    "longname": "lib/writers/constants.js~replaceContentLen",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/constants.js",
    "importStyle": null,
    "description": "Regex for rewriting the content length HTTP header",
    "lineNumber": 13,
    "type": {
      "nullable": null,
      "types": [
        "RegExp"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 353,
    "kind": "file",
    "name": "lib/writers/electron.js",
    "content": "const WARCWriterBase = require('./warcWriterBase')\nconst { CRLF } = require('./warcFields')\nconst { noGZ, replaceContentLen } = require('./constants')\nconst { getPostData, getResBody } = require('../utils/electron')\n\n/**\n * @desc WARC Generator for use with Electron\n * @see https://electron.atom.io/docs/\n * @see https://electron.atom.io/docs/api/debugger/\n * @extends {WARCWriterBase}\n */\nclass ElectronWARCGenerator extends WARCWriterBase {\n  /**\n   * @param {ElectronRequestCapturer} capturer - The Electron request capturer that contains requests\n   * to be serialized to the WARC\n   * @param {Object} wcDebugger - the Electron debugger to use to get the response body\n   * @param {WARCGenOpts} genOpts - Options for generating the WARC and optionally generating\n   * WARC info and metadata records\n   * @return {Promise<?Error>} - A Promise that resolves when WARC generation is complete\n   */\n  async generateWARC (capturer, wcDebugger, genOpts) {\n    const donePromise = new Promise(resolve => {\n      this.once('finished', resolve)\n    })\n    const { warcOpts, winfo, metadata } = genOpts\n    this.initWARC(warcOpts.warcPath, warcOpts)\n    if (winfo != null) {\n      await this.writeWarcInfoRecord(\n        winfo.isPartOfV,\n        winfo.warcInfoDescription,\n        winfo.ua\n      )\n    }\n    if (metadata != null) {\n      await this.writeWarcMetadata(metadata.targetURI, metadata.content)\n    }\n    for (let request of capturer.iterateRequests()) {\n      try {\n        await this.generateWarcEntry(request, wcDebugger)\n      } catch (error) {\n        console.error(error)\n      }\n    }\n    this.end()\n    return donePromise\n  }\n\n  /**\n   * @desc Generate a WARC record\n   * @param {CDPRequestInfo} nreq - The captured HTTP info\n   * @param {Object} wcDebugger - The Electron webcontents debugger object\n   * @return {Promise<void>}\n   */\n  async generateWarcEntry (nreq, wcDebugger) {\n    if (nreq.url.indexOf('data:') === 0) return\n    let postData\n    if (nreq.postData) {\n      postData = nreq.postData\n    } else if (nreq.hasPostData) {\n      try {\n        let post = await getPostData(nreq.requestId, wcDebugger)\n        postData = Buffer.from(post.postData, 'base64')\n      } catch (e) {}\n    }\n    if (nreq.canSerializeResponse()) {\n      let resData\n      let responseHeaders = nreq.serializeResponseHeaders()\n      if (nreq.getBody) {\n        let wasError = false\n        try {\n          let rbody = await getResBody(nreq.requestId, wcDebugger)\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(\n            replaceContentLen,\n            `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`\n          )\n        }\n      }\n      return this.writeRequestResponseRecords(\n        nreq.url,\n        {\n          headers: nreq.serializeRequestHeaders(),\n          data: postData\n        },\n        {\n          headers: responseHeaders,\n          data: resData\n        }\n      )\n    }\n    return this.writeRequestRecord(\n      nreq.url,\n      nreq.serializeRequestHeaders(),\n      postData\n    )\n  }\n}\n\n/**\n * @type {ElectronWARCGenerator}\n */\nmodule.exports = ElectronWARCGenerator\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/writers/electron.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 354,
    "kind": "class",
    "name": "ElectronWARCGenerator",
    "memberof": "lib/writers/electron.js",
    "static": true,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/writers/electron.js",
    "importStyle": "ElectronWARCGenerator",
    "description": "WARC Generator for use with Electron",
    "see": [
      "https://electron.atom.io/docs/",
      "https://electron.atom.io/docs/api/debugger/"
    ],
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "WARCWriterBase"
    ]
  },
  {
    "__docId__": 355,
    "kind": "method",
    "name": "generateWARC",
    "memberof": "lib/writers/electron.js~ElectronWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator#generateWARC",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "ElectronRequestCapturer"
        ],
        "spread": false,
        "optional": false,
        "name": "capturer",
        "description": "The Electron request capturer that contains requests\nto be serialized to the WARC"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "the Electron debugger to use to get the response body"
      },
      {
        "nullable": null,
        "types": [
          "WARCGenOpts"
        ],
        "spread": false,
        "optional": false,
        "name": "genOpts",
        "description": "Options for generating the WARC and optionally generating\nWARC info and metadata records"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<?Error>"
      ],
      "spread": false,
      "description": "A Promise that resolves when WARC generation is complete"
    }
  },
  {
    "__docId__": 356,
    "kind": "method",
    "name": "generateWarcEntry",
    "memberof": "lib/writers/electron.js~ElectronWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/electron.js~ElectronWARCGenerator#generateWarcEntry",
    "access": "public",
    "description": "Generate a WARC record",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "CDPRequestInfo"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "The captured HTTP info"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "wcDebugger",
        "description": "The Electron webcontents debugger object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 357,
    "kind": "file",
    "name": "lib/writers/index.js",
    "content": "/**\n * @type {{ElectronWARCWriter: ElectronWARCGenerator, RemoteChromeWARCWriter: RemoteChromeWARCGenerator, PuppeteerCDPWARCGenerator: PuppeteerCDPWARCGenerator, PuppeteerWARCGenerator: PuppeteerWARCGenerator, WARCWriterBase: WARCWriterBase}}\n */\nmodule.exports = {\n  /**\n   * @type {ElectronWARCGenerator}\n   */\n  ElectronWARCWriter: require('./electron'),\n\n  /**\n   * @type {RemoteChromeWARCGenerator}\n   */\n  RemoteChromeWARCWriter: require('./remoteChrome'),\n\n  /**\n   * @type {PuppeteerCDPWARCGenerator}\n   */\n  PuppeteerCDPWARCGenerator: require('./puppeteerCDP'),\n\n  /**\n   * @type {PuppeteerWARCGenerator}\n   */\n  PuppeteerWARCGenerator: require('./puppeteer'),\n\n  /**\n   * @type {WARCWriterBase}\n   */\n  WARCWriterBase: require('./warcWriterBase')\n}\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/writers/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 358,
    "kind": "file",
    "name": "lib/writers/puppeteer.js",
    "content": "const { URL } = require('url')\nconst { STATUS_CODES } = require('http')\nconst { CRLF } = require('./warcFields')\nconst WARCWriterBase = require('./warcWriterBase')\nconst {\n  stringifyHeaders,\n  stringifyRequestHeaders\n} = require('../utils/headerSerializers')\nconst { noGZ, replaceContentLen } = require('./constants')\n\n/**\n * @extends {WARCWriterBase}\n * @desc WARC Generator for use with puppeteer\n * @see https://github.com/GoogleChrome/puppeteer\n */\nclass PuppeteerWARCGenerator extends WARCWriterBase {\n  /**\n   * @desc Create a new PuppeteerWARCGenerator\n   */\n  constructor () {\n    super()\n    /**\n     * @type {URL}\n     * @private\n     */\n    this._UP = new URL('about:blank')\n  }\n\n  /**\n   * @desc\n   * @param {PuppeteerRequestCapturer} capturer - The Puppeteer request capturer that contains requests\n   * to be serialized to the WARC\n   * @param {WARCGenOpts} genOpts - Options for generating the WARC and optionally generating\n   * WARC info and metadata records\n   * @return {Promise<?Error>} - A Promise that resolves when WARC generation is complete\n   */\n  async generateWARC (capturer, genOpts) {\n    const donePromise = new Promise(resolve => {\n      this.once('finished', resolve)\n    })\n    const { warcOpts, winfo, metadata } = genOpts\n    this.initWARC(warcOpts.warcPath, warcOpts)\n    if (winfo != null) {\n      await this.writeWarcInfoRecord(\n        winfo.isPartOfV,\n        winfo.warcInfoDescription,\n        winfo.ua\n      )\n    }\n    if (metadata != null) {\n      await this.writeWarcMetadata(metadata.targetURI, metadata.content)\n    }\n    for (let request of capturer.iterateRequests()) {\n      try {\n        await this.generateWarcEntry(request)\n      } catch (error) {\n        console.error(error)\n      }\n    }\n    this.end()\n    return donePromise\n  }\n\n  /**\n   * @desc Generate a WARC record\n   * @param {Request} request - A Puppeteer Request object\n   * @return {Promise<void>}\n   */\n  async generateWarcEntry (request) {\n    if (request.url().indexOf('data:') === 0) return\n    const response = request.response()\n    this._UP.href = request.url()\n    let reqHTTP = `${request.method()} ${this._UP.pathname +\n      this._UP.searchParams.toString() +\n      this._UP.hash} HTTP/1.1${CRLF}${stringifyRequestHeaders(request.headers(), this._UP.host)}`\n    if (response) {\n      let resHTTP = `HTTP/1.1 ${response.status()} ${\n        STATUS_CODES[response.status()]\n      } ${CRLF}${stringifyHeaders(response.headers())}`\n      let body\n      let wasError = false\n      try {\n        body = await response.buffer()\n      } catch (e) {\n        wasError = true\n      }\n      if (!wasError) {\n        resHTTP = resHTTP.replace(noGZ, '')\n        resHTTP = resHTTP.replace(\n          replaceContentLen,\n          `Content-Length: ${Buffer.byteLength(body, 'utf8')}${CRLF}`\n        )\n      }\n      return this.writeRequestResponseRecords(\n        this._UP.href,\n        { headers: reqHTTP, data: request.postData() },\n        { headers: resHTTP, data: body }\n      )\n    }\n    return this.writeRequestRecord(this._UP.href, reqHTTP, request.postData())\n  }\n}\n\n/**\n * @type {PuppeteerWARCGenerator}\n */\nmodule.exports = PuppeteerWARCGenerator\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/writers/puppeteer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 359,
    "kind": "class",
    "name": "PuppeteerWARCGenerator",
    "memberof": "lib/writers/puppeteer.js",
    "static": true,
    "longname": "lib/writers/puppeteer.js~PuppeteerWARCGenerator",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/writers/puppeteer.js",
    "importStyle": "PuppeteerWARCGenerator",
    "description": "WARC Generator for use with puppeteer",
    "see": [
      "https://github.com/GoogleChrome/puppeteer"
    ],
    "lineNumber": 16,
    "interface": false,
    "extends": [
      "WARCWriterBase"
    ]
  },
  {
    "__docId__": 360,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/writers/puppeteer.js~PuppeteerWARCGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/puppeteer.js~PuppeteerWARCGenerator#constructor",
    "access": "public",
    "description": "Create a new PuppeteerWARCGenerator",
    "lineNumber": 20
  },
  {
    "__docId__": 361,
    "kind": "member",
    "name": "_UP",
    "memberof": "lib/writers/puppeteer.js~PuppeteerWARCGenerator",
    "static": false,
    "longname": "lib/writers/puppeteer.js~PuppeteerWARCGenerator#_UP",
    "access": "private",
    "description": "",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "URL"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 362,
    "kind": "method",
    "name": "generateWARC",
    "memberof": "lib/writers/puppeteer.js~PuppeteerWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/puppeteer.js~PuppeteerWARCGenerator#generateWARC",
    "access": "public",
    "description": "",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "PuppeteerRequestCapturer"
        ],
        "spread": false,
        "optional": false,
        "name": "capturer",
        "description": "The Puppeteer request capturer that contains requests\nto be serialized to the WARC"
      },
      {
        "nullable": null,
        "types": [
          "WARCGenOpts"
        ],
        "spread": false,
        "optional": false,
        "name": "genOpts",
        "description": "Options for generating the WARC and optionally generating\nWARC info and metadata records"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<?Error>"
      ],
      "spread": false,
      "description": "A Promise that resolves when WARC generation is complete"
    }
  },
  {
    "__docId__": 363,
    "kind": "method",
    "name": "generateWarcEntry",
    "memberof": "lib/writers/puppeteer.js~PuppeteerWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/puppeteer.js~PuppeteerWARCGenerator#generateWarcEntry",
    "access": "public",
    "description": "Generate a WARC record",
    "lineNumber": 69,
    "params": [
      {
        "nullable": null,
        "types": [
          "Request"
        ],
        "spread": false,
        "optional": false,
        "name": "request",
        "description": "A Puppeteer Request object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 364,
    "kind": "file",
    "name": "lib/writers/puppeteerCDP.js",
    "content": "const WARCWriterBase = require('./warcWriterBase')\nconst { CRLF } = require('./warcFields')\nconst { noGZ, replaceContentLen } = require('./constants')\n\n/**\n * @desc WARC Generator for use with puppeteer\n * @see https://github.com/GoogleChrome/puppeteer\n * @extends {WARCWriterBase}\n */\nclass PuppeteerCDPWARCGenerator extends WARCWriterBase {\n  /**\n   * @param {PuppeteerCDPRequestCapturer} capturer  - The PuppeteerCDP request capturer that contains requests\n   * to be serialized to the WARC\n   * @param {CDPSession} client - A CDPSession connected to the target the response bodies will be retrieved from\n   * @param {WARCGenOpts} genOpts - Options for generating the WARC and optionally generating\n   * WARC info and metadata records\n   * @return {Promise<?Error>} - A Promise that resolves when WARC generation is complete\n   */\n  async generateWARC (capturer, client, genOpts) {\n    const donePromise = new Promise(resolve => {\n      this.once('finished', resolve)\n    })\n    const { winfo, metadata, warcOpts } = genOpts\n    this.initWARC(warcOpts.warcPath, warcOpts)\n    if (winfo != null) {\n      await this.writeWarcInfoRecord(\n        winfo.isPartOfV,\n        winfo.warcInfoDescription,\n        winfo.ua\n      )\n    }\n    if (metadata != null) {\n      await this.writeWarcMetadata(metadata.targetURI, metadata.content)\n    }\n    for (let request of capturer.iterateRequests()) {\n      try {\n        await this.generateWarcEntry(request, client)\n      } catch (error) {\n        console.error(error)\n      }\n    }\n    this.end()\n    return donePromise\n  }\n\n  /**\n   * @desc Generate a WARC record\n   * @param {CDPRequestInfo} nreq - The captured HTTP info\n   * @param {CDPSession} client - A CDPSession connected to the target the response bodies will be retrieved from\n   * @return {Promise<void>}\n   */\n  async generateWarcEntry (nreq, client) {\n    if (nreq.url.indexOf('data:') === 0) return\n    let postData\n    if (nreq.postData) {\n      postData = nreq.postData\n    } else if (nreq.hasPostData) {\n      try {\n        let post = await client.send('Network.getRequestPostData', {\n          requestId: nreq.requestId\n        })\n        postData = Buffer.from(post.postData, 'base64')\n      } catch (e) {}\n    }\n    if (nreq.canSerializeResponse()) {\n      let resData\n      let responseHeaders = nreq.serializeResponseHeaders()\n      if (nreq.getBody) {\n        let wasError = false\n        try {\n          let rbody = await client.send('Network.getResponseBody', {\n            requestId: nreq.requestId\n          })\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(\n            replaceContentLen,\n            `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`\n          )\n        }\n      }\n      return this.writeRequestResponseRecords(\n        nreq.url,\n        {\n          headers: nreq.serializeRequestHeaders(),\n          data: postData\n        },\n        {\n          headers: responseHeaders,\n          data: resData\n        }\n      )\n    }\n    return this.writeRequestRecord(\n      nreq.url,\n      nreq.serializeRequestHeaders(),\n      postData\n    )\n  }\n}\n\n/**\n * @type {PuppeteerCDPWARCGenerator}\n */\nmodule.exports = PuppeteerCDPWARCGenerator\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/writers/puppeteerCDP.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 365,
    "kind": "class",
    "name": "PuppeteerCDPWARCGenerator",
    "memberof": "lib/writers/puppeteerCDP.js",
    "static": true,
    "longname": "lib/writers/puppeteerCDP.js~PuppeteerCDPWARCGenerator",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/writers/puppeteerCDP.js",
    "importStyle": "PuppeteerCDPWARCGenerator",
    "description": "WARC Generator for use with puppeteer",
    "see": [
      "https://github.com/GoogleChrome/puppeteer"
    ],
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "WARCWriterBase"
    ]
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "generateWARC",
    "memberof": "lib/writers/puppeteerCDP.js~PuppeteerCDPWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/puppeteerCDP.js~PuppeteerCDPWARCGenerator#generateWARC",
    "access": "public",
    "description": "",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "PuppeteerCDPRequestCapturer"
        ],
        "spread": false,
        "optional": false,
        "name": "capturer",
        "description": "The PuppeteerCDP request capturer that contains requests\nto be serialized to the WARC"
      },
      {
        "nullable": null,
        "types": [
          "CDPSession"
        ],
        "spread": false,
        "optional": false,
        "name": "client",
        "description": "A CDPSession connected to the target the response bodies will be retrieved from"
      },
      {
        "nullable": null,
        "types": [
          "WARCGenOpts"
        ],
        "spread": false,
        "optional": false,
        "name": "genOpts",
        "description": "Options for generating the WARC and optionally generating\nWARC info and metadata records"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<?Error>"
      ],
      "spread": false,
      "description": "A Promise that resolves when WARC generation is complete"
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "generateWarcEntry",
    "memberof": "lib/writers/puppeteerCDP.js~PuppeteerCDPWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/puppeteerCDP.js~PuppeteerCDPWARCGenerator#generateWarcEntry",
    "access": "public",
    "description": "Generate a WARC record",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "CDPRequestInfo"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "The captured HTTP info"
      },
      {
        "nullable": null,
        "types": [
          "CDPSession"
        ],
        "spread": false,
        "optional": false,
        "name": "client",
        "description": "A CDPSession connected to the target the response bodies will be retrieved from"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 368,
    "kind": "file",
    "name": "lib/writers/remoteChrome.js",
    "content": "const WARCWriterBase = require('./warcWriterBase')\nconst { CRLF } = require('./warcFields')\nconst { noGZ, replaceContentLen } = require('./constants')\n\n/**\n * @desc WARC Generator for use with chrome-remote-interface\n * @see https://github.com/cyrus-and/chrome-remote-interface\n * @extends {WARCWriterBase}\n */\nclass RemoteChromeWARCGenerator extends WARCWriterBase {\n  /**\n   * @param {RemoteChromeRequestCapturer} capturer - The RemoteChrome request capturer that contains requests\n   * to be serialized to the WARC\n   * @param {Object} network - The chrome-remote-interface Network object\n   * @param {WARCGenOpts} genOpts - Options for generating the WARC and optionally generating\n   * WARC info and metadata records\n   * @return {Promise<?Error>} - A Promise that resolves when WARC generation is complete\n   */\n  async generateWARC (capturer, network, genOpts) {\n    const donePromise = new Promise(resolve => {\n      this.once('finished', resolve)\n    })\n    const { warcOpts, winfo, metadata } = genOpts\n    this.initWARC(warcOpts.warcPath, warcOpts)\n    if (winfo != null) {\n      await this.writeWarcInfoRecord(\n        winfo.isPartOfV,\n        winfo.warcInfoDescription,\n        winfo.ua\n      )\n    }\n    if (metadata != null) {\n      await this.writeWarcMetadata(metadata.targetURI, metadata.content)\n    }\n    for (let request of capturer.iterateRequests()) {\n      try {\n        await this.generateWarcEntry(request, network)\n      } catch (error) {\n        console.error(error)\n      }\n    }\n    this.end()\n    return donePromise\n  }\n\n  /**\n   * @desc Generate a WARC record\n   * @param {CDPRequestInfo} nreq - The captured HTTP info\n   * @param {Object} network - The chrome-remote-interface Network object\n   * @return {Promise<void>}\n   */\n  async generateWarcEntry (nreq, network) {\n    if (nreq.url.indexOf('data:') === 0) return\n    let postData\n    if (nreq.postData) {\n      postData = nreq.postData\n    } else if (nreq.hasPostData) {\n      try {\n        let post = await network.getRequestPostData({\n          requestId: nreq.requestId\n        })\n        postData = Buffer.from(post.postData, 'base64')\n      } catch (e) {}\n    }\n    if (nreq.canSerializeResponse()) {\n      let resData\n      let responseHeaders = nreq.serializeResponseHeaders()\n      if (nreq.getBody) {\n        let wasError = false\n        try {\n          let rbody = await network.getResponseBody({\n            requestId: nreq.requestId\n          })\n          if (rbody.base64Encoded) {\n            resData = Buffer.from(rbody.body, 'base64')\n          } else {\n            resData = Buffer.from(rbody.body, 'utf8')\n          }\n        } catch (err) {\n          wasError = true\n        }\n        if (!wasError) {\n          responseHeaders = responseHeaders.replace(noGZ, '')\n          responseHeaders = responseHeaders.replace(\n            replaceContentLen,\n            `Content-Length: ${Buffer.byteLength(resData, 'utf8')}${CRLF}`\n          )\n        }\n      }\n      return this.writeRequestResponseRecords(\n        nreq.url,\n        {\n          headers: nreq.serializeRequestHeaders(),\n          data: postData\n        },\n        {\n          headers: responseHeaders,\n          data: resData\n        }\n      )\n    }\n    return this.writeRequestRecord(\n      nreq.url,\n      nreq.serializeRequestHeaders(),\n      postData\n    )\n  }\n}\n\n/**\n * @type {RemoteChromeWARCGenerator}\n */\nmodule.exports = RemoteChromeWARCGenerator\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/writers/remoteChrome.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 369,
    "kind": "class",
    "name": "RemoteChromeWARCGenerator",
    "memberof": "lib/writers/remoteChrome.js",
    "static": true,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/writers/remoteChrome.js",
    "importStyle": "RemoteChromeWARCGenerator",
    "description": "WARC Generator for use with chrome-remote-interface",
    "see": [
      "https://github.com/cyrus-and/chrome-remote-interface"
    ],
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "WARCWriterBase"
    ]
  },
  {
    "__docId__": 370,
    "kind": "method",
    "name": "generateWARC",
    "memberof": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator#generateWARC",
    "access": "public",
    "description": "",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "RemoteChromeRequestCapturer"
        ],
        "spread": false,
        "optional": false,
        "name": "capturer",
        "description": "The RemoteChrome request capturer that contains requests\nto be serialized to the WARC"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "The chrome-remote-interface Network object"
      },
      {
        "nullable": null,
        "types": [
          "WARCGenOpts"
        ],
        "spread": false,
        "optional": false,
        "name": "genOpts",
        "description": "Options for generating the WARC and optionally generating\nWARC info and metadata records"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<?Error>"
      ],
      "spread": false,
      "description": "A Promise that resolves when WARC generation is complete"
    }
  },
  {
    "__docId__": 371,
    "kind": "method",
    "name": "generateWarcEntry",
    "memberof": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/remoteChrome.js~RemoteChromeWARCGenerator#generateWarcEntry",
    "access": "public",
    "description": "Generate a WARC record",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "CDPRequestInfo"
        ],
        "spread": false,
        "optional": false,
        "name": "nreq",
        "description": "The captured HTTP info"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "network",
        "description": "The chrome-remote-interface Network object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 372,
    "kind": "file",
    "name": "lib/writers/warcFields.js",
    "content": "/**\r\n * @type {string}\r\n */\r\nconst CRLF = '\\r\\n'\r\n\r\n/**\r\n * @type {string}\r\n */\r\nconst CRLF2x = '\\r\\n\\r\\n'\r\n\r\n/**\r\n * @type {string}\r\n */\r\nconst recordSeparator = '\\r\\n\\r\\n'\r\n\r\n/**\r\n * @type {string}\r\n */\r\nconst WARCV = '1.1'\r\n\r\n/**\r\n * @type {string}\r\n */\r\nconst WARCSlashV = `WARC/${WARCV}${CRLF}`\r\n\r\n/**\r\n * @type {{warcinfo: string, metadata: string, request: string, response: string, revisit: string, resource: string, conversion: string, unknown: string, continuation: string}}\r\n */\r\nconst WARCTypes = {\r\n  warcinfo: 'warcinfo',\r\n  metadata: 'metadata',\r\n  request: 'request',\r\n  response: 'response',\r\n  revisit: 'revisit',\r\n  resource: 'resource',\r\n  conversion: 'conversion',\r\n  unknown: 'unknown',\r\n  continuation: 'continuation'\r\n}\r\n\r\nconst WARCContentTypes = {\r\n  warcFields: 'Content-Type: application/warc-fields\\r\\n',\r\n  httpRequest: 'Content-Type: application/http; msgtype=request\\r\\n',\r\n  httpResponse: 'Content-Type: application/http; msgtype=response\\r\\n'\r\n}\r\n\r\n/**\r\n * @param {string} uuid\r\n * @return {string}\r\n */\r\nfunction recordId (uuid) {\r\n  return `WARC-Record-ID: <urn:uuid:${uuid}>\\r\\n`\r\n}\r\n\r\n/**\r\n * @param {string} date\r\n * @return {string}\r\n */\r\nfunction warcDate (date) {\r\n  return `WARC-Date: ${date}${CRLF}`\r\n}\r\n\r\n/**\r\n * @param {string} targetURI\r\n * @return {string}\r\n */\r\nfunction warcTargetURI (targetURI) {\r\n  return `WARC-Target-URI: ${targetURI}${CRLF}`\r\n}\r\n\r\n/**\r\n * @param {string} type\r\n * @return {string}\r\n */\r\nfunction warcType (type) {\r\n  return `WARC-Type: ${type}${CRLF}`\r\n}\r\n\r\n/**\r\n * @param {string} fileName\r\n * @return {string}\r\n */\r\nfunction warcFilename (fileName) {\r\n  return `WARC-Filename: ${fileName}${CRLF}`\r\n}\r\n\r\n/**\r\n * @param {string|number} contentLen\r\n * @return {string}\r\n */\r\nfunction warcContentLength (contentLen) {\r\n  return `Content-Length: ${contentLen}${CRLF}`\r\n}\r\n\r\n/**\r\n * @param {string} contentType\r\n * @return {string}\r\n */\r\nfunction warcContentType (contentType) {\r\n  return `Content-Type: ${contentType}${CRLF}`\r\n}\r\n\r\n/**\r\n * @param {string} concurrentTo\r\n * @return {string}\r\n */\r\nfunction warcConcurrentTo (concurrentTo) {\r\n  return `WARC-Concurrent-To: ${concurrentTo}${CRLF}`\r\n}\r\n\r\n/**\r\n * @param {string} wid\r\n * @return {string}\r\n */\r\nfunction warcWarcInfoId (wid) {\r\n  return `WARC-Warcinfo-ID: <urn:uuid:${wid}>${CRLF}`\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} type\r\n * @param {Object} reqFields\r\n * @param {string} reqFields.id\r\n * @param {string} reqFields.date\r\n * @param {number} reqFields.len\r\n * @param {string} reqFields.targetURI\r\n * @return {string}\r\n */\r\nfunction requiredHeaderFields (type, { id, date, len, targetURI }) {\r\n  if (targetURI != null) {\r\n    return `${WARCSlashV}${warcType(type)}${recordId(id)}${warcDate(\r\n      date\r\n    )}${warcTargetURI(targetURI)}${warcContentLength(len)}`\r\n  }\r\n  return `${WARCSlashV}${warcType(type)}${recordId(id)}${warcDate(\r\n    date\r\n  )}${warcContentLength(len)}`\r\n}\r\n\r\n/**\r\n * @typedef {Object} WARCInfoHeader\r\n * @property {string} date - The date value for WARC-Date\r\n * @property {string} fileName - The name of the warc file\r\n * @property {string} rid - The id of the record\r\n * @property {number} len - The length of the records content\r\n */\r\n\r\n/**\r\n * @param {WARCInfoHeader} infoHeader\r\n * @return {string}\r\n */\r\nfunction warcInfoHeader (infoHeader) {\r\n  const required = `${requiredHeaderFields(WARCTypes.warcinfo, infoHeader)}${\r\n    WARCContentTypes.warcFields\r\n  }`\r\n  if (infoHeader.fileName != null) {\r\n    return `${required}${warcFilename(infoHeader.fileName)}`\r\n  }\r\n  return required\r\n}\r\n\r\n/**\r\n * @typedef {Object} WARCInfoContent\r\n * @property {string} version - The version of node-warc used to create the record\r\n * @property {string} isPartOfV - The value for isPartOf\r\n * @property {string} warcInfoDescription - A description for the warc\r\n * @property {string} ua - The user agent used to create the record\r\n */\r\n\r\n/**\r\n * @param {WARCInfoContent} infoContent\r\n * @return {string}\r\n */\r\nfunction warcInfoContent ({ version, isPartOfV, warcInfoDescription, ua }) {\r\n  const base = [\r\n    `software: node-warc/${version}${CRLF}format: WARC File Format ${WARCV}${CRLF}robots: ignore${CRLF}`\r\n  ]\r\n  if (isPartOfV != null) {\r\n    base.push(`isPartOf: ${isPartOfV}${CRLF}`)\r\n  }\r\n  if (warcInfoDescription != null) {\r\n    base.push(`description: ${warcInfoDescription}${CRLF}`)\r\n  }\r\n  if (ua != null) {\r\n    base.push(`http-header-user-agent: ${ua}${CRLF}`)\r\n  }\r\n  return base.join('')\r\n}\r\n\r\n/**\r\n * @typedef {Object} WARCMetadataHeader\r\n * @property {string} targetURI - The URI the records are for\r\n * @property {string} now - The date value for WARC-Date\r\n * @property {string} concurrentTo - The record id this metadata record is associated with\r\n * @property {string} rid - The record id of this record\r\n * @property {number} len - The length of this records content\r\n * @property {?string} wid - The record id of the Warcinfo record\r\n */\r\n\r\n/**\r\n * @param {WARCMetadataHeader} metadataHeader\r\n * @returns {string}\r\n */\r\nfunction warcMetadataHeader ({ targetURI, now, concurrentTo, rid, len, wid }) {\r\n  const base = [\r\n    requiredHeaderFields(WARCTypes.metadata, {\r\n      date: now,\r\n      len,\r\n      id: rid,\r\n      targetURI\r\n    }),\r\n    WARCContentTypes.warcFields\r\n  ]\r\n  if (concurrentTo != null) {\r\n    base.join(warcConcurrentTo(concurrentTo))\r\n  }\r\n  if (wid != null) {\r\n    base.push(warcWarcInfoId(wid))\r\n  }\r\n  return base.join('')\r\n}\r\n\r\n/**\r\n * @typedef {Object} WARCRequestHeader\r\n * @property {string} targetURI - The URI the record is for\r\n * @property {string} now - The date value for WARC-Date\r\n * @property {string} concurrentTo - The record id of the record this record associated with\r\n * @property {string} rid - The record id of this record\r\n * @property {number} len - The length of this records content\r\n * @property {?string} wid - The record id of the Warcinfo record\r\n */\r\n\r\n/**\r\n * @param {WARCRequestHeader} requestHeader\r\n * @returns {string}\r\n */\r\nfunction warcRequestHeader ({ targetURI, now, concurrentTo, rid, len, wid }) {\r\n  const base = [\r\n    requiredHeaderFields(WARCTypes.request, { date: now, len, id: rid, targetURI }),\r\n    WARCContentTypes.httpRequest\r\n  ]\r\n  if (concurrentTo != null) {\r\n    base.join(warcConcurrentTo(concurrentTo))\r\n  }\r\n  if (wid != null) {\r\n    base.push(warcWarcInfoId(wid))\r\n  }\r\n  return base.join('')\r\n}\r\n\r\n/**\r\n * @typedef {Object} WARCResponseHeader\r\n * @property {string} targetURI - The URI the record is for\r\n * @property {string} now - The date value for WARC-Date\r\n * @property {string} rid - The record id of this record\r\n * @property {number} len - The length of this records content\r\n * @property {?string} wid - The record id of the Warcinfo record\r\n */\r\n\r\n/**\r\n * @param {WARCResponseHeader} responseHeader\r\n * @returns {string}\r\n */\r\nfunction warcResponseHeader ({ targetURI, now, rid, len, wid }) {\r\n  const base = [\r\n    requiredHeaderFields(WARCTypes.response, { date: now, len, id: rid, targetURI }),\r\n    WARCContentTypes.httpResponse\r\n  ]\r\n  if (wid != null) {\r\n    base.push(warcWarcInfoId(wid))\r\n  }\r\n  return base.join('')\r\n}\r\n\r\nmodule.exports = {\r\n  /**\r\n   * @type {function(headerInfo: WARCInfoHeader): string}\r\n   */\r\n  warcInfoHeader,\r\n  /**\r\n   * @type {function(infoContent: WARCInfoContent): string}\r\n   */\r\n  warcInfoContent,\r\n  /**\r\n   * @type {function(reqiestData: WARCRequestHeader): string}\r\n   */\r\n  warcRequestHeader,\r\n  warcResponseHeader,\r\n  warcMetadataHeader,\r\n  recordSeparator,\r\n  CRLF,\r\n  CRLF2x\r\n}\r\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/writers/warcFields.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 373,
    "kind": "variable",
    "name": "CRLF",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~CRLF",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 4,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 374,
    "kind": "variable",
    "name": "CRLF2x",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~CRLF2x",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 9,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 375,
    "kind": "variable",
    "name": "recordSeparator",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~recordSeparator",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 14,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 376,
    "kind": "variable",
    "name": "WARCV",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~WARCV",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 377,
    "kind": "variable",
    "name": "WARCSlashV",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~WARCSlashV",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 378,
    "kind": "variable",
    "name": "WARCTypes",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~WARCTypes",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "{warcinfo: string, metadata: string, request: string, response: string, revisit: string, resource: string, conversion: string, unknown: string, continuation: string}"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 379,
    "kind": "variable",
    "name": "WARCContentTypes",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~WARCContentTypes",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "{\"warcFields\": string, \"httpRequest\": string, \"httpResponse\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 380,
    "kind": "function",
    "name": "recordId",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~recordId",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [
      {
        "name": "uuid",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 381,
    "kind": "function",
    "name": "warcDate",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcDate",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 382,
    "kind": "function",
    "name": "warcTargetURI",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcTargetURI",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 67,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 383,
    "kind": "function",
    "name": "warcType",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcType",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 384,
    "kind": "function",
    "name": "warcFilename",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcFilename",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fileName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 385,
    "kind": "function",
    "name": "warcContentLength",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcContentLength",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "contentLen",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 386,
    "kind": "function",
    "name": "warcContentType",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcContentType",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contentType",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 387,
    "kind": "function",
    "name": "warcConcurrentTo",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcConcurrentTo",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "concurrentTo",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 388,
    "kind": "function",
    "name": "warcWarcInfoId",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcWarcInfoId",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wid",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 389,
    "kind": "function",
    "name": "requiredHeaderFields",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~requiredHeaderFields",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "reqFields",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "reqFields.id",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "reqFields.date",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "reqFields.len",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "reqFields.targetURI",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 390,
    "kind": "typedef",
    "name": "WARCInfoHeader",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~WARCInfoHeader",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "The date value for WARC-Date"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fileName",
        "description": "The name of the warc file"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rid",
        "description": "The id of the record"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "The length of the records content"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WARCInfoHeader"
    }
  },
  {
    "__docId__": 391,
    "kind": "function",
    "name": "warcInfoHeader",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcInfoHeader",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCInfoHeader"
        ],
        "spread": false,
        "optional": false,
        "name": "infoHeader",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 392,
    "kind": "typedef",
    "name": "WARCInfoContent",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~WARCInfoContent",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "version",
        "description": "The version of node-warc used to create the record"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "isPartOfV",
        "description": "The value for isPartOf"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "warcInfoDescription",
        "description": "A description for the warc"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ua",
        "description": "The user agent used to create the record"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WARCInfoContent"
    }
  },
  {
    "__docId__": 393,
    "kind": "function",
    "name": "warcInfoContent",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcInfoContent",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 174,
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCInfoContent"
        ],
        "spread": false,
        "optional": false,
        "name": "infoContent",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 394,
    "kind": "typedef",
    "name": "WARCMetadataHeader",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~WARCMetadataHeader",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": "The URI the records are for"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "now",
        "description": "The date value for WARC-Date"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "concurrentTo",
        "description": "The record id this metadata record is associated with"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rid",
        "description": "The record id of this record"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "The length of this records content"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wid",
        "description": "The record id of the Warcinfo record"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WARCMetadataHeader"
    }
  },
  {
    "__docId__": 395,
    "kind": "function",
    "name": "warcMetadataHeader",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcMetadataHeader",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 204,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCMetadataHeader"
        ],
        "spread": false,
        "optional": false,
        "name": "metadataHeader",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 396,
    "kind": "typedef",
    "name": "WARCRequestHeader",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~WARCRequestHeader",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": "The URI the record is for"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "now",
        "description": "The date value for WARC-Date"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "concurrentTo",
        "description": "The record id of the record this record associated with"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rid",
        "description": "The record id of this record"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "The length of this records content"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wid",
        "description": "The record id of the Warcinfo record"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WARCRequestHeader"
    }
  },
  {
    "__docId__": 397,
    "kind": "function",
    "name": "warcRequestHeader",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcRequestHeader",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 237,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCRequestHeader"
        ],
        "spread": false,
        "optional": false,
        "name": "requestHeader",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 398,
    "kind": "typedef",
    "name": "WARCResponseHeader",
    "memberof": "lib/writers/warcFields.js",
    "static": true,
    "longname": "lib/writers/warcFields.js~WARCResponseHeader",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": "The URI the record is for"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "now",
        "description": "The date value for WARC-Date"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rid",
        "description": "The record id of this record"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": "The length of this records content"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "wid",
        "description": "The record id of the Warcinfo record"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WARCResponseHeader"
    }
  },
  {
    "__docId__": 399,
    "kind": "function",
    "name": "warcResponseHeader",
    "memberof": "lib/writers/warcFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcFields.js~warcResponseHeader",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 264,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "WARCResponseHeader"
        ],
        "spread": false,
        "optional": false,
        "name": "responseHeader",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 400,
    "kind": "file",
    "name": "lib/writers/warcWriterBase.js",
    "content": "const fs = require('fs-extra')\nconst zlib = require('zlib')\nconst Path = require('path')\nconst uuid = require('uuid/v1')\nconst EventEmitter = require('eventemitter3')\nconst {\n  warcInfoHeader,\n  warcInfoContent,\n  warcRequestHeader,\n  warcResponseHeader,\n  warcMetadataHeader,\n  recordSeparator,\n  CRLF,\n  CRLF2x\n} = require('./warcFields')\n\n/**\n * @type {Buffer}\n */\nconst recordSeparatorBuffer = Buffer.from(recordSeparator, 'utf8')\n\n/**\n * @type {Buffer}\n */\nconst CRLFBuffer = Buffer.from(CRLF, 'utf8')\n/**\n *\n * @param {string} string\n * @param {?Buffer|?string} maybeBuffer\n * @return {Buffer}\n */\nfunction makeContentBuffer (string, maybeBuffer) {\n  if (maybeBuffer != null) {\n    const strBuff = string.endsWith(CRLF2x)\n      ? Buffer.from(`${CRLF}${string}`, 'utf8')\n      : Buffer.from(`${CRLF}${string}${CRLF}`, 'utf8')\n    const cntBuffer = Buffer.isBuffer(maybeBuffer)\n      ? maybeBuffer\n      : Buffer.from(maybeBuffer, 'utf8')\n    return Buffer.concat(\n      [strBuff, cntBuffer],\n      strBuff.length + cntBuffer.length\n    )\n  }\n  return Buffer.from(`${CRLF}${string}`, 'utf8')\n}\n\n/**\n * @desc Default options that control how WARC writting is done\n * @type {{appending: boolean, gzip: boolean}}\n */\nconst defaultOpts = {\n  appending: false,\n  gzip: process.env.NODEWARC_WRITE_GZIPPED != null\n}\n\n/**\n * @extends {EventEmitter}\n * @desc Base class used for writing to the WARC\n */\nclass WARCWriterBase extends EventEmitter {\n  /**\n   * @desc Create a new WARCWriter\n   */\n  constructor () {\n    super()\n    /**\n     * @type {?WriteStream}\n     * @private\n     */\n    this._warcOutStream = null\n    /**\n     * @type {?Error}\n     * @private\n     */\n    this._lastError = null\n    /**\n     * @type {?string}\n     * @private\n     */\n    this._now = null\n    /**\n     * @type {?string}\n     * @private\n     */\n    this._fileName = null\n    /**\n     * @type {?string}\n     * @private\n     */\n    this._warcInfoId = null\n\n    /**\n     * @type {{appending: boolean, gzip: boolean}}\n     */\n    this.opts = defaultOpts\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this._version = '3.0.0'\n    this._onFinish = this._onFinish.bind(this)\n    this._onError = this._onError.bind(this)\n  }\n\n  /**\n   * @desc Initialize the writer. The options object is optional and defaults to `appending = false` and `gzip = process.env.NODEWARC_WRITE_GZIPPED != null`.\n   * Writing gzipped records is also controllable by setting `NODEWARC_WRITE_GZIPPED` environment variable.\n   * Options supplied to this method override the default options.\n   * @param {string} warcPath - the path for the WARC file to be written\n   * @param {?WARCFileOpts} [options] - write options controlling how the WARC should be written\n   */\n  initWARC (warcPath, options) {\n    this.opts = Object.assign({}, defaultOpts, options || {})\n    if (this.opts.appending) {\n      this._warcOutStream = fs.createWriteStream(warcPath, {\n        flags: 'a',\n        encoding: 'utf8'\n      })\n    } else {\n      this._warcOutStream = fs.createWriteStream(warcPath, { encoding: 'utf8' })\n    }\n    this._warcOutStream.on('finish', this._onFinish)\n    this._warcOutStream.on('error', this._onError)\n    let now = new Date().toISOString()\n    this._now = now.substr(0, now.indexOf('.')) + 'Z'\n    this._fileName = Path.basename(warcPath)\n  }\n\n  /**\n   * @param {string} targetURI\n   * @param {{headers: string, data?: Buffer|string}} reqData\n   * @param {{headers: string, data?: Buffer|string}} resData\n   * @return {Promise<void>}\n   */\n  async writeRequestResponseRecords (targetURI, reqData, resData) {\n    const resRecId = uuid()\n    await this._writeRequestRecord(\n      targetURI,\n      resRecId,\n      reqData.headers,\n      reqData.data\n    )\n    return this._writeResponseRecord(\n      targetURI,\n      resRecId,\n      resData.headers,\n      resData.data\n    )\n  }\n\n  /**\n   * @desc Write arbitrary number of items to the WARC\n   * @param {Buffer[]} recordParts\n   * @return {Promise<void>}\n   */\n  async writeRecordChunks (...recordParts) {\n    for (let chunk of recordParts) {\n      await this.writeRecordBlock(chunk)\n    }\n  }\n\n  /**\n   * @desc Write out the WARC-Type: info records\n   * @param {string} isPartOfV - The value of isPartOf\n   * @param {string} warcInfoDescription\n   * @param {string} ua - user agent\n   * @return {Promise<void>}\n   */\n  writeWarcInfoRecord (isPartOfV, warcInfoDescription, ua) {\n    return this.writeWarcRawInfoRecord(\n      Buffer.from(\n        warcInfoContent({\n          version: this._version,\n          isPartOfV,\n          warcInfoDescription,\n          ua\n        }),\n        'utf8'\n      )\n    )\n  }\n\n  /**\n   * @param {string|Buffer} warcInfoContent\n   */\n  writeWarcRawInfoRecord (warcInfoContent) {\n    this._warcInfoId = uuid()\n    const whct = Buffer.isBuffer(warcInfoContent)\n      ? warcInfoContent\n      : Buffer.from(warcInfoContent, 'utf8')\n    const whc = Buffer.concat([CRLFBuffer, whct], CRLFBuffer.length + whct.length)\n    const wh = Buffer.from(\n      warcInfoHeader({\n        date: this._now,\n        fileName: this._fileName,\n        len: whc.length,\n        rid: this._warcInfoId\n      }),\n      'utf8'\n    )\n    const totalLength = wh.length + whc.length + recordSeparatorBuffer.length\n    return this.writeRecordBlock(\n      Buffer.concat([wh, whc, recordSeparatorBuffer], totalLength)\n    )\n  }\n\n  /**\n   * @desc Write WARC-Type: metadata for outlinks\n   * @param {string} targetURI\n   * @param {string} outlinks\n   * @return {Promise.<void>}\n   */\n  writeWarcMetadataOutlinks (targetURI, outlinks) {\n    return this.writeWarcMetadata(targetURI, outlinks)\n  }\n\n  /**\n   * @desc Write WARC-Type: metadata record\n   * @param {string} targetURI - The URL of the page the this metadata record is for\n   * @param {string|Buffer} metaData - A string or buffer containing metadata information to be used as this records content\n   * @return {Promise<void>}\n   */\n  writeWarcMetadata (targetURI, metaData) {\n    const wmhc = Buffer.isBuffer(metaData)\n      ? Buffer.concat(\n        [CRLFBuffer, metaData],\n        CRLFBuffer.length + metaData.length\n      )\n      : Buffer.from(`${CRLF}${metaData}`, 'utf8')\n    const wmh = Buffer.from(\n      warcMetadataHeader({\n        targetURI,\n        now: this._now,\n        len: wmhc.length,\n        concurrentTo: this._warcInfoId,\n        rid: uuid()\n      }),\n      'utf8'\n    )\n    const totalLength = wmhc.length + wmh.length + recordSeparatorBuffer.length\n    return this.writeRecordBlock(\n      Buffer.concat([wmh, wmhc, recordSeparatorBuffer], totalLength)\n    )\n  }\n\n  /**\n   * @desc Write A Request Record\n   * @param {string} targetURI - The URL of the response\n   * @param {string} httpHeaderString - Stringified HTTP headers\n   * @param {string|Buffer} [requestData] - Body of the request if any\n   * @return {Promise<void>}\n   */\n  writeRequestRecord (targetURI, httpHeaderString, requestData) {\n    return this._writeRequestRecord(\n      targetURI,\n      null,\n      httpHeaderString,\n      requestData\n    )\n  }\n\n  /**\n   * @desc Write A Response Record\n   * @param {string} targetURI - The URL of the response\n   * @param {string} httpHeaderString - Stringified HTTP headers\n   * @param {string|Buffer} [responseData] - The response body if it exists\n   * @return {Promise<void>}\n   */\n  writeResponseRecord (targetURI, httpHeaderString, responseData) {\n    return this._writeResponseRecord(\n      targetURI,\n      uuid(),\n      httpHeaderString,\n      responseData\n    )\n  }\n\n  /**\n   * @desc Write an record block to the WARC\n   * @param {Buffer} recordBuffer\n   * @return {Promise<void>}\n   */\n  writeRecordBlock (recordBuffer) {\n    return new Promise((resolve, reject) => {\n      if (this.opts.gzip) {\n        // we're in gzipped mode - GZip the buffer\n        recordBuffer = zlib.gzipSync(recordBuffer)\n      }\n\n      if (!this._warcOutStream.write(recordBuffer, 'utf8')) {\n        this._warcOutStream.once('drain', resolve)\n      } else {\n        resolve()\n      }\n    })\n  }\n\n  /**\n   * @desc Close  the underlying filestream to the WARC currently being written.\n   * The `finished` event will not be emitted until this method has been called\n   */\n  end () {\n    if (this._warcOutStream) {\n      this._warcOutStream.end()\n    }\n  }\n\n  /**\n   * @desc Write A Request Record\n   * @param {string} targetURI - The URL of the response\n   * @param {?string} resId - The id of the record this request recorrd is concurrent to, typically its response\n   * @param {string} httpHeaderString - Stringified HTTP headers\n   * @param {string|Buffer} [requestData] - Body of the request if any\n   * @return {Promise<void>}\n   */\n  _writeRequestRecord (targetURI, resId, httpHeaderString, requestData) {\n    const reqHeadContentBuffer = makeContentBuffer(\n      httpHeaderString,\n      requestData\n    )\n    const reqWHeader = Buffer.from(\n      warcRequestHeader({\n        targetURI,\n        concurrentTo: resId,\n        now: this._now,\n        rid: uuid(),\n        wid: this._warcInfoId,\n        len: reqHeadContentBuffer.length\n      }),\n      'utf8'\n    )\n    const totalLength =\n      reqWHeader.length +\n      reqHeadContentBuffer.length +\n      recordSeparatorBuffer.length\n    return this.writeRecordBlock(\n      Buffer.concat(\n        [reqWHeader, reqHeadContentBuffer, recordSeparatorBuffer],\n        totalLength\n      )\n    )\n  }\n\n  /**\n   * @desc Write A Response Record\n   * @param {string} targetURI - The URL of the response\n   * @param {string} resId - The id to be used for the response record\n   * @param {string} httpHeaderString - Stringified HTTP headers\n   * @param {string|Buffer} [responseData] - The response body if it exists\n   * @return {Promise<void>}\n   */\n  _writeResponseRecord (targetURI, resId, httpHeaderString, responseData) {\n    const resHeaderContentBuffer = makeContentBuffer(\n      httpHeaderString,\n      responseData\n    )\n    const respWHeader = Buffer.from(\n      warcResponseHeader({\n        targetURI,\n        now: this._now,\n        rid: resId,\n        wid: this._warcInfoId,\n        len: resHeaderContentBuffer.length\n      }),\n      'utf8'\n    )\n    const totalLength =\n      respWHeader.length +\n      resHeaderContentBuffer.length +\n      recordSeparatorBuffer.length\n    return this.writeRecordBlock(\n      Buffer.concat(\n        [respWHeader, resHeaderContentBuffer, recordSeparatorBuffer],\n        totalLength\n      )\n    )\n  }\n\n  /**\n   * @desc Called when the WARC generation is finished\n   * @emits {finished} emitted when WARC generation is complete\n   * @private\n   */\n  _onFinish () {\n    let le = this._lastError\n    this._lastError = null\n    this._warcOutStream.removeAllListeners()\n    this._warcOutStream.destroy()\n    this._warcOutStream = null\n    this._now = null\n    this._fileName = null\n    this._warcInfoId = null\n    if (le) {\n      this.emit('finished', le)\n    } else {\n      this.emit('finished')\n    }\n  }\n\n  /**\n   * @desc Emits an error if one occurs\n   * @param {Error} err\n   * @emits {error} The error that occurred\n   * @private\n   */\n  _onError (err) {\n    this._lastError = err\n    this.emit('error', err)\n  }\n}\n\n/**\n * @type {WARCWriterBase}\n */\nmodule.exports = WARCWriterBase\n\n/**\n * @typedef {Object} WARCFileOpts\n * @property {boolean} [appending] - Should the WARC writer append to an existing warc?\n * @property {boolean} [gzip] - Should the WARC writer generate gziped records?\n */\n\n/**\n * @typedef {Object} WARCInitOpts\n * @property {string} warcPath - Path the warc file to be written to\n * @property {boolean} [appending] - Should the WARC writer append to an existing warc?\n * @property {boolean} [gzip] - Should the WARC writer generate gziped records?\n */\n\n/**\n * @typedef {Object} Metadata\n * @property {string} targetURI - The target URI for the metadata record\n * @property {?string|Buffer} [content] - The contents of the metadata record\n */\n\n/**\n * @typedef {Object} WARCGenOpts\n * @property {WARCInitOpts} warcOpts - Options for the writing of the WARC file\n * @property {?WARCInfoContent} [winfo = null] - Optional contents for the WARC info record\n * @property {?Metadata} [metadata = null] - Optional metadata contents\n */\n",
    "static": true,
    "longname": "/home/john/WebstormProjects/node-warc/lib/writers/warcWriterBase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 401,
    "kind": "variable",
    "name": "recordSeparatorBuffer",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~recordSeparatorBuffer",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 402,
    "kind": "variable",
    "name": "CRLFBuffer",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~CRLFBuffer",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 403,
    "kind": "function",
    "name": "makeContentBuffer",
    "memberof": "lib/writers/warcWriterBase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~makeContentBuffer",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": ""
      },
      {
        "nullable": true,
        "types": [
          "Buffer",
          "?string"
        ],
        "spread": false,
        "optional": false,
        "name": "maybeBuffer",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 404,
    "kind": "variable",
    "name": "defaultOpts",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~defaultOpts",
    "access": "public",
    "export": false,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": null,
    "description": "Default options that control how WARC writting is done",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "{appending: boolean, gzip: boolean}"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 405,
    "kind": "class",
    "name": "WARCWriterBase",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "access": "public",
    "export": true,
    "importPath": "node-warc/lib/writers/warcWriterBase.js",
    "importStyle": "WARCWriterBase",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "interface": false,
    "extends": [
      "eventemitter3~EventEmitter"
    ]
  },
  {
    "__docId__": 406,
    "kind": "typedef",
    "name": "WARCFileOpts",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~WARCFileOpts",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "appending",
        "description": "Should the WARC writer append to an existing warc?"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "gzip",
        "description": "Should the WARC writer generate gziped records?"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WARCFileOpts"
    }
  },
  {
    "__docId__": 407,
    "kind": "typedef",
    "name": "WARCInitOpts",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~WARCInitOpts",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "warcPath",
        "description": "Path the warc file to be written to"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "appending",
        "description": "Should the WARC writer append to an existing warc?"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "gzip",
        "description": "Should the WARC writer generate gziped records?"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WARCInitOpts"
    }
  },
  {
    "__docId__": 408,
    "kind": "typedef",
    "name": "Metadata",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~Metadata",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": "The target URI for the metadata record"
      },
      {
        "nullable": true,
        "types": [
          "string",
          "Buffer"
        ],
        "spread": false,
        "optional": true,
        "name": "content",
        "description": "The contents of the metadata record"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Metadata"
    }
  },
  {
    "__docId__": 409,
    "kind": "typedef",
    "name": "WARCGenOpts",
    "memberof": "lib/writers/warcWriterBase.js",
    "static": true,
    "longname": "lib/writers/warcWriterBase.js~WARCGenOpts",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "WARCInitOpts"
        ],
        "spread": false,
        "optional": false,
        "name": "warcOpts",
        "description": "Options for the writing of the WARC file"
      },
      {
        "nullable": true,
        "types": [
          "WARCInfoContent"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " null",
        "defaultRaw": null,
        "name": "winfo",
        "description": "Optional contents for the WARC info record"
      },
      {
        "nullable": true,
        "types": [
          "Metadata"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " null",
        "defaultRaw": null,
        "name": "metadata",
        "description": "Optional metadata contents"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WARCGenOpts"
    }
  },
  {
    "__docId__": 410,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#constructor",
    "access": "public",
    "description": "Create a new WARCWriter",
    "lineNumber": 65
  },
  {
    "__docId__": 411,
    "kind": "member",
    "name": "_warcOutStream",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_warcOutStream",
    "access": "private",
    "description": "",
    "lineNumber": 71,
    "type": {
      "nullable": true,
      "types": [
        "WriteStream"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 412,
    "kind": "member",
    "name": "_lastError",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_lastError",
    "access": "private",
    "description": "",
    "lineNumber": 76,
    "type": {
      "nullable": true,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 413,
    "kind": "member",
    "name": "_now",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_now",
    "access": "private",
    "description": "",
    "lineNumber": 81,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 414,
    "kind": "member",
    "name": "_fileName",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_fileName",
    "access": "private",
    "description": "",
    "lineNumber": 86,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 415,
    "kind": "member",
    "name": "_warcInfoId",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_warcInfoId",
    "access": "private",
    "description": "",
    "lineNumber": 91,
    "type": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 416,
    "kind": "member",
    "name": "opts",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#opts",
    "access": "public",
    "description": "",
    "lineNumber": 96,
    "type": {
      "nullable": null,
      "types": [
        "{appending: boolean, gzip: boolean}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 417,
    "kind": "member",
    "name": "_version",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_version",
    "access": "private",
    "description": "",
    "lineNumber": 102,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 420,
    "kind": "method",
    "name": "initWARC",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#initWARC",
    "access": "public",
    "description": "Initialize the writer. The options object is optional and defaults to `appending = false` and `gzip = process.env.NODEWARC_WRITE_GZIPPED != null`.\nWriting gzipped records is also controllable by setting `NODEWARC_WRITE_GZIPPED` environment variable.\nOptions supplied to this method override the default options.",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "warcPath",
        "description": "the path for the WARC file to be written"
      },
      {
        "nullable": true,
        "types": [
          "WARCFileOpts"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "write options controlling how the WARC should be written"
      }
    ],
    "return": null
  },
  {
    "__docId__": 426,
    "kind": "method",
    "name": "writeRequestResponseRecords",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeRequestResponseRecords",
    "access": "public",
    "description": "",
    "lineNumber": 137,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "{headers: string, data?: Buffer|string}"
        ],
        "spread": false,
        "optional": false,
        "name": "reqData",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "{headers: string, data?: Buffer|string}"
        ],
        "spread": false,
        "optional": false,
        "name": "resData",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 427,
    "kind": "method",
    "name": "writeRecordChunks",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeRecordChunks",
    "access": "public",
    "description": "Write arbitrary number of items to the WARC",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "recordParts",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 428,
    "kind": "method",
    "name": "writeWarcInfoRecord",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeWarcInfoRecord",
    "access": "public",
    "description": "Write out the WARC-Type: info records",
    "lineNumber": 171,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "isPartOfV",
        "description": "The value of isPartOf"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "warcInfoDescription",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ua",
        "description": "user agent"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 429,
    "kind": "method",
    "name": "writeWarcRawInfoRecord",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeWarcRawInfoRecord",
    "access": "public",
    "description": "",
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "warcInfoContent",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 431,
    "kind": "method",
    "name": "writeWarcMetadataOutlinks",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeWarcMetadataOutlinks",
    "access": "public",
    "description": "Write WARC-Type: metadata for outlinks",
    "lineNumber": 215,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "outlinks",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 432,
    "kind": "method",
    "name": "writeWarcMetadata",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeWarcMetadata",
    "access": "public",
    "description": "Write WARC-Type: metadata record",
    "lineNumber": 225,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": "The URL of the page the this metadata record is for"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "metaData",
        "description": "A string or buffer containing metadata information to be used as this records content"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 433,
    "kind": "method",
    "name": "writeRequestRecord",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeRequestRecord",
    "access": "public",
    "description": "Write A Request Record",
    "lineNumber": 255,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": "The URL of the response"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "httpHeaderString",
        "description": "Stringified HTTP headers"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Buffer"
        ],
        "spread": false,
        "optional": true,
        "name": "requestData",
        "description": "Body of the request if any"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 434,
    "kind": "method",
    "name": "writeResponseRecord",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeResponseRecord",
    "access": "public",
    "description": "Write A Response Record",
    "lineNumber": 271,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": "The URL of the response"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "httpHeaderString",
        "description": "Stringified HTTP headers"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Buffer"
        ],
        "spread": false,
        "optional": true,
        "name": "responseData",
        "description": "The response body if it exists"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "writeRecordBlock",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#writeRecordBlock",
    "access": "public",
    "description": "Write an record block to the WARC",
    "lineNumber": 285,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "recordBuffer",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 436,
    "kind": "method",
    "name": "end",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#end",
    "access": "public",
    "description": "Close  the underlying filestream to the WARC currently being written.\nThe `finished` event will not be emitted until this method has been called",
    "lineNumber": 304,
    "params": [],
    "return": null
  },
  {
    "__docId__": 437,
    "kind": "method",
    "name": "_writeRequestRecord",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_writeRequestRecord",
    "access": "private",
    "description": "Write A Request Record",
    "lineNumber": 318,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": "The URL of the response"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "resId",
        "description": "The id of the record this request recorrd is concurrent to, typically its response"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "httpHeaderString",
        "description": "Stringified HTTP headers"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Buffer"
        ],
        "spread": false,
        "optional": true,
        "name": "requestData",
        "description": "Body of the request if any"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 438,
    "kind": "method",
    "name": "_writeResponseRecord",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_writeResponseRecord",
    "access": "private",
    "description": "Write A Response Record",
    "lineNumber": 354,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetURI",
        "description": "The URL of the response"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "resId",
        "description": "The id to be used for the response record"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "httpHeaderString",
        "description": "Stringified HTTP headers"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Buffer"
        ],
        "spread": false,
        "optional": true,
        "name": "responseData",
        "description": "The response body if it exists"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 439,
    "kind": "method",
    "name": "_onFinish",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_onFinish",
    "access": "private",
    "description": "Called when the WARC generation is finished",
    "lineNumber": 386,
    "emits": [
      {
        "types": [
          "finished"
        ],
        "description": "emitted when WARC generation is complete"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 445,
    "kind": "method",
    "name": "_onError",
    "memberof": "lib/writers/warcWriterBase.js~WARCWriterBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/writers/warcWriterBase.js~WARCWriterBase#_onError",
    "access": "private",
    "description": "Emits an error if one occurs",
    "lineNumber": 408,
    "params": [
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "err",
        "description": ""
      }
    ],
    "emits": [
      {
        "types": [
          "error"
        ],
        "description": "The error that occurred"
      }
    ],
    "return": null
  },
  {
    "kind": "index",
    "content": "# node-warc\nParse Web Archive (WARC) files or create WARC files using [Electron](https://electron.atom.io/), [chrome-remote-interface](https://github.com/cyrus-and/chrome-remote-interface), or [Puppeteer](https://github.com/GoogleChrome/puppeteer)\n\nRun `npm install node-warc` or `yarn add node-warc` to ge started\n\n[![npm Package](https://img.shields.io/npm/v/node-warc.svg?style=flat-square)](https://www.npmjs.com/package/node-warc)\n\n## Documentation\nFull documentation available at [n0tan3rd.github.io/node-warc](https://n0tan3rd.github.io/node-warc/)\n\n## Example parsing usage\n\n\n### Using async iteration\n**Requires node 10 or greater**\n```js\nconst fs = require('fs')\nconst zlib = require('zlib')\n// recordIterator only exported if async iteration on readable streams is available\nconst { recordIterator } = require('node-warc')\n\nasync function iterateRecords (warcStream) {\n  for await (const record of recordIterator(warcStream)) {\n    console.log(record)\n  }\n}\n\niterateRecords(\n  fs.createReadStream('<path-to-gzipd-warcfile>').pipe(zlib.createGunzip())\n).then(() => {\n  console.log('done')\n})\n```\n\nOr using one of the parsers\n```js\nfor await (const record of new AutoWARCParser('<path-to-warcfile>')) {\n    console.log(record)\n}\n```\n\n### Using Stream Transform\n```js\nconst fs = require('fs')\nconst { WARCStreamTransform } = require('node-warc')\n\nfs\n  .createReadStream('<path-to-warcfile>')\n  .pipe(new WARCStreamTransform())\n  .on('data', record => {\n    console.log(record)\n  })\n```\n\n### Both ``.warc`` and ``.warc.gz``\n```js\nconst { AutoWARCParser } = require('node-warc')\n\nconst parser = new AutoWARCParser('<path-to-warcfile>')\nparser.on('record', record => { console.log(record) })\nparser.on('done', () => { console.log('finished') })\nparser.on('error', error => { console.error(error) })\nparser.start()\n```\n\n### Only gzip'd warc files\n```js\nconst { WARCGzParser } = require('node-warc')\n\nconst parser = new WARCGzParser('<path-to-warcfile>')\nparser.on('record', record => { console.log(record) })\nparser.on('done', () => { console.log('finished') })\nparser.on('error', error => { console.error(error) })\nparser.start()\n```\n\n### Only non gzip'd warc files\n```js\nconst { WARCGzParser } = require('node-warc')\n\nconst parser = new WARCParser('<path-to-gzipd-warcfile>')\nparser.on('record', record => { console.log(record) })\nparser.on('done', () => { console.log('finished') })\nparser.on('error', error => { console.error(error) })\nparser.start()\n```\n\n\n## Environment\n* `NODEWARC_WRITE_GZIPPED` - writes gzipped records to WARC outputs.",
    "longname": "/home/john/WebstormProjects/node-warc/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"node-warc\",\n  \"version\": \"3.0.1\",\n  \"description\": \"Parse And Write Web Archive Records (WARC) Files\",\n  \"main\": \"index.js\",\n  \"author\": {\n    \"name\": \"John Berlin\",\n    \"email\": \"n0tan3rd@gmail.com\"\n  },\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/N0taN3rd/node-warc.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/N0taN3rd/node-warc/issues\"\n  },\n  \"keywords\": [\n    \"warc\",\n    \"warc.gz\",\n    \"warc-parsing\",\n    \"web-archiving\",\n    \"web archiving Electron\",\n    \"web archiving Chrome\",\n    \"Electron\",\n    \"Chrome\"\n  ],\n  \"engines\": {\n    \"node\": \">=8.0.0\"\n  },\n  \"scripts\": {\n    \"lint\": \"standard | snazzy\",\n    \"fix-lint\": \"standard --fix\",\n    \"pretty\": \"prettier-standard lib/**/*.js\",\n    \"doc\": \"esdoc\",\n    \"test\": \"ava --verbose\",\n    \"test-report\": \"nyc ava --verbose\",\n    \"report-html\": \"nyc report --reporter=html\",\n    \"publish-docs\": \"gh-pages -d docs\"\n  },\n  \"eslintConfig\": {\n    \"env\": {\n      \"node\": true\n    }\n  },\n  \"dependencies\": {\n    \"bluebird\": \"^3.5.3\",\n    \"eventemitter3\": \"^3.1.0\",\n    \"fs-extra\": \"^7.0.1\",\n    \"headless-chrome-crawler\": \"^1.8.0\",\n    \"lodash\": \"^4.17.11\",\n    \"moment\": \"^2.22.2\",\n    \"untildify\": \"^3.0.3\",\n    \"uuid\": \"^3.3.2\"\n  },\n  \"devDependencies\": {\n    \"@types/fs-extra\": \"^5.0.4\",\n    \"@types/node\": \"^10.12.5\",\n    \"@types/puppeteer\": \"^1.10.0\",\n    \"ava\": \"^1.0.0-beta.8\",\n    \"chalk\": \"^2.4.1\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-external-ecmascript-plugin\": \"^1.0.0\",\n    \"esdoc-inject-style-plugin\": \"^1.0.0\",\n    \"esdoc-node\": \"^1.0.3\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"gh-pages\": \"^2.0.1\",\n    \"microtime\": \"^2.1.8\",\n    \"nyc\": \"^13.1.0\",\n    \"perfy\": \"^1.1.5\",\n    \"prettier-standard\": \"^8.0.1\",\n    \"pretty-time\": \"^1.1.0\",\n    \"puppeteer\": \"^1.10.0\",\n    \"rxjs\": \"^6.3.3\",\n    \"snazzy\": \"^8.0.0\",\n    \"standard\": \"^12.0.1\"\n  },\n  \"ava\": {\n    \"files\": [\n      \"test/*.js\"\n    ],\n    \"sources\": [\n      \"lib/**/*\"\n    ]\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"test/**\"\n    ]\n  },\n  \"resolutions\": {\n    \"**/graceful-fs\": \"4.1.11\",\n    \"**/universalify\": \"0.1.2\"\n  }\n}\n",
    "longname": "/home/john/WebstormProjects/node-warc/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]